import { ResponseError } from '@backstage/errors';

class StackstormClient {
  discoveryApi;
  fetchApi;
  webUrl;
  constructor({
    discoveryApi,
    fetchApi,
    webUrl
  }) {
    this.discoveryApi = discoveryApi;
    this.fetchApi = fetchApi;
    this.webUrl = webUrl;
  }
  static fromConfig(config, dependencies) {
    return new StackstormClient({
      discoveryApi: dependencies.discoveryApi,
      fetchApi: dependencies.fetchApi,
      webUrl: config.getString("stackstorm.webUrl")
    });
  }
  async get(input) {
    const apiUrl = `${await this.discoveryApi.getBaseUrl("proxy")}/stackstorm`;
    const response = await this.fetchApi.fetch(`${apiUrl}${input}`, {
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (!response.ok) throw await ResponseError.fromResponse(response);
    return await response.json();
  }
  async getExecutions(limit, offset) {
    const params = {
      limit: limit?.toString() || "10",
      offset: offset?.toString() || "0",
      include_attributes: "id,status,start_timestamp,action.ref,action.name,rule.ref",
      parent: "null"
    };
    const path = `/executions?${new URLSearchParams(params)}`;
    return this.get(path);
  }
  async getExecution(id) {
    const path = `/executions/${encodeURIComponent(id)}`;
    return this.get(path);
  }
  async getPacks() {
    return this.get("/packs");
  }
  async getActions(pack) {
    const params = {
      include_attributes: "id,ref,name,pack,description,runner_type",
      pack
    };
    const path = `/actions?${new URLSearchParams(params)}`;
    return this.get(path);
  }
  getExecutionHistoryUrl(id) {
    return `${this.webUrl}/?#/history/${encodeURIComponent(id)}`;
  }
  getActionUrl(ref) {
    return `${this.webUrl}/?#/actions/${encodeURIComponent(ref)}`;
  }
}

export { StackstormClient };
//# sourceMappingURL=StackstormClient.esm.js.map
