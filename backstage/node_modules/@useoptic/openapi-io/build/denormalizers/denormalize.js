"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.denormalizeOperationV3 = exports.denormalizePathsV3 = exports.denormalizeOperationV2 = exports.denormalizePathsV2 = exports.denormalize = void 0;
const openapi_utilities_1 = require("@useoptic/openapi-utilities");
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
const pointer_1 = require("./pointer");
const denormalizeProperty_1 = require("./denormalizeProperty");
// Denormalizes a dereferenced openapi spec - mutates in place
// This function
// - denormalizes shared path parameters
// - flattens allOf
// - adds response headers {} if not set
// - adds parameters [] if not set
function denormalize(parse, version, warnings) {
    parse = {
        ...parse,
        jsonLike: JSON.parse(JSON.stringify(parse.jsonLike)),
    };
    if (version === '2.x.x') {
        const consumes = parse.jsonLike.consumes;
        const produces = parse.jsonLike.produces;
        delete parse.jsonLike.consumes;
        delete parse.jsonLike.produces;
        for (const [pathKey, path] of Object.entries(parse.jsonLike.paths ?? {})) {
            if (path) {
                denormalizePathsV2(path, pathKey, parse.sourcemap, warnings);
                for (const method of Object.values(openapi_utilities_1.OpenAPIV3.HttpMethods)) {
                    const operation = path?.[method];
                    if (operation) {
                        denormalizeOperationV2(operation, { path: pathKey, method, consumes, produces }, parse.sourcemap, warnings);
                    }
                }
            }
        }
    }
    else {
        for (const [pathKey, path] of Object.entries(parse.jsonLike.paths ?? {})) {
            if (path) {
                denormalizePathsV3(path, pathKey, parse.sourcemap, warnings);
                for (const method of Object.values(openapi_utilities_1.OpenAPIV3.HttpMethods)) {
                    const operation = path?.[method];
                    if (operation) {
                        denormalizeOperationV3(operation, { path: pathKey, method }, parse.sourcemap, warnings);
                    }
                }
            }
        }
    }
    return parse;
}
exports.denormalize = denormalize;
function denormalizePathsV2(path, pathKey, sourcemap, warnings) {
    if (path.parameters) {
        for (const method of openapi_utilities_1.SWAGGER2_HTTP_METHODS) {
            const operation = path[method];
            if (operation) {
                // Merge in parameters
                for (const [idx, parameter] of path.parameters.entries()) {
                    if ('$ref' in parameter) {
                        continue;
                    }
                    // Look for an existing parameter, if it exists, we should keep the more specific parameter
                    const hasParameter = operation.parameters?.find((p) => !('$ref' in p) &&
                        p.in === parameter.in &&
                        p.name === parameter.name);
                    if (!hasParameter) {
                        if (!operation.parameters) {
                            operation.parameters = [];
                        }
                        const oldPointer = json_pointer_helpers_1.jsonPointerHelpers.compile([
                            'paths',
                            pathKey,
                            'parameters',
                            String(idx),
                        ]);
                        const newPointer = json_pointer_helpers_1.jsonPointerHelpers.compile([
                            'paths',
                            pathKey,
                            method,
                            'parameters',
                            String(operation.parameters.length),
                        ]);
                        sourcemap &&
                            (0, pointer_1.logPointer)(sourcemap, { old: oldPointer, new: newPointer });
                        operation.parameters.push(parameter);
                    }
                }
            }
        }
    }
    // Finally, we remove the parameter on the path level
    delete path.parameters;
}
exports.denormalizePathsV2 = denormalizePathsV2;
function denormalizeOperationV2(operation, { path, method, produces, consumes, }, sourcemap, warnings) {
    if (consumes) {
        if (operation.consumes) {
            operation.consumes = [...new Set([...operation.consumes, ...consumes])];
        }
        else {
            operation.consumes = [...consumes];
        }
    }
    if (produces) {
        if (operation.produces) {
            operation.produces = [...new Set([...operation.produces, ...produces])];
        }
        else {
            operation.produces = [...produces];
        }
    }
}
exports.denormalizeOperationV2 = denormalizeOperationV2;
function denormalizePathsV3(path, pathKey, sourcemap, warnings) {
    if (path.parameters) {
        for (const method of Object.values(openapi_utilities_1.OpenAPIV3.HttpMethods)) {
            const operation = path[method];
            if (operation) {
                // Merge in parameters
                for (const [idx, parameter] of path.parameters.entries()) {
                    if ('$ref' in parameter) {
                        continue;
                    }
                    // Look for an existing parameter, if it exists, we should keep the more specific parameter
                    const hasParameter = operation.parameters?.find((p) => !('$ref' in p) &&
                        p.in === parameter.in &&
                        p.name === parameter.name);
                    if (!hasParameter) {
                        if (!operation.parameters) {
                            operation.parameters = [];
                        }
                        const oldPointer = json_pointer_helpers_1.jsonPointerHelpers.compile([
                            'paths',
                            pathKey,
                            'parameters',
                            String(idx),
                        ]);
                        const newPointer = json_pointer_helpers_1.jsonPointerHelpers.compile([
                            'paths',
                            pathKey,
                            method,
                            'parameters',
                            String(operation.parameters.length),
                        ]);
                        sourcemap &&
                            (0, pointer_1.logPointer)(sourcemap, { old: oldPointer, new: newPointer });
                        operation.parameters.push(parameter);
                    }
                }
            }
        }
        // Finally, we remove the parameter on the path level
        delete path.parameters;
    }
}
exports.denormalizePathsV3 = denormalizePathsV3;
function denormalizeOperationV3(operation, { path, method, }, sourcemap, warnings) {
    // For all schemas, flatten allOfs
    if (operation.requestBody) {
        for (const [contentType, body] of Object.entries(operation.requestBody.content ?? {})) {
            const pointer = json_pointer_helpers_1.jsonPointerHelpers.compile([
                'paths',
                path,
                method,
                'requestBody',
                'content',
                contentType,
                'schema',
            ]);
            if (body.schema) {
                const w = (0, denormalizeProperty_1.denormalizeProperty)(body.schema, sourcemap, {
                    old: pointer,
                    new: pointer,
                });
                warnings?.push(...w);
            }
        }
    }
    for (const [statusCode, response] of Object.entries(operation.responses)) {
        for (const [contentType, body] of Object.entries(response.content ?? {})) {
            const pointer = json_pointer_helpers_1.jsonPointerHelpers.compile([
                'paths',
                path,
                method,
                'responses',
                statusCode,
                'content',
                contentType,
                'schema',
            ]);
            if (body.schema) {
                const w = (0, denormalizeProperty_1.denormalizeProperty)(body.schema, sourcemap, {
                    old: pointer,
                    new: pointer,
                });
                warnings?.push(...w);
            }
        }
    }
    // Attaches a `parameters` key to all methods
    if (!operation.parameters) {
        operation.parameters = [];
    }
    // Attaches a `response.headers` key to all responses
    for (const responseObj of Object.values(operation.responses)) {
        if (!responseObj.headers) {
            responseObj.headers = {};
        }
    }
}
exports.denormalizeOperationV3 = denormalizeOperationV3;
//# sourceMappingURL=denormalize.js.map