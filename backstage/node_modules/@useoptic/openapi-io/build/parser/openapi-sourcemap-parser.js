"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOpenAPIFromRepoWithSourcemap = exports.parseOpenAPIWithSourcemap = exports.dereferenceOpenApi = exports.ResolverError = exports.JSONParserError = void 0;
const json_schema_ref_parser_1 = __importDefault(require("@apidevtools/json-schema-ref-parser"));
// @ts-ignore
const $RefParserOptions = __importStar(require("@apidevtools/json-schema-ref-parser/lib/options"));
// @ts-ignore
const insourced_dereference_1 = require("./insourced-dereference");
const path_1 = __importDefault(require("path"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const is_url_1 = __importDefault(require("is-url"));
const sourcemap_1 = require("./sourcemap");
const git_branch_file_resolver_1 = require("./resolvers/git-branch-file-resolver");
const bottleneck_1 = __importDefault(require("bottleneck"));
// @ts-ignore
const customYaml = __importStar(require("./insourced-yaml"));
const custom_http_ref_handler_1 = require("./resolvers/custom-http-ref-handler");
var json_schema_ref_parser_2 = require("@apidevtools/json-schema-ref-parser");
Object.defineProperty(exports, "JSONParserError", { enumerable: true, get: function () { return json_schema_ref_parser_2.JSONParserError; } });
Object.defineProperty(exports, "ResolverError", { enumerable: true, get: function () { return json_schema_ref_parser_2.ResolverError; } });
async function dereferenceOpenApi(path, options = {}) {
    const resolver = new json_schema_ref_parser_1.default();
    const headersMap = (0, custom_http_ref_handler_1.parseHeadersConfig)(options.externalRefHeaders ?? []);
    const sourcemap = new sourcemap_1.JsonSchemaSourcemap(path);
    const resolve = {
        file: options.externalRefHandler,
        customRefHandler: options.externalRefHandler,
        customHttpRefHandler: (0, custom_http_ref_handler_1.customHttpResolver)(headersMap),
        external: true,
    };
    // Resolve all references
    const resolverResults = await resolver.resolve(path, {
        resolve,
        parse: {
            yaml: customYaml,
        },
    });
    const limiter = new bottleneck_1.default({
        maxConcurrent: 20,
    });
    // parse all asts and add to sourcemap
    const cachedUrls = new Set([]);
    await Promise.all(resolverResults.paths().map((filePath, index) => limiter.schedule(async () => {
        if ((0, is_url_1.default)(filePath)) {
            const inCache = cachedUrls.has(filePath);
            if (!inCache) {
                const headers = {
                    ...custom_http_ref_handler_1.DEFAULT_HEADERS,
                    ...(0, custom_http_ref_handler_1.getMostRelevantHeader)(filePath, headersMap),
                };
                const response = await (0, node_fetch_1.default)(filePath, {
                    headers,
                });
                const contents = await response.text();
                cachedUrls.add(filePath);
                sourcemap.addFileIfMissingFromContents(filePath, contents, index);
            }
        }
        else if (options.externalRefHandler) {
            const contents = await options.externalRefHandler.read({
                url: filePath,
            });
            sourcemap.addFileIfMissingFromContents(filePath, contents, index);
        }
        else {
            await sourcemap.addFileIfMissing(filePath, index);
        }
    })));
    // Dereference all references
    (0, insourced_dereference_1.dereference)(resolver, {
        ...$RefParserOptions.defaults,
        path: path,
        dereference: { circular: 'ignore' },
        resolve,
        parse: {
            yaml: customYaml,
        },
    }, sourcemap);
    return { jsonLike: resolver.schema, sourcemap: sourcemap };
}
exports.dereferenceOpenApi = dereferenceOpenApi;
async function parseOpenAPIWithSourcemap(path, options = {}) {
    return dereferenceOpenApi(path, {
        externalRefHeaders: options.externalRefHeaders,
    });
}
exports.parseOpenAPIWithSourcemap = parseOpenAPIWithSourcemap;
async function parseOpenAPIFromRepoWithSourcemap(name, repoPath, branch, options = {}) {
    const inGitResolver = (0, git_branch_file_resolver_1.gitBranchResolver)(repoPath, branch);
    const fileName = path_1.default.join(repoPath, name);
    return dereferenceOpenApi(fileName, {
        externalRefHandler: inGitResolver,
        externalRefHeaders: options.externalRefHeaders,
    });
}
exports.parseOpenAPIFromRepoWithSourcemap = parseOpenAPIFromRepoWithSourcemap;
//# sourceMappingURL=openapi-sourcemap-parser.js.map