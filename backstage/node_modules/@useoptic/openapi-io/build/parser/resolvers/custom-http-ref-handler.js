"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.customHttpResolver = exports.parseHeadersConfig = exports.getMostRelevantHeader = exports.DEFAULT_HEADERS = void 0;
const ono_1 = require("@jsdevtools/ono");
const json_schema_ref_parser_1 = require("@apidevtools/json-schema-ref-parser");
const node_fetch_1 = __importDefault(require("node-fetch"));
const url = require('@apidevtools/json-schema-ref-parser/lib/util/url');
const ANY_PREFIX = Symbol('Apply to all urls');
const MAX_REDIRECTS = 5;
exports.DEFAULT_HEADERS = {
    accept: '*/*',
};
// Selects the most specific urlPrefix to get the header by
function getMostRelevantHeader(url, headersByUrlPrefix) {
    let mostRelevantHeaders = { headers: {}, relevance: -1 };
    for (const [urlPrefix, headers] of headersByUrlPrefix) {
        let relevance = null;
        if (urlPrefix === ANY_PREFIX) {
            relevance = 1;
        }
        else if (url.startsWith(urlPrefix)) {
            relevance = urlPrefix.length;
        }
        if (relevance !== null && relevance > mostRelevantHeaders.relevance) {
            mostRelevantHeaders = {
                relevance,
                headers,
            };
        }
    }
    return mostRelevantHeaders.headers;
}
exports.getMostRelevantHeader = getMostRelevantHeader;
async function download(url, headersByUrlPrefix, redirects = []) {
    const headers = {
        ...exports.DEFAULT_HEADERS,
        ...getMostRelevantHeader(url, headersByUrlPrefix),
    };
    const response = await (0, node_fetch_1.default)(url, {
        headers,
    });
    redirects = [...redirects, url];
    if (response.status >= 400) {
        throw (0, ono_1.ono)({ status: response.status }, `HTTP ERROR ${response.status}`);
    }
    else if (response.status >= 300) {
        if (redirects.length > MAX_REDIRECTS) {
            throw new json_schema_ref_parser_1.ResolverError((0, ono_1.ono)({ status: response.status }, `Error downloading ${redirects[0]}. \nToo many redirects: \n  ${redirects.join(' \n  ')}`), '');
        }
        else if (!('location' in response.headers) ||
            !response.headers.location ||
            typeof response.headers.location !== 'string') {
            throw (0, ono_1.ono)({ status: response.status }, `HTTP ${response.status} redirect with no location header`);
        }
        else {
            return download(response.headers.location, headersByUrlPrefix, redirects);
        }
    }
    else {
        return response.text();
    }
}
function parseHeadersConfig(headersByUrlPrefix) {
    const prefixMap = new Map();
    for (const conf of headersByUrlPrefix) {
        const key = conf.url_prefix ?? ANY_PREFIX;
        prefixMap.set(key, conf.headers);
    }
    return prefixMap;
}
exports.parseHeadersConfig = parseHeadersConfig;
const customHttpResolver = (headersByUrlPrefix) => {
    return {
        order: 100,
        canRead: (file) => {
            return url.isHttp(file.url);
        },
        read: (file) => {
            return download(file.url, headersByUrlPrefix);
        },
    };
};
exports.customHttpResolver = customHttpResolver;
//# sourceMappingURL=custom-http-ref-handler.js.map