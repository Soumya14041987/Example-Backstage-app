"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filePathToGitPath = exports.gitBranchResolver = void 0;
const ono_1 = require("@jsdevtools/ono");
const json_schema_ref_parser_1 = require("@apidevtools/json-schema-ref-parser");
const url = require('@apidevtools/json-schema-ref-parser/lib/util/url');
const upath_1 = __importDefault(require("upath"));
const child_process_1 = require("child_process");
const gitBranchResolver = (gitBaseRepo, branch) => ({
    order: 1,
    canRead(file) {
        return url.isFileSystemPath(file.url);
    },
    read(file) {
        return new Promise((resolve, reject) => {
            // We need to decode the git path, because we receive the file path / url as a URL encoded string
            const decodedFilePath = decodeURIComponent(file.url);
            const toGit = filePathToGitPath(gitBaseRepo, decodedFilePath);
            const command = `git show "${branch}:${toGit}"`;
            try {
                (0, child_process_1.exec)(command, { cwd: gitBaseRepo, maxBuffer: 1024 * 1024 * 100 }, (err, stdout, stderr) => {
                    if (err)
                        reject(new json_schema_ref_parser_1.ResolverError((0, ono_1.ono)(err.message, `Error opening file "${toGit}"`), toGit));
                    if (stdout)
                        resolve(stdout);
                });
            }
            catch (err) {
                reject(new json_schema_ref_parser_1.ResolverError((0, ono_1.ono)(err, `Error opening file "${toGit}"`), toGit));
            }
        });
    },
});
exports.gitBranchResolver = gitBranchResolver;
function filePathToGitPath(gitBaseRepo, filePath) {
    const toGit = upath_1.default.relative(gitBaseRepo, filePath);
    return upath_1.default.toUnix(toGit);
}
exports.filePathToGitPath = filePathToGitPath;
//# sourceMappingURL=git-branch-file-resolver.js.map