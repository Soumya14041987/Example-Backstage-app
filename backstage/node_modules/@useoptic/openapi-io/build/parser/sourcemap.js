"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonSchemaSourcemap = void 0;
const promises_1 = __importDefault(require("node:fs/promises"));
const crypto_1 = require("crypto");
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
function getsha256(contents) {
    const hash = (0, crypto_1.createHash)('sha256');
    hash.update(contents);
    return hash.digest('hex');
}
class JsonSchemaSourcemap {
    static fromSerializedSourcemap(serialized) {
        const sourcemap = new JsonSchemaSourcemap(serialized.rootFilePath);
        sourcemap.files = serialized.files;
        sourcemap.refMappings = serialized.refMappings;
        return sourcemap;
    }
    constructor(rootFilePath) {
        this.rootFilePath = rootFilePath;
        this.files = [];
        this.refMappings = {};
    }
    async addFileIfMissing(filePath, fileIndex) {
        if (!this.files.find((i) => i.path === filePath)) {
            const contents = (await promises_1.default.readFile(filePath)).toString();
            this.files.push({
                path: filePath,
                sha256: getsha256(contents),
                contents,
                index: fileIndex,
            });
        }
    }
    addFileIfMissingFromContents(filePath, contents, fileIndex) {
        if (!this.files.find((i) => i.path === filePath)) {
            this.files.push({
                path: filePath,
                index: fileIndex,
                contents,
                sha256: getsha256(contents),
            });
        }
    }
    logPointerInFile(filePath, sourcePointer, targetPointer) {
        const thisFile = this.files.find((i) => filePath === i.path);
        if (thisFile) {
            this.refMappings[targetPointer] = [thisFile.index, sourcePointer];
        }
    }
    logPointer(pathRelativeToFile, pathRelativeToRoot) {
        const relativePathDecoded = json_pointer_helpers_1.jsonPointerHelpers.unescapeUriSafePointer(pathRelativeToFile);
        const rootKey = json_pointer_helpers_1.jsonPointerHelpers.unescapeUriSafePointer(pathRelativeToRoot.substring(1));
        const thisFile = this.files.find((i) => relativePathDecoded.startsWith(i.path));
        if (thisFile) {
            const jsonPointer = json_pointer_helpers_1.jsonPointerHelpers.unescapeUriSafePointer(relativePathDecoded.split(thisFile.path)[1].substring(1) || '/');
            if (rootKey === jsonPointer)
                return;
            this.refMappings[rootKey] = [thisFile.index, jsonPointer];
        }
    }
}
exports.JsonSchemaSourcemap = JsonSchemaSourcemap;
//# sourceMappingURL=sourcemap.js.map