"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateOpenApiV3Document = exports.validateSwaggerV2Document = exports.processValidatorErrors = void 0;
const ajv_1 = __importDefault(require("ajv"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const validation_schemas_1 = require("./validation-schemas");
const openapi_versions_1 = require("./openapi-versions");
const ajv_errors_1 = __importDefault(require("ajv-errors"));
const chalk_1 = __importDefault(require("chalk"));
const log_json_pointer_1 = require("./log-json-pointer");
const advanced_validation_1 = require("./advanced-validation");
const errors_1 = require("./errors");
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
class OpenAPISchemaValidator {
    constructor(options) {
        this.options = options;
    }
    validate2(openapiDoc) {
        const ajvInstance = new ajv_1.default({ allErrors: true, strict: false });
        (0, ajv_errors_1.default)(ajvInstance);
        (0, ajv_formats_1.default)(ajvInstance);
        let validator;
        if (this.options.strictOpenAPI) {
            (0, advanced_validation_1.attachAdvancedValidators)(ajvInstance);
            ajvInstance.addSchema(validation_schemas_1.swagger2_schema_object);
            validator = ajvInstance.compile(validation_schemas_1.swagger2_schema_object);
        }
        else {
            ajvInstance.addSchema(validation_schemas_1.basic_swagger2_object);
            validator = ajvInstance.compile(validation_schemas_1.basic_swagger2_object);
        }
        if (!validator(openapiDoc) && validator.errors) {
            return { errors: validator.errors };
        }
        else {
            return { errors: [] };
        }
    }
    validate3_0(openapiDoc) {
        const ajvInstance = new ajv_1.default({ allErrors: true, strict: false });
        (0, ajv_errors_1.default)(ajvInstance);
        (0, ajv_formats_1.default)(ajvInstance);
        let validator;
        if (this.options.strictOpenAPI) {
            (0, advanced_validation_1.attachAdvancedValidators)(ajvInstance);
            ajvInstance.addSchema(validation_schemas_1.openapi3_0_json_schema);
            validator = ajvInstance.compile(validation_schemas_1.openapi3_0_json_schema);
        }
        else {
            ajvInstance.addSchema(validation_schemas_1.basic3openapi_schema);
            validator = ajvInstance.compile(validation_schemas_1.basic3openapi_schema);
        }
        if (!validator(openapiDoc) && validator.errors) {
            return { errors: validator.errors };
        }
        else {
            return { errors: [] };
        }
    }
    validate3_1(openapiDoc) {
        const ajvInstance = new ajv_1.default({ allErrors: true, strict: false });
        (0, ajv_errors_1.default)(ajvInstance);
        (0, ajv_formats_1.default)(ajvInstance);
        let validator;
        if (this.options.strictOpenAPI) {
            (0, advanced_validation_1.attachAdvancedValidators)(ajvInstance);
            ajvInstance.addSchema(validation_schemas_1.openapi3_1_json_schema);
            validator = ajvInstance.compile(validation_schemas_1.openapi3_1_json_schema);
        }
        else {
            ajvInstance.addSchema(validation_schemas_1.basic3openapi_schema);
            validator = ajvInstance.compile(validation_schemas_1.basic3openapi_schema);
        }
        if (!validator(openapiDoc) && validator.errors) {
            return { errors: validator.errors };
        }
        else {
            return { errors: [] };
        }
    }
}
exports.default = OpenAPISchemaValidator;
const getReadableError = (error) => {
    if (error.keyword === 'enum') {
        const paths = error.instancePath.split('/');
        const key = paths[paths.length - 1];
        return `${key} ${error.message} ${error.params.allowedValues.join(',')}`;
    }
    else {
        const readableJsonPath = json_pointer_helpers_1.jsonPointerHelpers
            .decode(error.instancePath)
            .join(' > ');
        return `${readableJsonPath} ${error.message}` ?? '';
    }
};
const processValidatorErrors = (spec, errors, sourcemap) => {
    const sortedErrorsByLength = errors.sort((a, b) => b.instancePath.length - a.instancePath.length);
    const pathsWithErrors = [];
    for (const error of sortedErrorsByLength) {
        // We want to only render the root of the error message
        if (pathsWithErrors.every((addedError) => !addedError.instancePath.startsWith(error.instancePath)) ||
            error.keyword === 'x-custom-validator') {
            pathsWithErrors.push(error);
        }
    }
    const logger = sourcemap && (0, log_json_pointer_1.jsonPointerLogger)(sourcemap);
    return pathsWithErrors
        .map((error) => {
        const pathToLog = error.keyword === 'additionalProperties'
            ? json_pointer_helpers_1.jsonPointerHelpers.append(error.instancePath, error.params.additionalProperty)
            : error.instancePath;
        const preview = logger ? logger.log(pathToLog) : `${error.instancePath}`;
        return `${chalk_1.default.red('invalid openapi: ')}${chalk_1.default.bold.red(getReadableError(error))}\n${preview}`;
    })
        .filter((value, index, array) => array.indexOf(value) === index);
};
exports.processValidatorErrors = processValidatorErrors;
const validateSwaggerV2Document = (spec, sourcemap, validatorOptions = { strictOpenAPI: true }) => {
    const validator = new OpenAPISchemaValidator(validatorOptions);
    let results = validator.validate2(spec);
    // will throw for unsupported spec version before running
    if (results && results.errors.length > 0) {
        const processedErrors = (0, exports.processValidatorErrors)(spec, results.errors, sourcemap);
        throw new errors_1.ValidationError(processedErrors.join('\n'));
    }
    return spec;
};
exports.validateSwaggerV2Document = validateSwaggerV2Document;
const validateOpenApiV3Document = (spec, sourcemap, validatorOptions = { strictOpenAPI: true }) => {
    const validator = new OpenAPISchemaValidator(validatorOptions);
    let results = undefined;
    // will throw for unsupported spec version before running
    const version = (0, openapi_versions_1.checkOpenAPIVersion)(spec);
    if (version === '3.0.x')
        results = validator.validate3_0(spec);
    if (version === '3.1.x')
        results = validator.validate3_1(spec);
    if (results && results.errors.length > 0) {
        const processedErrors = (0, exports.processValidatorErrors)(spec, results.errors, sourcemap);
        throw new errors_1.ValidationError(processedErrors.join('\n'));
    }
    return spec;
};
exports.validateOpenApiV3Document = validateOpenApiV3Document;
//# sourceMappingURL=validator.js.map