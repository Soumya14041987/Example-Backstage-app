"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fileExists = fileExists;
exports.normalizeWorkspace = normalizeWorkspace;
exports.reqs = void 0;
exports.run = run;
exports.runOptic = runOptic;
exports.setupTestServer = setupTestServer;
exports.setupWorkspace = setupWorkspace;
var _globals = require("@jest/globals");
var _http = _interopRequireDefault(require("http"));
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _child_process = require("child_process");
var _nodePath = _interopRequireDefault(require("node:path"));
const root = _nodePath.default.join(__dirname, '..', '..', '..');
async function run(command, print = true, cwd = process.cwd()) {
  const result = {
    stdout: '',
    stderr: '',
    combined: '',
    code: 0
  };
  return new Promise((resolve, reject) => {
    const proc = (0, _child_process.spawn)(command, [], {
      shell: true,
      stdio: ['inherit', 'pipe', 'pipe'],
      cwd,
      env: {
        ...process.env,
        FORCE_COLOR: '1'
      }
    });
    proc.on('close', code => {
      result.code = code;
      resolve(result);
    });
    proc.on('error', err => {
      reject(err);
    });
    proc.stdout.on('data', data => {
      if (print) {
        process.stdout.write(data);
      }
      result.stdout += data;
      result.combined += data;
    });
    proc.stderr.on('data', data => {
      if (print) {
        process.stderr.write(data);
      }
      result.stderr += data;
      result.combined += data;
    });
  });
}
async function setupWorkspace(template, providedOptions = {}) {
  const defaultOptions = {
    repo: true,
    commit: false
  };
  const options = {
    ...defaultOptions,
    ...providedOptions
  };
  const templatePath = _nodePath.default.join(__dirname, 'workspaces', template);
  const dir = await _promises.default.mkdtemp(_nodePath.default.join(root, 'tmp/'));
  const {
    code: cpCode
  } = await run(`cp -R ${templatePath}/* ${dir}/`, false);
  if (cpCode !== 0) {
    throw `Failed to copy workspace template ${template}`;
  }
  if (options.repo) {
    const {
      code: gitInitCode,
      combined: gitCombined
    } = await run('git init -b master \
      && git config user.email "test@useoptic.com" \
      && git config user.name "Optic test" \
      && git config commit.gpgsign false \
      && git remote add origin git@github.com:User/UserRepo.git', false, dir);
    if (gitInitCode !== 0) {
      throw `Git init failed in ${dir}: ${gitCombined}`;
    }
    if (options.commit) {
      const {
        code: commitCode,
        combined: commitCombined
      } = await run(`git add . && git commit -m 'first commit'`, false, dir);
      if (commitCode !== 0) {
        throw `Git commit failed in ${dir}: ${commitCombined}`;
      }
    }
  }
  return dir;
}
async function getTsNodePath() {
  const tsNodeAtRoot = _nodePath.default.join(root, '../..', 'node_modules', '.bin', 'ts-node');
  const tsNodeAtSubproject = _nodePath.default.join(root, 'node_modules', '.bin', 'ts-node');
  try {
    await _promises.default.access(tsNodeAtRoot);
    return tsNodeAtRoot;
  } catch (e) {
    return tsNodeAtSubproject;
  }
}
async function runOptic(workspace, cmd, print) {
  const src = _nodePath.default.join(root, 'src', 'index.ts');
  const tsNode = await getTsNodePath();
  const result = await run(`${tsNode} ${src} ${cmd}`, print ?? false, workspace);
  return result;
}
async function fileExists(path) {
  try {
    await _promises.default.stat(path);
  } catch {
    return false;
  }
  return true;
}
function normalizeWorkspace(workspace, text) {
  return text.replace(new RegExp(workspace, 'g'), '$$workspace$$').replace(new RegExp(_nodePath.default.resolve(root, '../..'), 'g'), '$$root$$');
}
let server;
let reqs = exports.reqs = [];
const createListener = handler => {
  return async function listener(req, resp) {
    reqs.push(req);
    resp.writeHead(200);
    const body = req.url && req.method && handler ? await handler({
      url: req.url,
      method: req.method,
      headers: req.headers
    }) : undefined;
    resp.end(body);
  };
};
function setupTestServer(maybeHandler) {
  let originalBwtsHostOverride = process.env.BWTS_HOST_OVERRIDE;
  (0, _globals.beforeEach)(() => {
    exports.reqs = reqs = [];
    server = _http.default.createServer(createListener(maybeHandler));
    server.listen();
    originalBwtsHostOverride = process.env.BWTS_HOST_OVERRIDE;
    const {
      port
    } = server.address();
    process.env.BWTS_HOST_OVERRIDE = `http://127.0.0.1:${port}`;
  });
  (0, _globals.afterEach)(() => {
    server.close();
    process.env.BWTS_HOST_OVERRIDE = originalBwtsHostOverride;
  });
}