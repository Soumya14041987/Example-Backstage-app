"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.followFile = followFile;
exports.getPathCandidatesForSha = getPathCandidatesForSha;
exports.getShasCandidatesForPath = getShasCandidatesForPath;
var _util = require("util");
var _child_process = require("child_process");
var _gitUtils = require("../../utils/git-utils");
var _path = _interopRequireDefault(require("path"));
const exec = (0, _util.promisify)(_child_process.exec);
async function getShasCandidatesForPath(path, depth) {
  // This should return commits in reverse chronological order
  // first parent treats merge commits as a single depth (not including children in it)
  const command = depth === '0' ? `git rev-list HEAD --first-parent` : `git rev-list HEAD -n ${depth} --first-parent`;
  let hashes;
  try {
    const commandResults = await exec(command).then(({
      stdout
    }) => stdout.trim());
    hashes = commandResults.split('\n');
  } catch (e) {
    // Will fail in an empty git repository
    return {
      shas: [],
      paths: []
    };
  }
  return {
    shas: hashes,
    paths: [path]
  };
}
async function followFile(path, depth = '0') {
  const depthChunk = depth === '0' ? '' : ` -n ${Number(depth) + 1}`;
  const command = `git log${depthChunk} --follow --name-only --pretty=format:"%H" ${path}`;
  try {
    const commandResults = await exec(command).then(({
      stdout
    }) => stdout.trim());
    const entries = commandResults.split('\n\n').map(group => group.split('\n'));
    return entries;
  } catch (err) {
    return [];
  }
}
async function getPathCandidatesForSha(sha, opts) {
  let hashes = [sha];
  if (opts.depth !== '1') {
    const command = opts.depth === '0' ? `git rev-list HEAD --first-parent` : `git rev-list HEAD -n ${opts.depth} --first-parent`;
    try {
      // Repos with a large set of commits may exceed the size of the default buffer
      const opts = {
        maxBuffer: 1024 * 1024 * 2
      }; // 2MB
      const commandResults = await exec(command, opts).then(({
        stdout
      }) => stdout.trim());
      hashes = commandResults.split('\n');
    } catch (e) {
      // Will fail in an empty git repository
    }
  }
  const paths = [];
  // Pull all spec candidates (i.e. specs that have openapi key and are yml/yaml/json)
  // This won't check version / validity of spec and will not look for swagger2 specs
  const relativePaths = await (0, _gitUtils.findOpenApiSpecsCandidates)();
  for (const p of relativePaths) {
    if (!_path.default.resolve(p).startsWith(opts.startsWith)) {
      continue;
    }
    paths.push(p);
  }
  return {
    shas: hashes,
    paths
  };
}