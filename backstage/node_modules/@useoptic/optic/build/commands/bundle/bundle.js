"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerBundle = void 0;
var _commander = require("commander");
var _specLoaders = require("../../utils/spec-loaders");
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _openapiIo = require("@useoptic/openapi-io");
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _path = _interopRequireDefault(require("path"));
var _yaml = _interopRequireDefault(require("yaml"));
var _errorHandler = require("../../error-handler");
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var jsonpatch = _interopRequireWildcard(require("fast-json-patch"));
var _lodash = _interopRequireDefault(require("lodash.sortby"));
var _logger = require("../../logger");
var _jsonIterator = require("./json-iterator");
var _jsonSchemaRefParser = _interopRequireDefault(require("@apidevtools/json-schema-ref-parser"));
var _customHttpRefHandler = require("@useoptic/openapi-io/build/parser/resolvers/custom-http-ref-handler");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const description = `bundle external references for an OpenAPI specification`;
const usage = () => `
  optic bundle <file_path>
  optic bundle <file_path> > bundled.yml
  optic bundle <file_path> -o bundled.yml
`;
const helpText = `
Example usage:
  $ optic bundle openapi-spec.yml > bundled.yml
  `;
const registerBundle = (cli, config) => {
  // TODO remove june 2023
  const filterXExtensions = new _commander.Option('--filter-x-extensions [extensions]', 'extensions to filter when truthy value set').hideHelp(true);
  const includeXExtensions = new _commander.Option('--include-x-extensions [extensions]', 'extensions to filter when truthy value set').hideHelp(true);
  cli.command('bundle', {
    hidden: true
  }).configureHelp({
    commandUsage: usage
  }).addHelpText('after', helpText).description(description).argument('[file_path]', 'openapi file to bundle').option('-o [output]', 'output file name').addOption(filterXExtensions).addOption(includeXExtensions).action((0, _errorHandler.errorHandler)(bundleAction(config), {
    command: 'bundle'
  }));
};
exports.registerBundle = registerBundle;
const getSpec = async (file1, config) => {
  try {
    return (0, _specLoaders.loadSpec)(file1, config, {
      strict: false,
      denormalize: false
    });
  } catch (e) {
    throw new _openapiUtilities.UserError({
      initialError: e instanceof Error ? e : undefined
    });
  }
};
const bundleAction = config => async (filePath, options) => {
  const {
    o,
    filterXExtensions,
    includeXExtensions
  } = options;
  const filterExtensions = (filterXExtensions || '').split(/[ ,]+/).filter(extension => extension.startsWith('x-'));
  const includeExtensions = (includeXExtensions || '').split(/[ ,]+/).filter(extension => extension.startsWith('x-'));
  const resolveRefs = async path => {
    var _config$external_refs;
    const resolver = new _jsonSchemaRefParser.default();
    const headersMap = (0, _customHttpRefHandler.parseHeadersConfig)(((_config$external_refs = config.external_refs) === null || _config$external_refs === void 0 ? void 0 : _config$external_refs.resolve_headers) ?? []);
    const resolve = {
      customHttpRefHandler: (0, _customHttpRefHandler.customHttpResolver)(headersMap),
      external: true
    };
    return await resolver.resolve(path, {
      resolve
    });
  };
  let parsedFile;
  if (filePath) {
    parsedFile = await getSpec(filePath, config);
    if (parsedFile.version === '2.x.x') {
      _logger.logger.error('Swagger 2 is not supported');
      process.exitCode = 1;
      return;
    }
    let updatedSpec = await bundle(parsedFile.jsonLike, parsedFile.sourcemap, resolveRefs);
    if (includeExtensions.length) {
      Object.entries(updatedSpec.paths ?? {}).forEach(([path, operations]) => {
        Object.entries(operations).forEach(([key, operation]) => {
          if (!Object.values(_openapiUtilities.OpenAPIV3.HttpMethods).includes(key)) return;
          if (operation && !includeExtensions.some(extension => Boolean(operation[extension]))) {
            // @ts-ignore
            delete updatedSpec.paths[path][key];
            const otherKeys = Object.keys(updatedSpec.paths[path] || {});
            if (otherKeys.length === 0 || otherKeys.length === 1 && otherKeys[0] === 'parameters') {
              delete updatedSpec.paths[path];
            }
          }
        });
      });
    }
    if (filterExtensions.length) {
      Object.entries(updatedSpec.paths ?? {}).forEach(([path, operations]) => {
        Object.entries(operations).forEach(([key, operation]) => {
          if (!Object.values(_openapiUtilities.OpenAPIV3.HttpMethods).includes(key)) return;
          // should filter
          if (operation && filterExtensions.some(extension => Boolean(operation[extension]))) {
            // @ts-ignore
            delete updatedSpec.paths[path][key];
            const otherKeys = Object.keys(updatedSpec.paths[path] || {});
            if (otherKeys.length === 0 || otherKeys.length === 1 && otherKeys[0] === 'parameters') {
              delete updatedSpec.paths[path];
            }
          }
        });
      });
    }
    updatedSpec = removeUnusedComponents(updatedSpec);
    const yamlOut = () => _yaml.default.stringify(updatedSpec, {
      defaultStringType: 'QUOTE_DOUBLE'
    });
    if (o) {
      // write to file
      const outputPath = _path.default.resolve(o);
      await _promises.default.writeFile(outputPath, (0, _openapiIo.isYaml)(o) ? yamlOut() : JSON.stringify(updatedSpec, null, 2));
      _logger.logger.info('wrote bundled spec to ' + _path.default.resolve(o));
    } else {
      // assume pipe >
      if ((0, _openapiIo.isYaml)(filePath)) {
        console.log(yamlOut());
      } else {
        console.log(JSON.stringify(updatedSpec, null, 2));
      }
    }
  } else {
    _logger.logger.error('No specification found');
    process.exitCode = 1;
    return;
  }
};
const methods = `{${Object.values(_openapiUtilities.OpenAPIV3.HttpMethods).join(',')}}`;
const matches = {
  inResponseSchema: ['paths', '**', methods, 'responses', '**', 'content', '**/**', 'schema'],
  inRequestSchema: ['paths', '**', methods, 'requestBody', 'content', '**/**', 'schema'],
  inOperationParameterSchema: ['paths', '**', methods, 'parameters', '**', 'schema'],
  inExistingComponent: ['components', 'schemas', '**'],
  inExistingRequestBody: ['components', 'requestBodies', '**', 'content', '**/**'],
  inExistingResponseBody: ['components', 'responses', '**', 'content', '**/**'],
  inRequestBody: ['paths', '**', methods, 'requestBody'],
  inResponseStatusCode: ['paths', '**', methods, 'responses', '**'],
  inOperationParameter: ['paths', '**', methods, 'parameters', '**'],
  inPathParameter: ['paths', '**', 'parameters', '**'],
  inRequestExamples: ['paths', '**', methods, 'requestBody', 'content', '**/**', 'examples', '**'],
  inResponseExamples: ['paths', '**', methods, 'responses', '**', 'content', '**/**', 'examples', '**'],
  inRequestExample: ['paths', '**', methods, 'requestBody', 'content', '**/**', 'example'],
  inResponseExample: ['paths', '**', methods, 'responses', '**', 'content', '**/**', 'example']
};
async function bundle(spec, sourcemap, refResolver) {
  // create empty component objects if they do not exist
  if (!spec.components) spec.components = {};
  if (!spec.components.schemas) spec.components.schemas = {};
  if (!spec.components.parameters) spec.components.parameters = {};
  if (!spec.components.examples) spec.components.examples = {};
  if (!spec.components.requestBodies) spec.components.requestBodies = {};
  if (!spec.components.responses) spec.components.responses = {};
  let updatedSpec = spec;

  // handle schemas
  updatedSpec = await bundleMatchingRefsAsComponents(updatedSpec, sourcemap, [matches.inRequestSchema, matches.inResponseSchema, matches.inOperationParameterSchema, matches.inExistingComponent, matches.inExistingRequestBody, matches.inExistingResponseBody], 'children', _jsonPointerHelpers.jsonPointerHelpers.compile(['components', 'schemas']), (schema, filePath, pathInFile) => {
    const inOtherFile = filePath !== sourcemap.rootFilePath;
    const components = _jsonPointerHelpers.jsonPointerHelpers.decode(pathInFile);
    if (inOtherFile && components.length <= 1) {
      return toComponentName(_path.default.parse(filePath).name);
    } else {
      if (schema.title) return toComponentName(schema.title);
      const last = components[components.length - 1];
      return toComponentName(last || 'Schema');
    }
  }, {
    rewriteMapping: true
  }, refResolver);

  // handle parameters
  updatedSpec = await bundleMatchingRefsAsComponents(updatedSpec, sourcemap, [matches.inPathParameter, matches.inOperationParameter], 'parent', _jsonPointerHelpers.jsonPointerHelpers.compile(['components', 'parameters']), parameter => {
    return toComponentName(`${capitalize(parameter.name)}${capitalize(parameter.in)}`) || 'Parameter';
  }, {
    rewriteMapping: false
  }, refResolver);

  // handle requestBodies
  updatedSpec = await bundleMatchingRefsAsComponents(updatedSpec, sourcemap, [matches.inRequestBody], 'parent', _jsonPointerHelpers.jsonPointerHelpers.compile(['components', 'requestBodies']), (example, filePath, pathInFile) => {
    const inOtherFile = filePath !== sourcemap.rootFilePath;
    const components = _jsonPointerHelpers.jsonPointerHelpers.decode(pathInFile);
    if (inOtherFile && components.length <= 1) {
      return toComponentName(_path.default.parse(filePath).name);
    } else {
      const last = components[components.length - 1];
      return toComponentName(last || 'RequestBody');
    }
  }, {
    rewriteMapping: false
  }, refResolver);
  updatedSpec = await bundleMatchingRefsAsComponents(updatedSpec, sourcemap, [matches.inResponseStatusCode], 'parent', _jsonPointerHelpers.jsonPointerHelpers.compile(['components', 'responses']), (example, filePath, pathInFile) => {
    const inOtherFile = filePath !== sourcemap.rootFilePath;
    const components = _jsonPointerHelpers.jsonPointerHelpers.decode(pathInFile);
    if (inOtherFile && components.length <= 1) {
      return toComponentName(_path.default.parse(filePath).name);
    } else {
      const last = components[components.length - 1];
      return toComponentName(last || 'ResponseBody');
    }
  }, {
    rewriteMapping: false
  }, refResolver);

  // handle examples
  updatedSpec = await bundleMatchingRefsAsComponents(updatedSpec, sourcemap, [matches.inRequestExample, matches.inRequestExamples, matches.inResponseExample, matches.inResponseExamples], 'parent', _jsonPointerHelpers.jsonPointerHelpers.compile(['components', 'examples']), (example, filePath, pathInFile) => {
    const inOtherFile = filePath !== sourcemap.rootFilePath;
    const components = _jsonPointerHelpers.jsonPointerHelpers.decode(pathInFile);
    if (inOtherFile && components.length <= 1) {
      return toComponentName(_path.default.parse(filePath).name);
    } else {
      const last = components[components.length - 1];
      return toComponentName(last || 'Example');
    }
  }, {
    rewriteMapping: false
  }, refResolver);
  return updatedSpec;
}

// assumes single file OpenAPI spec
function removeUnusedComponents(spec) {
  let updatedSpec = spec;
  let removedCount = undefined;
  while (removedCount !== 0) {
    const removals = [];
    const refMap = {};
    const buildRefMap = (spec, pointer = _jsonPointerHelpers.jsonPointerHelpers.compile([])) => {
      if (Array.isArray(spec)) {
        spec.forEach((item, index) => buildRefMap(item, _jsonPointerHelpers.jsonPointerHelpers.append(pointer, index.toString())));
      } else if (typeof spec === 'object' && spec !== null) {
        Object.entries(spec).map(([key, value]) => {
          if (key === '$ref' && typeof value === 'string') {
            const componentPath = value.startsWith('#') ? value.substring(1) : value;

            // remove circular references from count
            if (!_jsonPointerHelpers.jsonPointerHelpers.startsWith(pointer, _jsonPointerHelpers.jsonPointerHelpers.decode(componentPath))) {
              refMap[pointer] = componentPath;
            }
          } else {
            buildRefMap(value, _jsonPointerHelpers.jsonPointerHelpers.append(pointer, key));
          }
        });
      }
    };
    buildRefMap(updatedSpec);
    const usages = new Set(Object.values(refMap));
    const refMapEntries = Object.entries(refMap);
    const hasPathToOperation = (componentPath, parents = []) => {
      const usages = refMapEntries.filter(([usage, component]) => component === componentPath);

      // used directly in a path
      const usedDirectlyInAnOperation = usages.some(([usage]) => {
        return _jsonPointerHelpers.jsonPointerHelpers.startsWith(usage, ['paths'], {
          exact: true
        });
      });
      if (usedDirectlyInAnOperation) return true;
      const parentsUsedInOperation = usages.some(([usage, component]) => {
        if (_jsonPointerHelpers.jsonPointerHelpers.startsWith(usage, ['components'], {
          exact: true
        })) {
          const parentComponent = _jsonPointerHelpers.jsonPointerHelpers.compile(_jsonPointerHelpers.jsonPointerHelpers.decode(usage).slice(0, 3));
          // console.log('checking parent: ' + parentComponent);
          if (parents.includes(parentComponent)) return false;
          return hasPathToOperation(parentComponent, [...parents, componentPath]);
        }
      });
      if (parentsUsedInOperation) return true;
      return false;
    };
    const testComponents = kind => {
      const components = _jsonPointerHelpers.jsonPointerHelpers.tryGet(updatedSpec, _jsonPointerHelpers.jsonPointerHelpers.compile(['components', kind]));
      const componentNames = Object.keys(components.match ? components.value : {});
      componentNames.forEach(name => {
        const jsonPointer = _jsonPointerHelpers.jsonPointerHelpers.compile(['components', kind, name]);
        const isUsedInOperation = hasPathToOperation(jsonPointer);
        if (!usages.has(jsonPointer) || !isUsedInOperation) {
          removals.push({
            op: 'remove',
            path: jsonPointer
          });
        }
      });
    };
    testComponents('schemas');
    testComponents('requestBodies');
    testComponents('responses');
    testComponents('examples');
    testComponents('parameters');
    testComponents('headers');
    const copied = JSON.parse(JSON.stringify(updatedSpec));
    removedCount = removals.length;
    updatedSpec = jsonpatch.applyPatch(copied, removals, true, true).newDocument;
  }
  return updatedSpec;
}
async function bundleMatchingRefsAsComponents(spec, sourcemap, matchers, match, targetPath, naming, options, refResolver) {
  const rootFileIndex = sourcemap.files.find(i => i.path === sourcemap.rootFilePath).index;

  // find all $ref usages that match the target pattern ie. in a schema?
  const matchingKeys = Object.keys(sourcemap.refMappings).filter(flatSpecPath => {
    return matchers.some(matcher => {
      if (match === 'parent') {
        return _jsonPointerHelpers.jsonPointerHelpers.matches(flatSpecPath, matcher);
      } else {
        return _jsonPointerHelpers.jsonPointerHelpers.startsWith(flatSpecPath, matcher) || _jsonPointerHelpers.jsonPointerHelpers.matches(flatSpecPath, matcher);
      }
    });
  });

  // build a set of used names -- we don't want conflicts since the namespace is the components.{} object
  const existingComponents = _jsonPointerHelpers.jsonPointerHelpers.tryGet(spec, targetPath);
  const usedNames = new Set(existingComponents.match ? Object.keys(existingComponents.value) : []);

  // when new components are made, ensure the name is unique. If it's not unique try incrementing `_#` until it is.
  const leaseComponentPath = name => {
    let componentName = name;
    let trailingNumber = 0;
    while (usedNames.has(componentName)) {
      componentName = name + '_' + trailingNumber;
      trailingNumber++;
    }
    usedNames.add(componentName);
    return _jsonPointerHelpers.jsonPointerHelpers.append(targetPath, componentName);
  };
  const refs = {};
  const addComponentOperations = [];
  const updateUsagesOperations = [];
  matchingKeys.forEach(key => {
    const mapping = sourcemap.refMappings[key];
    const refKey = `${mapping[0].toString()}-${mapping[1]}`;
    // if the $ref has already been named, add a usage
    if (refs.hasOwnProperty(refKey)) {
      const foundRef = refs[refKey];
      // the first entry was circular, replace it
      const component = _jsonPointerHelpers.jsonPointerHelpers.get(spec, key);
      if (foundRef && foundRef.circular && !component.hasOwnProperty('$ref')) {
        foundRef.component = component;
        foundRef.originalPath = key;
        foundRef.circular = false;
      }
      foundRef.usages.push(key);
    } else {
      // if the $ref has never been seen before, add it and compute a free name
      const component = _jsonPointerHelpers.jsonPointerHelpers.get(spec, key);
      const nameOptions = naming(component, sourcemap.files.find(file => file.index === mapping[0]).path, mapping[1]);

      // this checks if the component is already in the root file of the spec
      const isAlreadyInPlace = refKey.startsWith(`${rootFileIndex}-${targetPath}`);
      const componentPath = isAlreadyInPlace ? (() => {
        const [, lastKey] = _jsonPointerHelpers.jsonPointerHelpers.splitParentChild(mapping[1]);
        usedNames.add(lastKey);
        return mapping[1];
      })() : leaseComponentPath(nameOptions);
      const aliases = (() => {
        const set = new Set();
        // file ref with root schema
        if (mapping[1] === '/') {
          set.add(sourcemap.files[mapping[0]].path);
          set.add(_path.default.relative(_path.default.dirname(sourcemap.rootFilePath), sourcemap.files[mapping[0]].path));
        }
        if (isAlreadyInPlace) set.add(componentPath);
        return set;
      })();
      refs[refKey] = {
        aliases: aliases,
        skipAddingToComponents: isAlreadyInPlace,
        originalPath: key,
        circular: component.hasOwnProperty('$ref'),
        componentPath,
        component,
        usages: [key]
      };
    }
  });
  const refArray = Object.values(refs);

  // second pass: Nested schemas. Patch the new components we've created that rely on other newly created components.
  refArray.forEach(ref => {
    const nestedRefs = refArray.filter(i => i.usages.some(i => _jsonPointerHelpers.jsonPointerHelpers.startsWith(i, _jsonPointerHelpers.jsonPointerHelpers.decode(ref.originalPath), {
      exact: true
    }) && i !== ref.originalPath));
    const nestedRefUsageUpdates = [];
    nestedRefs.forEach(nestedRef => {
      nestedRef.usages.forEach(i => {
        const original = _jsonPointerHelpers.jsonPointerHelpers.decode(ref.originalPath);
        const newRef = _jsonPointerHelpers.jsonPointerHelpers.decode(i);
        if (_jsonPointerHelpers.jsonPointerHelpers.startsWith(i, _jsonPointerHelpers.jsonPointerHelpers.decode(ref.originalPath), {
          exact: true
        }) && i !== ref.originalPath && newRef.length > original.length) {
          const original = _jsonPointerHelpers.jsonPointerHelpers.decode(ref.originalPath);
          const newRef = _jsonPointerHelpers.jsonPointerHelpers.decode(i);
          const newPath = _jsonPointerHelpers.jsonPointerHelpers.compile(newRef.slice(original.length));
          const patch = {
            op: 'replace',
            path: newPath,
            value: {
              $ref: '#' + nestedRef.componentPath
            }
          };
          nestedRefUsageUpdates.push(patch);
        }
      });
      nestedRef.usages = nestedRef.usages.filter(i => !(_jsonPointerHelpers.jsonPointerHelpers.startsWith(i, _jsonPointerHelpers.jsonPointerHelpers.decode(ref.originalPath), {
        exact: true
      }) && i !== ref.originalPath));
    });
    ref.component = jsonpatch.applyPatch(ref.component, (0, _lodash.default)(nestedRefUsageUpdates, i => -_jsonPointerHelpers.jsonPointerHelpers.decode(i.path).length), true, true).newDocument;
  });

  // now generate the actual spec patches
  refArray.forEach(ref => {
    if (!ref.skipAddingToComponents) addComponentOperations.push({
      op: 'add',
      path: ref.componentPath,
      value: ref.component
    });
    ref.usages.forEach(usage => {
      updateUsagesOperations.push({
        op: 'replace',
        path: usage,
        value: {
          $ref: '#' + ref.componentPath
        }
      });
    });
  });

  // add components first
  let specCopy = JSON.parse(JSON.stringify(spec));
  specCopy = jsonpatch.applyPatch(specCopy, addComponentOperations, true, true).newDocument;
  //
  // // then add $refs in reverse depth order (to prevent conflicts).
  specCopy = (0, _lodash.default)(updateUsagesOperations, op => _jsonPointerHelpers.jsonPointerHelpers.decode(op.path).length).reduce((specCopy, operation) => {
    const error = jsonpatch.validate([operation], specCopy);
    if (!error) {
      return jsonpatch.applyPatch(specCopy, [operation], true, true).newDocument;
    } else {
      return specCopy;
    }
  }, specCopy);
  if (options.rewriteMapping) {
    let $refs = await refResolver(sourcemap.rootFilePath);
    const refKeys = $refs.paths();

    // handle mapping
    const mappingPattern = [matches.inRequestSchema, matches.inResponseSchema, matches.inOperationParameterSchema, matches.inExistingComponent, matches.inExistingRequestBody, matches.inExistingResponseBody];
    for (const obj of (0, _jsonIterator.jsonIterator)(specCopy)) {
      if (mappingPattern.some(pattern => _jsonPointerHelpers.jsonPointerHelpers.startsWith(obj.pointer, pattern) && _jsonPointerHelpers.jsonPointerHelpers.endsWith(obj.pointer, ['discriminator', 'mapping', '**']))) {
        const isRef = refKeys.find(i => i.endsWith(obj.value));
        if (isRef) {
          const refFound = refArray.find(i => i.aliases.has(isRef));
          if (refFound) {
            jsonpatch.applyPatch(specCopy, [{
              op: 'replace',
              path: obj.pointer,
              value: '#' + refFound.componentPath
            }]);
          }
        }
      }
    }
  }
  return specCopy;
}
function toComponentName(input) {
  return input.replaceAll(/-/g, '_').replaceAll(/[^a-zA-Z0-9_]+/g, '');
}
function capitalize(s) {
  return s[0].toUpperCase() + s.slice(1);
}