"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.captureRequestsFromProxy = captureRequestsFromProxy;
var _child_process = require("child_process");
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _bottleneck = _interopRequireDefault(require("bottleneck"));
var _exitHook = _interopRequireDefault(require("exit-hook"));
var _urlJoin = _interopRequireDefault(require("url-join"));
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _logger = require("../../../logger");
var _capture = require("../../../utils/capture");
var _har = require("../sources/har");
var _spinner = require("../../../utils/spinner");
var _proxy2 = require("../sources/proxy");
const defaultServerReadyTimeout = 10_000; // 10s

// Clears logging so that the spinner is always flushed to the bottom until it is completed
const loggerWhileSpinning = {
  debug: (spinner, ...msg) => {
    spinner === null || spinner === void 0 || spinner.clear();
    _logger.logger.debug(...msg);
    spinner === null || spinner === void 0 || spinner.render();
  },
  error: (spinner, ...msg) => {
    spinner === null || spinner === void 0 || spinner.clear();
    _logger.logger.error(...msg);
    spinner === null || spinner === void 0 || spinner.render();
  },
  info: (spinner, ...msg) => {
    spinner === null || spinner === void 0 || spinner.clear();
    _logger.logger.info(...msg);
    spinner === null || spinner === void 0 || spinner.render();
  }
};
const wait = time => new Promise(r => setTimeout(() => r(null), time));
function startApp(command, dir, spinner) {
  const cmd = (0, _capture.commandSplitter)(command);
  let app;
  try {
    app = (0, _child_process.spawn)(cmd.cmd, cmd.args, {
      detached: true,
      cwd: dir,
      shell: true
    });
  } catch (e) {
    throw new _openapiUtilities.UserError({
      message: e.message
    });
  }
  app.stdout.on('data', data => {
    loggerWhileSpinning.debug(spinner, data.toString());
  });
  app.stderr.on('data', data => {
    loggerWhileSpinning.error(spinner, data.toString());
  });
  const bailout = {
    didBailout: false,
    promise: new Promise(resolve => {
      app.on('exit', code => {
        bailout.didBailout = true;
        // Resolve instead of reject since in cases where spawn cmd instantly fails we end up with an unhandled rejection
        resolve(new _openapiUtilities.UserError({
          message: `Server unexpectedly exited with error code ${code}`
        }));
      });
    })
  };
  return [app, bailout];
}
async function waitForServer(bailout, readyEndpoint, readyInterval, readyTimeout, targetUrl, spinner) {
  //
  // wait for the app to be ready
  //

  const url = (0, _urlJoin.default)(targetUrl, readyEndpoint);
  const timeout = readyTimeout || defaultServerReadyTimeout;
  const now = Date.now();
  let didTimeout = false;
  const checkServer = () => (0, _nodeFetch.default)(url).then(res => String(res.status).startsWith('2')).catch(e => {
    loggerWhileSpinning.debug(spinner, e);
    return false;
  });
  const serverReadyPromise = new Promise(async (resolve, reject) => {
    let done = false;

    // We need to bail out if the server shut down, otherwise we never conclude this promise chain
    while (!done && !bailout.didBailout) {
      const isReady = await checkServer();
      if (isReady) {
        done = true;
      } else if (Date.now() > now + timeout) {
        didTimeout = true;
        reject(new _openapiUtilities.UserError({
          message: 'The server timed out before a successful healthcheck.'
        }));
      }
      await wait(readyInterval);
    }
    if (didTimeout) spinner === null || spinner === void 0 || spinner.fail('Verify the server URL in your optic.yml is correct and your server is reachable.');
    if (!bailout.didBailout) resolve(null);
  });
  await Promise.race([serverReadyPromise, bailout.promise.then(e => {
    throw e;
  })]);
}
function sendRequests(reqs, proxyUrl, concurrency, spinner) {
  const limiter = new _bottleneck.default({
    maxConcurrent: concurrency,
    minTime: 0
  });
  return reqs.map(async r => {
    let verb = r.method || 'GET';
    let opts = {
      method: verb,
      headers: {}
    };
    if (r.data) opts['body'] = JSON.stringify(r.data);
    if (r.headers) {
      // convert all header keys to lowercase for easier content-type checking below
      const headers = Object.keys(r.headers).reduce((acc, key) => {
        acc[key.toLowerCase()] = r.headers[key];
        return acc;
      }, {});
      opts['headers'] = headers;
    }

    // if a content-type header is not set, add it
    if (!opts['headers'].hasOwnProperty('content-type')) {
      opts['headers']['content-type'] = 'application/json;charset=UTF-8';
    }
    return limiter.schedule(() => (0, _nodeFetch.default)((0, _urlJoin.default)(proxyUrl, r.path), opts).catch(error => {
      loggerWhileSpinning.error(spinner, error.message);
    }));
  });
}
async function runRequestsCommand(command, proxyVar, proxyUrl, spinner) {
  const cmd = (0, _capture.commandSplitter)(command);
  let reqCmd;
  try {
    reqCmd = (0, _child_process.spawn)(cmd.cmd, cmd.args, {
      env: {
        ...process.env,
        [proxyVar]: proxyUrl
      },
      detached: false,
      shell: true,
      // hide child process powershell windows on Windows systems. this only works with "detached: false".
      // https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback
      windowsHide: true
    });
  } catch (e) {
    throw new _openapiUtilities.UserError({
      initialError: e
    });
  }
  let reqCmdPromise;
  reqCmdPromise = new Promise((resolve, reject) => {
    reqCmd.on('exit', code => {
      if (code === 0) {
        resolve();
      } else {
        reject(new _openapiUtilities.UserError({
          message: `command ${cmd} failed with exit code ${code}`
        }));
      }
    });
  });
  reqCmd.stdout.on('data', data => {
    loggerWhileSpinning.info(spinner, data.toString());
  });
  reqCmd.stderr.on('data', data => {
    loggerWhileSpinning.error(spinner, data.toString());
  });
  return reqCmdPromise;
}
function makeAllRequests(captureConfig, proxyUrl, spinner) {
  // send requests
  let sendRequestsPromise = Promise.resolve();
  if (captureConfig.requests && captureConfig.requests.send) {
    var _captureConfig$config;
    const requests = sendRequests(captureConfig.requests.send, proxyUrl, ((_captureConfig$config = captureConfig.config) === null || _captureConfig$config === void 0 ? void 0 : _captureConfig$config.request_concurrency) || 5, spinner);
    sendRequestsPromise = Promise.allSettled(requests).then(results => {
      let hasError = false;
      results.forEach((result, idx) => {
        if (result.status === 'rejected') {
          const req = captureConfig.requests[idx];
          loggerWhileSpinning.error(spinner, `Request ${req.method ?? 'GET'} ${req.path} failed with ${result.reason}`);
          hasError = true;
        }
      });
      if (hasError) throw new Error('Some requests failed');
    });
  }

  // run requests command
  let runRequestsPromise = Promise.resolve();
  if (captureConfig.requests && captureConfig.requests.run) {
    const proxyVar = captureConfig.requests.run.proxy_variable || 'OPTIC_PROXY';
    runRequestsPromise = runRequestsCommand(captureConfig.requests.run.command, proxyVar, proxyUrl, spinner);
  }
  return [sendRequestsPromise, runRequestsPromise];
}
async function captureRequestsFromProxy(config, captureConfig, options) {
  var _getSpinner;
  let app = undefined;
  let proxy = undefined;
  function cleanup() {
    var _proxy;
    (_proxy = proxy) === null || _proxy === void 0 || _proxy.stop();
    if (app && app.pid && app.exitCode === null) {
      if (process.platform === 'win32') {
        // https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/taskkill
        (0, _child_process.exec)(`taskkill /pid ${app.pid} /t /f`);
      } else {
        process.kill(-app.pid);
      }
    }
  }
  const unsubscribeHook = (0, _exitHook.default)(() => {
    cleanup();
  });
  const spinner = options.disableSpinner ? undefined : (_getSpinner = (0, _spinner.getSpinner)({
    text: 'Generating traffic to send to server',
    color: 'blue'
  })) === null || _getSpinner === void 0 ? void 0 : _getSpinner.start();
  let interactions = null;
  const serverUrl = options.serverUrl;
  const serverDir = captureConfig.server.dir === undefined ? config.root : captureConfig.server.dir;
  const timeout = captureConfig.server.ready_timeout || defaultServerReadyTimeout;
  const readyInterval = captureConfig.server.ready_interval || 1000;
  // start app

  let errors = [];
  try {
    let bailout = {
      didBailout: false,
      // If no server is started, we never need to bailout so we need a noop promise that never resolves
      promise: new Promise(() => {})
    };
    if (!options.serverOverride && captureConfig.server.command) {
      loggerWhileSpinning.debug(spinner, `Starting app using command ${captureConfig.server.command}`);
      [app, bailout] = startApp(captureConfig.server.command, serverDir, spinner);

      // since ready_endpoint is not required always wait one interval. without ready_endpoint,
      // ready_interval must be at least the time it takes to start the server.
      await wait(readyInterval);
      if (captureConfig.server.ready_endpoint) {
        if (spinner) spinner.text = 'Waiting for server to come online...';
        await waitForServer(bailout, captureConfig.server.ready_endpoint, readyInterval, timeout, serverUrl, spinner);
      }
    }
    // start proxy
    proxy = new _proxy2.ProxyServer(serverUrl);
    const [proxyInteractions, proxyUrl] = await proxy.start(options.proxyPort ? Number(options.proxyPort) : undefined);
    interactions = proxyInteractions;
    if (spinner) spinner.text = 'Sending requests to server';
    let [sendRequestsPromise, runRequestsPromise] = makeAllRequests(captureConfig, proxyUrl, spinner);
    // Here we continue even if some of the requests failed - we log out the requests errors but use the rest to query
    const requestsPromises = Promise.all([sendRequestsPromise, runRequestsPromise]);
    // Wait for either all the requests to complete (or reject), or for the app to shutdown prematurely
    await Promise.race([bailout.promise.then(e => {
      throw e;
    }), requestsPromises]);
    // catch the bailout promise rejection when we shutdown the app
    bailout.promise.catch(e => {});
  } catch (e) {
    spinner === null || spinner === void 0 || spinner.fail(e.message);

    // Meaning either the requests threw an uncaught exception or the app server randomly quit
    process.exitCode = 1;
    // The finally block will run before we return from the fn call
    return;
  } finally {
    unsubscribeHook();
    cleanup();
    if (errors.length > 0) {
      _logger.logger.error('finished with errors:');
      errors.forEach((error, index) => {
        _logger.logger.error(`${index}:\n${error}`);
      });
    }
  }
  spinner === null || spinner === void 0 || spinner.succeed('Finished running requests');

  // process proxy interactions into hars
  return _har.HarEntries.fromProxyInteractions(interactions);
}