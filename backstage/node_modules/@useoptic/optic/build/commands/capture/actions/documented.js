"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.diffExistingEndpoint = diffExistingEndpoint;
var _patches = require("../patches/patches");
var AT = _interopRequireWildcard(require("../../oas/lib/async-tools"));
var _file = require("../write/file");
var _summaries = require("../patches/summaries");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
// Groups together diffs that are triggered from the same schema instance (we could have multiple interactions or array items that trigger a custom schema error)
// The reason we need to group these diffs and not the patches, is because once a patchable diff is hit the in-memory spec used to continue diffing never generates the second diff.
// In the case of unpatchable diffs, we get all interactions that would have caused this issue
async function groupUnpatchableDiffs(collectedPatches) {
  const patchesOrGroupedDiffs = [];
  const relatedErrorToIdx = new Map();
  for (let i = 0; i < collectedPatches.length; i++) {
    const patchOrDiff = collectedPatches[i];
    if ('unpatchable' in patchOrDiff) {
      const errorId = `${patchOrDiff.validationError.schemaPath}${patchOrDiff.validationError.keyword}`;
      const relatedIdx = relatedErrorToIdx.get(errorId);
      if (typeof relatedIdx === 'number') {
        const relatedDiff = patchesOrGroupedDiffs[relatedIdx];
        if ('unpatchable' in relatedDiff) {
          relatedDiff.examples.push(patchOrDiff.example);
        } else {
          throw new Error('Invalid index for patchesOrGroupedDiffs');
        }
      } else {
        relatedErrorToIdx.set(errorId, patchesOrGroupedDiffs.length);
        const {
          example,
          ...withoutExample
        } = patchOrDiff;
        patchesOrGroupedDiffs.push({
          ...withoutExample,
          examples: [example]
        });
      }
    } else {
      patchesOrGroupedDiffs.push(patchOrDiff);
    }
  }
  return async function* () {
    for (const patchOrDiff of patchesOrGroupedDiffs) {
      yield patchOrDiff;
    }
  }();
}
async function diffExistingEndpoint(interactions, parseResult, coverage, endpoint, options) {
  const patchSummaries = new _summaries.EndpointPatchSummaries(parseResult, options);
  function addPatchSummary(patchOrDiff) {
    coverage.shapeDiff(patchOrDiff);
    patchSummaries.addPatch(patchOrDiff);
  }
  const groupedDiffs = await groupUnpatchableDiffs(await AT.collect((0, _patches.generateEndpointSpecPatches)(interactions, {
    spec: parseResult.jsonLike
  }, endpoint, {
    coverage
  })));
  const specPatches = AT.filter(patchOrDiff => {
    return !('unpatchable' in patchOrDiff);
  })(AT.tap(addPatchSummary)(groupedDiffs));
  if (options.update) {
    const operations = await (0, _patches.jsonOpsFromSpecPatches)(specPatches);
    await (0, _file.writePatchesToFiles)(operations, parseResult.sourcemap);
  } else {
    for await (const _ of specPatches) {}
  }
  const summaries = patchSummaries.getPatchSummaries();
  return {
    patchSummaries: summaries,
    hasDiffs: summaries.length > 0
  };
}