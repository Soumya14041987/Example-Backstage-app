"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.documentNewEndpoint = documentNewEndpoint;
exports.promptUserForPathPattern = promptUserForPathPattern;
var _prompts = _interopRequireDefault(require("prompts"));
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _pathPatterns = require("../../../utils/pathPatterns");
var _minimatch = require("minimatch");
var _logger = require("../../../logger");
var AT = _interopRequireWildcard(require("../../oas/lib/async-tools"));
var _patches = require("../patches/patches");
var _chalk = _interopRequireDefault(require("chalk"));
var _file = require("../write/file");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
async function promptUserForPathPattern(interactions, pathInference, options) {
  const filteredInteractions = [];
  const methodMap = new Map(Object.values(_openapiUtilities.OpenAPIV3.HttpMethods).filter(method => method !== 'options' && method !== 'head').map(method => [method, {
    add: new Set(),
    ignore: new Set()
  }]));
  const newIgnorePaths = [];
  for await (const interaction of interactions) {
    const {
      path,
      method
    } = interaction.request;
    const pathsNode = methodMap.get(method);
    if (!pathsNode) {
      _logger.logger.debug(`Skipping ${method} ${path} because ${method} is not a supported method`);
      continue;
    }
    const {
      add,
      ignore
    } = pathsNode;
    const pathInAdd = [...add.values()].some(p => (0, _pathPatterns.matchPathPattern)(p, path).match);
    const pathInIgnore = [...ignore.values()].some(ignore => (0, _minimatch.minimatch)(path, ignore));
    const guessedPattern = pathInference.getInferedPattern(path);
    if (pathInAdd) {
      filteredInteractions.push(interaction);
    } else if (pathInIgnore) {
      _logger.logger.debug(`Skipping ${method} ${path} because is in ignored specs`);
      continue;
    } else if (options.update === 'automatic') {
      add.add(guessedPattern);
      pathInference.addKnownPath(guessedPattern);
      filteredInteractions.push(interaction);
    } else {
      _logger.logger.info(`> ` + _chalk.default.bold.blue(guessedPattern));
      const results = await (0, _prompts.default)([{
        type: 'select',
        name: 'action',
        message: `Is this the right pattern for ${_chalk.default.gray(`${method.toUpperCase()} ${path}`)}`,
        choices: [{
          title: 'yes',
          value: 'yes'
        }, {
          title: 'no',
          value: 'no'
        }, {
          title: 'ignore',
          value: 'ignore'
        }, {
          title: 'skip',
          value: 'skip'
        }]
      }, {
        type: pre => pre === 'no' ? 'text' : null,
        name: 'newPath',
        message: `Provide the correct path (e.g. ${_chalk.default.gray('/api/users/{userId}')})`,
        validate: pattern => (0, _pathPatterns.matchPathPattern)(pattern, interaction.request.path).match ? true : `Must be a valid path pattern and match the path ${path}`
      }], {
        onCancel: () => process.exit(1)
      });
      if (results.action === 'yes') {
        add.add(guessedPattern);
        pathInference.addKnownPath(guessedPattern);
        filteredInteractions.push(interaction);
      } else if (results.action === 'no') {
        add.add(results.newPath);
        pathInference.addKnownPath(results.newPath);
        filteredInteractions.push(interaction);
      } else if (results.action === 'skip') {
        continue;
      } else {
        ignore.add(path);
        newIgnorePaths.push({
          method,
          path
        });
      }
    }
  }
  const endpointsToAdd = [];
  for (const [method, methodNode] of methodMap) {
    for (const path of methodNode.add) {
      endpointsToAdd.push({
        method,
        path
      });
    }
  }
  return {
    interactions: filteredInteractions,
    endpointsToAdd,
    ignorePaths: newIgnorePaths
  };
}
async function documentNewEndpoint(interactions, parseResult, endpoint) {
  const interactionsAsAsyncIterator = async function* () {
    for (const interaction of interactions) {
      const {
        path,
        method
      } = interaction.request;
      if ((0, _pathPatterns.matchPathPattern)(endpoint.path, path).match && endpoint.method === method) {
        yield interaction;
      }
    }
  }();

  // generate patches to add the endpoint if doesn't exist
  const specPatches = async function* () {
    // Holds the same reference so we can mutate the spec in place and pass it to different generators
    const specHolder = {
      spec: parseResult.jsonLike
    };
    const meta = {
      schemaAdditionsSet: new Set(),
      usedExistingRef: false
    };
    yield* (0, _patches.generatePathAndMethodSpecPatches)(specHolder, endpoint);

    // We don't need to collect unpatchable diffs here, since optic is generating a spec from no schema, we'll always know how to handle schemas we create
    yield* AT.filter(diffOrPatch => !('unpatchable' in diffOrPatch))((0, _patches.generateEndpointSpecPatches)(interactionsAsAsyncIterator, specHolder, endpoint, meta));
    yield* (0, _patches.generateRefRefactorPatches)(specHolder, meta);

    // If we use an existing ref, we need to rerun traffic
    if (meta.usedExistingRef) {
      yield* AT.filter(diffOrPatch => !('unpatchable' in diffOrPatch))((0, _patches.generateEndpointSpecPatches)(interactionsAsAsyncIterator, specHolder, endpoint, meta));
    }
  }();
  const operations = await (0, _patches.jsonOpsFromSpecPatches)(specPatches);
  await (0, _file.writePatchesToFiles)(operations, parseResult.sourcemap);
}