"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processCaptures = processCaptures;
exports.registerCaptureCommand = registerCaptureCommand;
var _chalk = _interopRequireDefault(require("chalk"));
var _commander = require("commander");
var _path = _interopRequireDefault(require("path"));
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _nodeFs = _interopRequireDefault(require("node:fs"));
var _openapiIo = require("@useoptic/openapi-io");
var _errorHandler = require("../../error-handler");
var _specs = require("../../utils/specs");
var _logger = require("../../logger");
var _config = require("../../config");
var _captureClear = require("../oas/capture-clear");
var _captureInit = require("./capture-init");
var _capture = require("../oas/capture");
var _storage = require("./storage");
var _specLoaders = require("../../utils/spec-loaders");
var _apiCoverage = require("./coverage/api-coverage");
var _har = require("./sources/har");
var _actions = require("./actions");
var _captureRequests = require("./actions/captureRequests");
var _postman = require("./sources/postman");
var _capturedInteractions = require("./sources/captured-interactions");
var AT = _interopRequireWildcard(require("../oas/lib/async-tools"));
var _groupedInteractions = require("./interactions/grouped-interactions");
var _capture2 = require("../../utils/capture");
var _pathInference = require("./operations/path-inference");
var _spinner = require("../../utils/spinner");
var _segment = require("../../segment");
var _lodash = _interopRequireDefault(require("lodash.sortby"));
var Git = _interopRequireWildcard(require("../../utils/git-utils"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const indent = n => '  '.repeat(n);
function registerCaptureCommand(cli, config) {
  const command = cli.command('capture');
  command.argument('<openapi-file>', 'An OpenAPI spec file to add an operation to').argument('[target-url]', 'The url to capture (deprecated, use optic.yml configuration instead)').description('Capture traffic using the configuration in optic.yml').addOption(new _commander.Option('-p, --proxy-port <proxy-port>', 'Specify the port the proxy should be running on').default(8000)).addOption(new _commander.Option('-u, --update [mode]', `Update the OpenAPI spec based on the traffic. Mode selects the update behavior:
- documented: Update previously documented endpoints
- interactive: Prompt for new endpoints
- automatic: Automatically document new endpoints`).preset('documented').choices(['interactive', 'automatic', 'documented'])).option('--postman <postman-collection-file>', 'Path to Postman collection').option('--har <har-file or directory>', 'Path to har file (v1.2, v1.3), or directory containing har files').option('--verbose', 'Display verbose diff output', false).option('-s, --server-override <url>', 'Skip executing `capture[].server.command` and forward proxy traffic to this URL instead').option('--upload', 'Upload coverage results to Optic Cloud', false)
  // TODO deprecate hidden options below
  .addOption(new _commander.Option('--no-tls', 'Disable TLS support for --proxy and prevent generation of new CA certificates').hideHelp()).addOption(new _commander.Option('-r, --reverse-proxy', 'Run optic capture in reverse proxy mode').hideHelp()).addOption(new _commander.Option('--command <command>', 'Command to run with the http_proxy and http_proxy configured').hideHelp()).addOption(new _commander.Option('-d, --debug', `Output debug information (on stderr). Use LOG_LEVEL env with 'debug', 'info' to increase verbosity.`).hideHelp()).addOption(new _commander.Option('-o, --output <output>', 'File name for output').hideHelp()).action((0, _errorHandler.errorHandler)(getCaptureAction(config, command), {
    command: 'capture'
  }));

  // subcommands
  command.addCommand((0, _captureClear.clearCommand)()).addCommand((0, _captureInit.initCommand)(config));
}
const getCaptureAction = (config, command) => async (filePath, targetUrl, options) => {
  var _config$capture, _config$vcs, _captureConfig$reques3, _captureConfig$reques4;
  // capture v1
  if (targetUrl !== undefined) {
    _logger.logger.warn(_chalk.default.yellow.bold(`optic capture <filepath> <url> is deprecated. Start using the new capture flow by running "optic capture init ${filePath}"`));
    await (0, _capture.captureV1)(filePath, targetUrl, config, command);
    return;
  }
  (0, _segment.trackEvent)('optic.capture.start', {
    input: options.har ? 'har' : options.postman ? 'postman' : 'capture',
    mode: options.update ?? 'verify',
    isInCi: config.isInCi
  });
  const trafficDirectory = await setup(filePath);
  _logger.logger.debug(`Writing captured traffic to ${trafficDirectory}`);
  let spec = await (0, _specLoaders.loadSpec)(filePath, config, {
    strict: false,
    denormalize: false
  });
  if (spec.version === '2.x.x') {
    _logger.logger.error(`capture does not support swagger 2 specifications`);
    process.exitCode = 1;
    return;
  }
  let serverUrl = null;
  let captures;
  const pathFromRoot = (0, _capture2.resolveRelativePath)(config.root, filePath);
  const captureConfig = (_config$capture = config.capture) === null || _config$capture === void 0 ? void 0 : _config$capture[pathFromRoot];
  if (options.har) {
    captures = new _groupedInteractions.GroupedCaptures(trafficDirectory, spec.jsonLike);
    try {
      const harEntries = (0, _har.getHarEntriesFromFs)(options.har);
      for await (const harOrErr of harEntries) {
        if (harOrErr.ok) {
          captures.addHar(harOrErr.val);
        } else {
          _logger.logger.debug(harOrErr.val);
        }
      }
    } catch (e) {
      _logger.logger.error(_chalk.default.red(`Error parsing ${options.har}`));
      _logger.logger.error(e);
      process.exitCode = 1;
      return;
    }
  } else if (options.postman) {
    captures = new _groupedInteractions.GroupedCaptures(trafficDirectory, spec.jsonLike);
    const postmanEntryResults = _postman.PostmanCollectionEntries.fromReadable(_nodeFs.default.createReadStream(options.postman));
    let postmanEntries = AT.unwrapOr(postmanEntryResults, err => {
      _logger.logger.debug(err);
    });
    for await (const interaction of _capturedInteractions.CapturedInteractions.fromPostmanCollection(postmanEntries)) {
      captures.addInteraction(interaction);
    }
  } else {
    var _captureConfig$reques, _captureConfig$reques2;
    // verify capture v2 config is present
    if (targetUrl !== undefined || captureConfig === undefined) {
      const initSuggestion = `'optic capture init ${filePath}'`;
      config.isDefaultConfig ? _logger.logger.error(`An optic.yml file wasn't found. To create an optic.yml file with a default capture block, run ${initSuggestion}.`) : _logger.logger.error(`Expected a capture config entry for ${pathFromRoot}. To add a capture config entry to your optic.yml, run ${initSuggestion}.`);
      process.exitCode = 1;
      return;
    }

    // verify that capture.requests or capture.requests_command is set
    if (!((_captureConfig$reques = captureConfig.requests) !== null && _captureConfig$reques !== void 0 && _captureConfig$reques.run) && !((_captureConfig$reques2 = captureConfig.requests) !== null && _captureConfig$reques2 !== void 0 && _captureConfig$reques2.send)) {
      _logger.logger.error(`"requests.send" or "requests.run" must be specified in optic.yml`);
      process.exitCode = 1;
      return;
    }

    // verify port number is valid
    if (options.proxyPort && isNaN(Number(options.proxyPort))) {
      _logger.logger.error(`--proxy-port must be a number - received ${options.proxyPort}`);
      process.exitCode = 1;
      return;
    }
    serverUrl = options.serverOverride || captureConfig.server.url;
    captures = new _groupedInteractions.GroupedCaptures(trafficDirectory, spec.jsonLike, {
      baseServerUrl: serverUrl
    });
    const harEntries = await (0, _captureRequests.captureRequestsFromProxy)(config, captureConfig, {
      ...options,
      serverUrl
    });
    if (!harEntries) {
      // Error thrown where we don't have requests
      process.exitCode = 1;
      return;
    }
    for await (const har of harEntries) {
      captures.addHar(har);
      _logger.logger.debug(`Captured ${har.request.method.toUpperCase()} ${har.request.url}`);
    }
    await captures.writeHarFiles();
  }
  const captureOutput = await processCaptures({
    cliConfig: config,
    captureConfig: captureConfig,
    spec,
    filePath,
    captures
  }, {
    ...options,
    bufferLogs: false
  });
  if (!captureOutput.success) {
    process.exitCode = 1;
    return;
  }
  const {
    unmatchedInteractions,
    totalInteractions,
    coverage,
    endpointsAdded,
    hasAnyDiffs,
    endpointCounts
  } = captureOutput;
  const maybeOrigin = ((_config$vcs = config.vcs) === null || _config$vcs === void 0 ? void 0 : _config$vcs.type) === _config.VCS.Git ? await Git.guessRemoteOrigin() : null;
  const relativePath = _path.default.relative(config.root, _path.default.resolve(filePath));
  (0, _segment.trackEvent)('optic.capture.completed', {
    input: options.har ? 'har' : options.postman ? 'postman' : 'capture',
    mode: options.update ?? 'verify',
    serverUrl,
    captureCmd: (captureConfig === null || captureConfig === void 0 || (_captureConfig$reques3 = captureConfig.requests.run) === null || _captureConfig$reques3 === void 0 ? void 0 : _captureConfig$reques3.command) ?? null,
    captureRequests: (captureConfig === null || captureConfig === void 0 || (_captureConfig$reques4 = captureConfig.requests.send) === null || _captureConfig$reques4 === void 0 ? void 0 : _captureConfig$reques4.length) ?? 0,
    interactionCount: totalInteractions,
    endpointsAdded,
    endpointsUpdated: options.update ? endpointCounts.total : 0,
    isInCi: config.isInCi,
    upload: options.upload,
    ...(maybeOrigin !== null && maybeOrigin !== void 0 && maybeOrigin.web_url ? {
      webUrlAndPath: `${maybeOrigin.web_url}.${relativePath}`,
      webUrl: maybeOrigin.web_url
    } : {})
  });
  if (options.upload) {
    if (options.update) {
      _logger.logger.error('optic capture --upload cannot be run with the --update flag');
      process.exitCode = 1;
      return;
    }
    _logger.logger.error(`Coverage upload is no longer supported`);
  }
  if (hasAnyDiffs) {
    process.exitCode = 1;
  }
  if (unmatchedInteractions && (options.update === 'documented' || !options.update)) {
    _logger.logger.info('');
    _logger.logger.info(_chalk.default.yellow(`New endpoints are only added in interactive mode. Run 'optic capture ${filePath} --update interactive' to add new endpoints`));
    process.exitCode = 1;
  }
  await (0, _segment.flushEvents)();
};
async function createOpenAPIFile(filePath) {
  const specFile = (0, _specs.createNewSpecFile)('3.1.0');
  if ((0, _openapiIo.isJson)(filePath)) {
    _logger.logger.info(`Initializing OpenAPI file at ${filePath}`);
    await _promises.default.mkdir(_path.default.dirname(filePath), {
      recursive: true
    });
    await _promises.default.writeFile(filePath, JSON.stringify(specFile, null, 2));
    return true;
  } else if ((0, _openapiIo.isYaml)(filePath)) {
    await _promises.default.mkdir(_path.default.dirname(filePath), {
      recursive: true
    });
    _logger.logger.info(`Initializing OpenAPI file at ${filePath}`);
    await _promises.default.writeFile(filePath, (0, _openapiIo.writeYaml)(specFile));
    return true;
  } else {
    return false;
  }
}
function getSummaryText(endpointCoverage) {
  const getIcon = node => node.seen ? node.diffs ? _chalk.default.red('× ') : _chalk.default.green('✓ ') : '';
  const items = [];
  if (endpointCoverage.requestBody) {
    const icon = getIcon(endpointCoverage.requestBody);
    items.push(`${icon}Request Body`);
  }
  const coverageResponses = (0, _lodash.default)(Object.entries(endpointCoverage.responses), ([statusCode]) => statusCode);
  for (const [statusCode, node] of coverageResponses) {
    const icon = getIcon(node);
    items.push(`${icon}${statusCode} response`);
  }
  return items.join(', ');
}
async function setup(filePath) {
  const resolvedPath = _path.default.resolve(filePath);
  let openApiExists = false;
  try {
    await _promises.default.stat(resolvedPath);
    openApiExists = true;
  } catch (e) {}
  if (!openApiExists) {
    const fileCreated = await createOpenAPIFile(filePath);
    if (!fileCreated) {
      _logger.logger.error('Could not create OpenAPI file');
      process.exit(1);
    }
  }
  return await (0, _storage.getCaptureStorage)(resolvedPath);
}
async function processCaptures({
  captureConfig,
  cliConfig,
  captures,
  spec,
  filePath
}, options) {
  const bufferedOutput = [];
  const {
    unmatched: unmatchedInteractions,
    total: totalInteractions
  } = captures.interactionCount();
  if (totalInteractions === 0) {
    var _captureConfig$reques5, _captureConfig$reques7;
    const errorMsg = _chalk.default.red('Error: No requests were captured by the Optic proxy');
    options.bufferLogs ? bufferedOutput.push(errorMsg) : _logger.logger.error(errorMsg);
    if (captureConfig !== null && captureConfig !== void 0 && (_captureConfig$reques5 = captureConfig.requests) !== null && _captureConfig$reques5 !== void 0 && _captureConfig$reques5.run) {
      var _captureConfig$reques6;
      const helpMsg = `Check that you are sending requests to the Optic proxy. You can see where the Optic proxy is running by using the ${(captureConfig === null || captureConfig === void 0 || (_captureConfig$reques6 = captureConfig.requests) === null || _captureConfig$reques6 === void 0 ? void 0 : _captureConfig$reques6.run.proxy_variable) ?? 'OPTIC_PROXY'} environment variable`;
      options.bufferLogs ? bufferedOutput.push(helpMsg) : _logger.logger.error(helpMsg);
    } else if (captureConfig !== null && captureConfig !== void 0 && (_captureConfig$reques7 = captureConfig.requests) !== null && _captureConfig$reques7 !== void 0 && _captureConfig$reques7.send) {
      var _captureConfig$reques8, _captureConfig$reques9;
      const helpMsg = `Check that you are sending at least one request in your send configuration. Using config`;
      options.bufferLogs ? bufferedOutput.push(helpMsg) : _logger.logger.error(helpMsg);
      options.bufferLogs ? bufferedOutput.push(JSON.stringify(captureConfig === null || captureConfig === void 0 || (_captureConfig$reques8 = captureConfig.requests) === null || _captureConfig$reques8 === void 0 ? void 0 : _captureConfig$reques8.send)) : _logger.logger.error(captureConfig === null || captureConfig === void 0 || (_captureConfig$reques9 = captureConfig.requests) === null || _captureConfig$reques9 === void 0 ? void 0 : _captureConfig$reques9.send);
    }
    return {
      bufferedOutput,
      success: false
    };
  }

  // update existing endpoints
  const coverage = new _apiCoverage.ApiCoverageCounter((0, _openapiIo.denormalize)(spec, spec.version).jsonLike);
  let hasAnyDiffs = false;
  let diffCount = 0;
  let endpointsAdded = 0;
  let mismatchedEndpoints = new Set();

  // Handle interactions for documented endpoints first
  const interactionsToLog = (0, _lodash.default)([...captures.getDocumentedEndpointInteractions()], ({
    endpoint
  }) => `${endpoint.path}${endpoint.method}`);
  for (const {
    interactions,
    endpoint
  } of interactionsToLog) {
    var _getSpinner;
    const {
      path,
      method
    } = endpoint;
    const endpointText = `${method.toUpperCase()} ${path}`;
    const spinner = !options.bufferLogs ? (_getSpinner = (0, _spinner.getSpinner)({
      text: endpointText,
      color: 'blue'
    })) === null || _getSpinner === void 0 ? void 0 : _getSpinner.start() : (bufferedOutput.push(endpointText), undefined);
    const {
      patchSummaries,
      hasDiffs
    } = await (0, _actions.diffExistingEndpoint)(interactions, spec, coverage, endpoint, options);
    let endpointCoverage = coverage.coverage.paths[path][method];
    if (options.update) {
      var _spec$jsonLike$paths;
      // Since we flush each endpoint updates to disk, we should reload the spec to get the latest spec and sourcemap which we both use to generate the next set of patches
      spec = await (0, _specLoaders.loadSpec)(filePath, cliConfig, {
        strict: false,
        denormalize: false
      });
      const operation = (_spec$jsonLike$paths = spec.jsonLike.paths) === null || _spec$jsonLike$paths === void 0 || (_spec$jsonLike$paths = _spec$jsonLike$paths[path]) === null || _spec$jsonLike$paths === void 0 ? void 0 : _spec$jsonLike$paths[method];
      if (operation) {
        coverage.addEndpoint(operation, path, method, {
          newlyDocumented: true
        });
        endpointCoverage = coverage.coverage.paths[path][method];
      }
      spinner === null || spinner === void 0 || spinner.succeed(endpointText);
    } else {
      if (!hasDiffs) {
        spinner === null || spinner === void 0 || spinner.succeed(endpointText);
      } else {
        mismatchedEndpoints.add(`${method}-${path}`);
        hasAnyDiffs = true;
        spinner === null || spinner === void 0 || spinner.fail(endpointText);
      }
    }
    const summaryText = getSummaryText(endpointCoverage);
    summaryText && options.bufferLogs ? bufferedOutput.push(indent(1) + summaryText) : _logger.logger.info(indent(1) + summaryText);
    for (const patchSummary of patchSummaries) {
      options.bufferLogs ? bufferedOutput.push(indent(1) + patchSummary) : _logger.logger.info(indent(1) + patchSummary);
    }
    diffCount += patchSummaries.length;
  }
  const endpointCounts = captures.counts();
  if (endpointCounts.total > 0 && endpointCounts.unmatched > 0) {
    const unmatchedEndpointsText = `${endpointCounts.unmatched} endpoint${endpointCounts.unmatched === 1 ? '' : 's'}`;
    if (endpointCounts.matched > 0) {
      const txt = _chalk.default.gray(`...and ${unmatchedEndpointsText} that did not receive traffic`);
      options.bufferLogs ? bufferedOutput.push(txt) : _logger.logger.info(txt);
    } else {
      const txt = _chalk.default.gray(`${unmatchedEndpointsText} did not receive traffic`);
      options.bufferLogs ? bufferedOutput.push(txt) : _logger.logger.info(txt);
    }
    if (options.verbose) {
      const text = [_chalk.default.gray(`Unmatched endpoints:`)];
      for (const endpoint of endpointCounts.paths.unmatched) {
        text.push(`  ${_chalk.default.gray(`${endpoint.method.toUpperCase()} ${endpoint.path}`)}`);
      }
      for (const line of text) options.bufferLogs ? bufferedOutput.push(line) : _logger.logger.info(line);
    }
  }

  // document new endpoints
  if (unmatchedInteractions) {
    if (options.update === 'interactive' || options.update === 'automatic') {
      options.bufferLogs ? bufferedOutput.push('') : _logger.logger.info('');
      const summary = _chalk.default.bold.gray('Learning path patterns for unmatched requests...');
      options.bufferLogs ? bufferedOutput.push(summary) : _logger.logger.info(summary);
      const inferredPathStructure = await _pathInference.PathInference.fromSpecAndInteractions(spec.jsonLike, captures.getUndocumentedInteractions());
      const {
        interactions: filteredInteractions,
        ignorePaths: newIgnorePaths,
        endpointsToAdd
      } = await (0, _actions.promptUserForPathPattern)(captures.getUndocumentedInteractions(), inferredPathStructure, {
        update: options.update
      });
      const header = _chalk.default.bold.gray('Documenting new operations:');
      options.bufferLogs ? bufferedOutput.push(header) : _logger.logger.info(header);
      for (const endpoint of (0, _lodash.default)(endpointsToAdd, e => `${e.path}${e.method}`)) {
        var _getSpinner2;
        const {
          path,
          method
        } = endpoint;
        const endpointText = `${method.toUpperCase()} ${path}`;
        const spinner = (_getSpinner2 = (0, _spinner.getSpinner)({
          text: endpointText,
          color: 'blue'
        })) === null || _getSpinner2 === void 0 ? void 0 : _getSpinner2.start();
        await (0, _actions.documentNewEndpoint)(filteredInteractions, spec, endpoint);

        // Since we flush each endpoint updates to disk, we should reload the spec to get the latest spec and sourcemap which we both use to generate the next set of patches
        spec = await (0, _specLoaders.loadSpec)(filePath, cliConfig, {
          strict: false,
          denormalize: false
        });
        spinner === null || spinner === void 0 || spinner.succeed();
      }
      endpointsAdded = endpointsToAdd.length;
      if (newIgnorePaths.length) {
        await (0, _actions.addIgnorePaths)(spec, newIgnorePaths);
      }
    }
  }
  if (!options.update) {
    const coverageStats = coverage.calculateCoverage();
    const coverageText = `${coverageStats.percent}% coverage of your documented operations.`;
    const requestsText = unmatchedInteractions === 0 ? `All requests matched a documented path (${totalInteractions} total requests)` : `${unmatchedInteractions} requests did not match a documented path (${totalInteractions} total requests).`;
    const diffText = `${diffCount} diffs detected in documented operations`;
    options.bufferLogs ? bufferedOutput.push('') : _logger.logger.info();
    options.bufferLogs ? bufferedOutput.push(`${coverageText} ${requestsText}`) : _logger.logger.info(`${coverageText} ${requestsText}`);
    diffCount !== 0 && (options.bufferLogs ? bufferedOutput.push(diffText) : _logger.logger.info(diffText));
  } else if (options.update === 'documented' && unmatchedInteractions > 0) {
    const unmatchedText = `${unmatchedInteractions} unmatched requests`;
    options.bufferLogs ? bufferedOutput.push('') : _logger.logger.info();
    options.bufferLogs ? bufferedOutput.push(unmatchedText) : _logger.logger.info(unmatchedText);
  }
  return {
    unmatchedInteractions,
    totalInteractions,
    coverage,
    endpointsAdded,
    mismatchedEndpoints: mismatchedEndpoints.size,
    endpointCounts,
    bufferedOutput,
    hasAnyDiffs,
    success: true
  };
}