"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ApiCoverageCounter = void 0;
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _chalk = _interopRequireDefault(require("chalk"));
var _lodash = _interopRequireDefault(require("lodash.sortby"));
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _checksum = require("../../../utils/checksum");
var _operations = require("../../oas/operations");
var _openapiIo = require("@useoptic/openapi-io");
class ApiCoverageCounter {
  constructor(spec) {
    this.coverage = {
      paths: {}
    };
    const {
      jsonLike: denormalizedSpec
    } = (0, _openapiIo.denormalize)({
      jsonLike: JSON.parse(JSON.stringify(spec))
    }, '3.0.x');
    Object.entries(denormalizedSpec.paths ?? {}).forEach(([path, methods]) => {
      this.coverage.paths[path] = {};
      Object.entries(methods || {}).forEach(entry => {
        const [method, operation] = entry;
        if (Object.values(_openapiUtilities.OpenAPIV3.HttpMethods).includes(method)) {
          this.addEndpoint(operation, path, method, {
            newlyDocumented: false
          });
        }
      });
    });
  }
  addEndpoint(operation, path, method, options) {
    const responses = {};
    const initialSeen = options.newlyDocumented;
    Object.keys(operation.responses || {}).forEach(res => {
      responses[res] = {
        seen: initialSeen,
        diffs: false
      };
    });
    const endpointChecksum = (0, _checksum.computeEndpointChecksum)(path, method, operation);
    this.coverage.paths[path][method] = {
      checksum: endpointChecksum,
      interactions: 0,
      responses,
      requestBody: operation.requestBody ? {
        seen: initialSeen,
        diffs: false
      } : undefined,
      seen: initialSeen,
      diffs: false
    };
  }
  operationInteraction = (pathPattern, method, hasRequestBody, statusCode) => {
    var _this$coverage$paths$;
    const operation = (_this$coverage$paths$ = this.coverage.paths[pathPattern]) === null || _this$coverage$paths$ === void 0 ? void 0 : _this$coverage$paths$[method];
    if (operation) {
      operation.interactions++;
      operation.seen = true;
      const hasValidStatusCode = statusCode ? Number(statusCode) >= 200 && Number(statusCode) < 400 : false;
      if (hasRequestBody && operation.requestBody && hasValidStatusCode) operation.requestBody.seen = true;
      let partialMatch;
      // exact match
      if (statusCode) {
        if (operation.responses[statusCode]) {
          operation.responses[statusCode].seen = true;
        } else if (partialMatch = partialMatches(Object.keys(operation.responses), statusCode)) {
          operation.responses[partialMatch].seen = true;
        } else if (operation.responses['default']) {
          operation.responses['default'].seen = true;
        }
      }
    }
  };
  shapeDiff = patch => {
    var _this$coverage$paths$2;
    const parts = _jsonPointerHelpers.jsonPointerHelpers.decode(patch.path);
    const [_, pathPattern, method] = parts;
    const operation = (_this$coverage$paths$2 = this.coverage.paths[pathPattern]) === null || _this$coverage$paths$2 === void 0 ? void 0 : _this$coverage$paths$2[method];
    if (operation) {
      var _patch$diff, _patch$diff2, _patch$diff3;
      if ('unpatchable' in patch || ((_patch$diff = patch.diff) === null || _patch$diff === void 0 ? void 0 : _patch$diff.kind) === 'UnmatchedType' || ((_patch$diff2 = patch.diff) === null || _patch$diff2 === void 0 ? void 0 : _patch$diff2.kind) === 'AdditionalProperty' || ((_patch$diff3 = patch.diff) === null || _patch$diff3 === void 0 ? void 0 : _patch$diff3.kind) === 'MissingRequiredProperty') {
        const isResponse = _jsonPointerHelpers.jsonPointerHelpers.startsWith(patch.path, ['paths', '**', '**', 'responses']);
        if (isResponse) {
          const [, _pathPattern, _method,, statusCode] = parts;
          if (operation.responses[statusCode]) {
            operation.responses[statusCode].diffs = true;
          }
        } else {
          if (operation.requestBody) {
            operation.requestBody.diffs = true;
          }
        }
      }
    }
  };
  calculateCoverage = () => {
    let branches = 0;
    let count = 0;
    let interactions = 0;
    Object.entries(this.coverage.paths).forEach(([_, methods]) => {
      Object.entries(methods).forEach(([method, operation]) => {
        branches++;
        if (operation.seen) count++;
        interactions += operation.interactions;
        if (operation.requestBody) {
          branches++;
          if (operation.requestBody.seen) count++;
        }
        Object.entries(operation.responses).forEach(([_, response]) => {
          branches++;
          if (response.seen) count++;
        });
      });
    });
    return {
      branches,
      count,
      percent: branches === 0 ? '0' : (count / branches * 100).toFixed(1),
      totalRequests: interactions
    };
  };
  renderCoverage = () => {
    const {
      percent
    } = this.calculateCoverage();
    console.log(' ' + _chalk.default.bold.underline(`Coverage Report ${percent}%`));
    const toPrint = [];
    Object.entries(this.coverage.paths).forEach(([path, methods]) => {
      Object.entries(methods).forEach(([method, operation]) => {
        const seen = (0, _openapiUtilities.countOperationCoverage)(operation, x => x.seen);
        const max = (0, _openapiUtilities.countOperationCoverage)(operation, () => true);
        const percentCovered = seen / max * 100;
        const responses = ` ${percentCovered !== 0 ? '●' : '◌'}${percentCovered > 25 ? '●' : '◌'}${percentCovered > 50 ? '●' : '◌'}${percentCovered > 75 ? '●' : '◌'} `;
        const line1 = seen === 0 ? _chalk.default.dim.bold(`${responses}  ${method} ${path}`) : _chalk.default.bold(`${responses}  ${method} ${path}`);
        let line2Items = [' ' + operation.interactions.toString().padStart(4, ' ') + '  '];
        if (operation.requestBody) {
          line2Items.push(operation.requestBody.seen ? _chalk.default.green('RequestBody') : _chalk.default.dim('RequestBody'));
        }
        Object.entries(operation.responses).forEach(([statusCode, response]) => {
          if (response.seen) {
            line2Items.push(_chalk.default.green(statusCode));
          } else {
            line2Items.push(_chalk.default.dim(statusCode));
          }
        });
        toPrint.push([operation.interactions, `${line1}\n${line2Items.join(' ')}`]);
      });
    });
    (0, _lodash.default)(toPrint, cov => 1 - cov[0]).forEach(cov => console.log(cov[1]));
    console.log('');
  };
}
exports.ApiCoverageCounter = ApiCoverageCounter;
function partialMatches(statusCodes, current) {
  return statusCodes.find(code => {
    if (_operations.statusRangePattern.test(code) && code.substring(0, 1) === current.substring(0, 1)) {
      return true;
    }
  });
}