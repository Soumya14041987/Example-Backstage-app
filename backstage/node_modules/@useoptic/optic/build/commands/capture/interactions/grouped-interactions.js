"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GroupedCaptures = void 0;
exports.createHostBaseMap = createHostBaseMap;
exports.filterIgnoredInteractions = filterIgnoredInteractions;
exports.handleServerPathPrefix = handleServerPathPrefix;
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _crypto = _interopRequireDefault(require("crypto"));
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _path = _interopRequireDefault(require("path"));
var _capturedInteractions = require("../sources/captured-interactions");
var _queries = require("../operations/queries");
var _logger = require("../../../logger");
var _specs = require("../../../utils/specs");
var _minimatch = require("minimatch");
function createHostBaseMap(spec, options = {}) {
  const hostBaseMap = {};
  const servers = spec.servers ?? [];
  if (options.baseServerUrl) servers.push({
    url: options.baseServerUrl
  });
  servers.forEach(server => {
    try {
      // add absolute in case url is relative (valid in OpenAPI, ignored when absolute)
      const parsed = new URL(server.url);
      const pathName = parsed.pathname;
      const pathWithoutTrailingSlash = pathName.endsWith('/') && pathName.length > 1 ? pathName.substring(0, pathName.length - 1) : pathName;
      // Only overwrite if this host is more specific
      // This assumes only one path per hostname - if there's a case we need to handle more than one prefix per hostname we need to update this code
      if (!hostBaseMap[parsed.host] || hostBaseMap[parsed.host].length < pathWithoutTrailingSlash.length) {
        hostBaseMap[parsed.host] = pathWithoutTrailingSlash;
      }
    } catch (e) {}
  });
  return hostBaseMap;
}
function adjustPath({
  path,
  method,
  host
}, hostBaseMap, options = {}) {
  if (hostBaseMap[host] && hostBaseMap[host] !== '/') {
    const base = hostBaseMap[host];
    if (path.startsWith(base)) {
      const adjustedPath = path === base ? '/' : path.replace(base, '');
      return adjustedPath;
    } else {
      // Otherwise this is a request we should ignore since it doesn't match the base path for the hostBaseMap
      !options.silent && _logger.logger.debug(`Skipping interaction ${path} ${method} because path does not start with the hostname base: ${base}`);
      return null;
    }
  }
  return path;
}
async function* handleServerPathPrefix(interactions, hostBaseMap) {
  for await (const interaction of interactions) {
    const adjustedPath = adjustPath(interaction.request, hostBaseMap);
    if (adjustedPath) {
      const adjustedInteraction = {
        ...interaction,
        request: {
          ...interaction.request,
          path: adjustedPath
        }
      };
      yield adjustedInteraction;
    }
  }
}
async function* filterIgnoredInteractions(interactions, spec) {
  const ignorePaths = (0, _specs.getIgnorePaths)(spec);
  const methodMap = new Map(Object.values(_openapiUtilities.OpenAPIV3.HttpMethods).filter(method => method !== 'options' && method !== 'head').map(method => [method, new Set()]));
  for (const ignore of ignorePaths) {
    if (ignore.method) {
      var _methodMap$get;
      (_methodMap$get = methodMap.get(ignore.method)) === null || _methodMap$get === void 0 || _methodMap$get.add(ignore.path);
    } else {
      for (const [, ignoreSet] of methodMap) {
        ignoreSet.add(ignore.path);
      }
    }
  }
  for await (const interaction of interactions) {
    const ignorePaths = methodMap.get(interaction.request.method) ?? new Set();
    const ignoreMatch = [...ignorePaths.values()].find(p => (0, _minimatch.minimatch)(interaction.request.path, p));
    if (ignoreMatch) {
      _logger.logger.debug(`Skipping interaction ${interaction.request.path} ${interaction.request.method} because path matched the ignore pattern ${ignoreMatch}`);
    } else {
      yield interaction;
    }
  }
}
class GroupedCaptures {
  // TODO - store interactions over hars - to do this:
  // - update capture interactions to be serializable (i.e. stop storing CapturedBody as a stream)
  // - build a read / write storage format for interactions

  // TODO - if we want to store + use cached hars, we'll need to store the `hostBaseMap` (tbd) - this is sometimes specified in `serverOverride` or `server.url`
  // which tells the hars how we store it.

  constructor(trafficDir, spec, options = {}) {
    this.spec = spec;
    this.hostBaseMap = createHostBaseMap(spec, options);
    const endpoints = (0, _queries.specToOperations)(spec).map(p => ({
      ...p,
      path: p.pathPattern
    }));
    this.queries = new _queries.OperationQueries(endpoints.map(e => ({
      pathPattern: e.path,
      method: e.method,
      specPath: _jsonPointerHelpers.jsonPointerHelpers.compile(['paths', e.path, e.method])
    })));
    this.paths = new Map();
    for (const endpoint of endpoints) {
      const id = (0, _openapiUtilities.getEndpointId)(endpoint);
      const endpointHash = _crypto.default.createHash('md5').update(id).digest('hex');
      const fPath = _path.default.join(trafficDir, `${endpointHash}.har`);
      this.paths.set(id, {
        path: fPath,
        hars: [],
        interactions: [],
        endpoint
      });
    }
    const unmatched = _path.default.join(trafficDir, `unmatched.har`);
    this.unmatched = {
      path: unmatched,
      hars: [],
      interactions: []
    };
  }
  addInteraction(interaction) {
    const pathname = adjustPath(interaction.request, this.hostBaseMap, {
      silent: true
    }) ?? interaction.request.path;
    const opRes = this.queries.findOperation(pathname, interaction.request.method);
    const operation = opRes.ok && opRes.val.some ? opRes.val.val : null;
    const pathNode = operation ? this.paths.get((0, _openapiUtilities.getEndpointId)({
      method: operation.method,
      path: operation.pathPattern
    })) : null;
    if (!pathNode) {
      this.unmatched.interactions.push(interaction);
    } else {
      pathNode.interactions.push(interaction);
    }
  }
  addHar(har) {
    let pathname;
    try {
      const url = new URL(har.request.url);
      pathname = adjustPath({
        method: har.request.method,
        path: url.pathname,
        host: url.host
      }, this.hostBaseMap, {
        silent: true
      }) ?? url.pathname;
    } catch (e) {
      _logger.logger.debug(`Skipping har entry - invalid URL`);
      _logger.logger.debug(har);
      _logger.logger.debug(e);
      return;
    }
    const opRes = this.queries.findOperation(pathname, har.request.method);
    const operation = opRes.ok && opRes.val.some ? opRes.val.val : null;
    const pathNode = operation ? this.paths.get((0, _openapiUtilities.getEndpointId)({
      method: operation.method,
      path: operation.pathPattern
    })) : null;
    if (!pathNode) {
      this.unmatched.hars.push(har);
    } else {
      pathNode.hars.push(har);
    }
  }
  async writeHarFiles() {
    for (const file of [...this.paths.values(), this.unmatched]) {
      if (!file.hars.length) continue;
      const har = {
        log: {
          version: '1.3',
          creator: 'Optic capture command',
          entries: file.hars
        }
      };
      await _promises.default.writeFile(file.path, JSON.stringify(har));
    }
  }
  counts() {
    let total = 0;
    let unmatched = 0;
    const unmatchedPaths = [];
    const matchedPaths = [];
    let matched = 0;
    for (const [, node] of this.paths) {
      total++;
      if (node.hars.length === 0 && node.interactions.length === 0) {
        unmatched++;
        unmatchedPaths.push(node.endpoint);
      }
      if (node.hars.length !== 0 || node.interactions.length !== 0) {
        matched++;
        matchedPaths.push(node.endpoint);
      }
    }
    return {
      total,
      unmatched,
      matched,
      paths: {
        unmatched: unmatchedPaths,
        matched: matchedPaths
      }
    };
  }
  interactionCount() {
    const unmatched = this.unmatched.hars.length + this.unmatched.interactions.length;
    let matched = 0;
    for (const [, node] of this.paths) {
      matched += node.hars.length + node.interactions.length;
    }
    const total = matched + unmatched;
    return {
      total,
      unmatched,
      matched
    };
  }
  *getDocumentedEndpointInteractions() {
    for (const [, node] of this.paths) {
      if (node.hars.length || node.interactions.length) {
        yield {
          endpoint: node.endpoint,
          interactions: handleServerPathPrefix(filterIgnoredInteractions(this.getInteractionsIterator(node), this.spec), this.hostBaseMap)
        };
      }
    }
  }
  getUndocumentedInteractions() {
    return handleServerPathPrefix(filterIgnoredInteractions(this.getInteractionsIterator(this.unmatched), this.spec), this.hostBaseMap);
  }
  async *getInteractionsIterator(node) {
    for (const har of node.hars) {
      const interaction = _capturedInteractions.CapturedInteraction.fromHarEntry(har);
      if (interaction) yield interaction;
    }
    for (const interaction of node.interactions) {
      yield interaction;
    }
  }
}
exports.GroupedCaptures = GroupedCaptures;