"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OperationQueries = void 0;
exports.specToOperations = specToOperations;
exports.specToPaths = specToPaths;
var _tsResults = require("ts-results");
var _pathPatterns = require("../../../utils/pathPatterns");
class OperationQueries {
  constructor(operations) {
    this.operations = operations;
    this.patterns = [...new Set(this.operations.map(({
      pathPattern
    }) => pathPattern))];
  }
  findOperation(path, method) {
    const matchedPatternResult = this.matchPathPattern(path);
    if (matchedPatternResult.err) return matchedPatternResult;
    let maybeMatchedPattern = matchedPatternResult.unwrap();
    if (maybeMatchedPattern.none) return (0, _tsResults.Ok)(_tsResults.None);
    let matchedPattern = maybeMatchedPattern.unwrap();
    const operation = this.operations.find(op => matchedPattern.toLowerCase() === op.pathPattern.toLowerCase() && op.method.toLowerCase() == method.toLowerCase());
    if (!operation) return (0, _tsResults.Ok)(_tsResults.None);
    return (0, _tsResults.Ok)((0, _tsResults.Some)(operation));
  }
  findPathPattern(pathPattern) {
    const matchedPatternResult = this.matchPathPattern(pathPattern);
    if (matchedPatternResult.err) return matchedPatternResult;
    let maybeMatchedPattern = matchedPatternResult.unwrap();
    if (maybeMatchedPattern.none) return (0, _tsResults.Ok)(_tsResults.None);
    let matchedPattern = maybeMatchedPattern.unwrap();
    const operation = this.operations.find(op => op.pathPattern === matchedPattern);
    if (!operation) return (0, _tsResults.Ok)(_tsResults.None);
    return (0, _tsResults.Ok)((0, _tsResults.Some)(operation.pathPattern));
  }
  matchPathPattern(path) {
    let qualifiedPatterns = this.patterns.filter(pattern => (0, _pathPatterns.matchPathPattern)(pattern, path).match);
    if (qualifiedPatterns.length > 1) {
      const exactMatch = qualifiedPatterns.find(pattern => {
        const match = (0, _pathPatterns.matchPathPattern)(pattern, path);
        return match.match && match.exact;
      });
      if (exactMatch) {
        return (0, _tsResults.Ok)((0, _tsResults.Some)(exactMatch));
      } else {
        return (0, _tsResults.Ok)((0, _tsResults.Some)(qualifiedPatterns[0]));
      }
    } else if (qualifiedPatterns.length === 1) {
      let pattern = qualifiedPatterns[0];
      return (0, _tsResults.Ok)((0, _tsResults.Some)(pattern));
    } else {
      return (0, _tsResults.Ok)(_tsResults.None);
    }
  }
}
exports.OperationQueries = OperationQueries;
function specToOperations(spec) {
  return specToPaths(spec).flatMap(o => o.methods.map(m => ({
    method: m,
    pathPattern: o.pathPattern
  })));
}
function specToPaths(spec) {
  const operations = [];
  const allowedKeys = ['get', 'post', 'put', 'delete', 'patch', 'head', 'options'];
  Object.entries(spec.paths ?? {}).forEach(([pathPattern, methods]) => {
    if (methods) {
      operations.push({
        pathPattern,
        methods: Object.keys(methods).filter(key => allowedKeys.includes(key))
      });
    }
  });
  return operations;
}