"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SchemaInventory = void 0;
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _closeness = require("./closeness");
var _patchOperations = require("../../patch-operations");
var _operations = require("../../../../oas/operations");
class SchemaInventory {
  constructor(closeness = 0.8) {
    this.closeness = closeness;
  }
  schemaMap = new Map();
  addSchemas(rootJsonpath, schemas) {
    Object.entries(schemas).forEach(([name, schema]) => {
      // this might need to be memoized.
      if (schema) this.schemaMap.set(_jsonPointerHelpers.jsonPointerHelpers.append(rootJsonpath, name), (0, _closeness.walkSchema)(schema));
    });
  }
  findClosest(generatedSchema) {
    const thisSchema = (0, _closeness.walkSchema)(generatedSchema);
    let closestMatch;
    this.schemaMap.forEach((value, path) => {
      const closeness = (0, _closeness.computeClosenessFromKeyValueTuples)(thisSchema, value);
      // existing match
      if (closestMatch && closeness >= closestMatch.percent) {
        closestMatch = {
          ref: path,
          percent: closeness
        };
      }
      // no match
      if (closeness >= this.closeness) {
        closestMatch = {
          ref: path,
          percent: closeness
        };
      }
    });
    if (closestMatch && closestMatch.percent >= this.closeness) {
      return closestMatch;
    } else {
      return undefined;
    }
  }
  async *refsForAdditions(addedPaths, spec, meta = {}) {
    if (addedPaths.size === 0) return [];
    const sorted = Array.from(addedPaths).sort();
    let rootSchemasAdded = false;
    for await (let added of sorted) {
      const addedSchema = _jsonPointerHelpers.jsonPointerHelpers.get(spec, added);
      const arrayItems = arrayItemPaths(addedSchema, added);
      const isAPrimitiveSchema = addedSchema.type === 'string' || addedSchema.type === 'boolean' || addedSchema.type === 'number' || addedSchema.type === 'integer';
      const isARootSchema = _jsonPointerHelpers.jsonPointerHelpers.matches(added, ['paths', '**', '**', 'responses', '**', 'content', '**', 'schema']) ||
      // is a root request schema
      _jsonPointerHelpers.jsonPointerHelpers.matches(added, ['paths', '**', '**', 'requestBody', 'content', '**', 'schema']);
      let matchedRoot = false;
      let matchedSub = false;
      if (isARootSchema) {
        const match = this.findClosest(addedSchema);
        // use ref
        if (match) {
          meta.usedExistingRef = true;
          matchedRoot = true;
          const patch = {
            description: `use $ref ${match.ref}`,
            path: added,
            impact: [_patchOperations.PatchImpact.Refactor],
            diff: undefined,
            groupedOperations: [{
              op: 'replace',
              path: added,
              value: {
                $ref: `#${match.ref}`
              }
            }]
          };
          yield patch;
        }
      }
      if (!matchedRoot) {
        for await (let items of arrayItems) {
          const match = this.findClosest(_jsonPointerHelpers.jsonPointerHelpers.get(spec, items));
          if (match && match.percent > this.closeness) {
            meta.usedExistingRef = true;
            matchedSub = true;
            const patch = {
              description: `use $ref ${match.ref}`,
              path: items,
              impact: [_patchOperations.PatchImpact.Refactor],
              diff: undefined,
              groupedOperations: [{
                op: 'replace',
                path: items,
                value: {
                  $ref: `#${match.ref}`
                }
              }]
            };
            yield patch;
          }
        }
      }
      //create a root schema
      if (!matchedSub && !matchedRoot && isARootSchema && !isAPrimitiveSchema) {
        const refName = refNameGenerator(added);
        matchedRoot = true;
        let refPath = _jsonPointerHelpers.jsonPointerHelpers.compile(['components', 'schemas', refName]);

        // ensure randomness if we hit a conflict
        let counter = 1;
        while (this.schemaMap.has(refPath)) {
          refPath = _jsonPointerHelpers.jsonPointerHelpers.compile(['components', 'schemas', refName + '_' + String(counter)]);
          if (counter > 1000) {
            throw new Error('Could not determine a unique name');
          }
          counter++;
        }
        const schemaOps = [];
        if (!rootSchemasAdded) {
          if (!spec.components) {
            rootSchemasAdded = true;
            schemaOps.push({
              op: 'add',
              path: _jsonPointerHelpers.jsonPointerHelpers.compile(['components']),
              value: {
                schemas: {}
              }
            });
          } else if (!spec.components.schemas) {
            rootSchemasAdded = true;
            schemaOps.push({
              op: 'add',
              path: _jsonPointerHelpers.jsonPointerHelpers.compile(['components', 'schemas']),
              value: {}
            });
          }
        }
        const patch = {
          description: `create and use $ref for body`,
          path: added,
          impact: [_patchOperations.PatchImpact.Refactor],
          diff: undefined,
          groupedOperations: [...schemaOps, {
            op: 'add',
            path: refPath,
            value: addedSchema
          }, {
            op: 'replace',
            path: added,
            value: {
              $ref: `#${refPath}`
            }
          }]
        };
        yield patch;
      }
    }
  }
}
exports.SchemaInventory = SchemaInventory;
function arrayItemPaths(initialSchema, initialPath) {
  const results = [];
  function walk(schema, path, n) {
    if (n > 2) return;
    if (_openapiUtilities.OAS3.isArrayType(schema.type) && schema.items) {
      const itemsPath = _jsonPointerHelpers.jsonPointerHelpers.append(path, 'items');
      results.push(itemsPath);
      walk(schema.items, itemsPath, n + 1);
    }
    if (_openapiUtilities.OAS3.isObjectType(schema.type) && schema.properties) {
      Object.entries(schema.properties).forEach(([prop, propSchema]) => {
        walk(propSchema, _jsonPointerHelpers.jsonPointerHelpers.append(path, 'properties', prop), n + 1);
      });
    }
  }
  walk(initialSchema, initialPath, 0);
  return results;
}
function refNameGenerator(rootBodySchemaPath) {
  const [_, path, method, requestBodyOrResponses, ...other] = _jsonPointerHelpers.jsonPointerHelpers.decode(rootBodySchemaPath);
  const components = _operations.PathComponents.fromPath(path);
  const pathName = components.map(i => capitalizeFirstLetter(i.name.toLowerCase())).join('');
  if (requestBodyOrResponses === 'responses') {
    const statusCode = other[0];
    return `${capitalizeFirstLetter(method)}${pathName}${statusCode.toString()}ResponseBody`;
  } else if (requestBodyOrResponses === 'requestBody') {
    return `${capitalizeFirstLetter(method)}${pathName}RequestBody`;
  } else {
    return 'SharedComponent';
  }
}
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
}