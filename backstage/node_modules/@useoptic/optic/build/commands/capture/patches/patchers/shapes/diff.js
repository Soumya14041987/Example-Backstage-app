"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShapeDiffTraverser = exports.ShapeDiffResultKind = exports.SchemaCompilationError = exports.JsonSchemaKnownKeyword = void 0;
exports.diffBodyBySchema = diffBodyBySchema;
var _jsonSchemaTraverse = _interopRequireDefault(require("json-schema-traverse"));
var _2 = _interopRequireDefault(require("ajv/dist/2019"));
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _ono = require("@jsdevtools/ono");
var _tsResults = require("ts-results");
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _additionalProperties = require("./handlers/additionalProperties");
var _oneOf = require("./handlers/oneOf");
var _required = require("./handlers/required");
var _type = require("./handlers/type");
var _enum = require("./handlers/enum");
var _unevaluatedProperties = require("./handlers/unevaluatedProperties");
function diffBodyBySchema(body, schema, {
  specJsonPath,
  interaction
}) {
  let traverser = new ShapeDiffTraverser({
    specJsonPath,
    interaction
  });
  return traverser.traverse(body.value, schema).map(() => traverser.results());
}
function* diffVisitors(validationError, example, {
  specJsonPath,
  interaction,
  schema
}) {
  switch (validationError.keyword) {
    case JsonSchemaKnownKeyword.unevaluatedProperties:
      yield* (0, _unevaluatedProperties.unevaluatedPropertiesDiffs)(validationError, example, {
        specJsonPath,
        interaction,
        schema
      });
      break;
    case JsonSchemaKnownKeyword.additionalProperties:
      yield* (0, _additionalProperties.additionalPropertiesDiffs)(validationError, example);
      break;
    case JsonSchemaKnownKeyword.oneOf:
      yield* (0, _oneOf.oneOfKeywordDiffs)(validationError, example);
      break;
    case JsonSchemaKnownKeyword.required:
      yield* (0, _required.requiredKeywordDiffs)(validationError, example);
      break;
    case JsonSchemaKnownKeyword.type:
      yield* (0, _type.typeKeywordDiffs)(validationError, example);
      break;
    case JsonSchemaKnownKeyword.enum:
      yield* (0, _enum.enumKeywordDiffs)(validationError, example);
      break;
    default:
      const schemaPath = validationError.schemaPath.substring(1);
      yield {
        validationError,
        example: _jsonPointerHelpers.jsonPointerHelpers.get(example, validationError.instancePath),
        unpatchable: true,
        interaction,
        bodyPath: specJsonPath,
        schemaPath,
        path: _jsonPointerHelpers.jsonPointerHelpers.append(specJsonPath, 'schema', ..._jsonPointerHelpers.jsonPointerHelpers.decode(schemaPath))
      };
  }
}
let ShapeDiffResultKind = exports.ShapeDiffResultKind = /*#__PURE__*/function (ShapeDiffResultKind) {
  ShapeDiffResultKind["AdditionalProperty"] = "AdditionalProperty";
  ShapeDiffResultKind["MissingRequiredProperty"] = "MissingRequiredProperty";
  ShapeDiffResultKind["MissingEnumValue"] = "MissingEnumValue";
  ShapeDiffResultKind["UnmatchedType"] = "UnmatchedType";
  return ShapeDiffResultKind;
}({}); // The result of matching a body against it's (JSON) schema
class ShapeDiffTraverser {
  constructor({
    specJsonPath,
    interaction
  }) {
    this.validator = new _2.default({
      allErrors: true,
      validateFormats: false,
      strictSchema: false,
      strictTypes: false,
      useDefaults: true
    });
    this.specJsonPath = specJsonPath;
    this.interaction = interaction;
  }
  traverse(bodyValue, schema) {
    this.bodyValue = bodyValue;
    this.schema = schema;
    try {
      this.validate = this.validator.compile(prepareSchemaForDiff(schema));
    } catch (err) {
      // Catching and not throwing is okay here. `validator.compile` is stateless, with all state for the validator
      // being contained by the function that now doesn't get assigned.
      const wrapped = new SchemaCompilationError(err);
      return (0, _tsResults.Err)(wrapped);
    }
    this.validate(bodyValue);
    return _tsResults.Ok.EMPTY;
  }
  *results() {
    if (!this.validate || !this.validate.errors) return;
    // Sometimes the schema path returned from AJV is encoded
    let validationErrors = this.validate.errors.map(e => ({
      ...e,
      schemaPath: decodeURIComponent(e.schemaPath)
    }));
    let oneOfs = new Map();
    let oneOfBranchType = [];
    let oneOfBranchOther = [];
    for (let validationError of validationErrors) {
      if (validationError.keyword === JsonSchemaKnownKeyword.oneOf) {
        let schemaPath = validationError.schemaPath.substring(1); // valid json pointer
        oneOfs.set(schemaPath, validationError);
      } else if (validationError.schemaPath.indexOf('oneOf') > -1) {
        // probably has a oneof ancestor

        let schemaPath = _jsonPointerHelpers.jsonPointerHelpers.decode(validationError.schemaPath.substring(1));
        let oneOfPath = schemaPath.slice(0, schemaPath.lastIndexOf('oneOf') + 1);
        let branchPath = schemaPath.slice(oneOfPath.length);

        // TODO: consider hardening detection of one of branches. Going just off string keynames could
        // potentially be ugly, as we're dealing with partially user-definable input (property names).
        if (branchPath.length == 2 && branchPath[1] === JsonSchemaKnownKeyword.type || branchPath.length === 3 && branchPath[1] === 'items' && branchPath[2] === JsonSchemaKnownKeyword.type) {
          oneOfBranchType.push([_jsonPointerHelpers.jsonPointerHelpers.compile(oneOfPath), validationError]);
        } else if (branchPath.length >= 2) {
          oneOfBranchOther.push([_jsonPointerHelpers.jsonPointerHelpers.compile(oneOfPath), validationError]);
        }
      } else {
        // not related to one-of? visit right away
        yield* diffVisitors(validationError, this.bodyValue, {
          specJsonPath: this.specJsonPath,
          interaction: this.interaction,
          schema: this.schema
        });
      }
    }
    for (let [oneOfPath, otherBranchError] of oneOfBranchOther) {
      // any nested errors are all safe to visit
      yield* diffVisitors(otherBranchError, this.bodyValue, {
        specJsonPath: this.specJsonPath,
        interaction: this.interaction,
        schema: this.schema
      });

      // once a nested error has been visited, we consider this a branch type match
      oneOfs.delete(oneOfPath);
      oneOfBranchType = oneOfBranchType.filter(([branchOneOfPath, _]) => oneOfPath !== branchOneOfPath);
    }

    // visit any left over one ofs
    for (let oneOfError of oneOfs.values()) {
      yield* diffVisitors(oneOfError, this.bodyValue, {
        specJsonPath: this.specJsonPath,
        interaction: this.interaction,
        schema: this.schema
      });
    }
  }
}
exports.ShapeDiffTraverser = ShapeDiffTraverser;
let JsonSchemaKnownKeyword = exports.JsonSchemaKnownKeyword = /*#__PURE__*/function (JsonSchemaKnownKeyword) {
  JsonSchemaKnownKeyword["required"] = "required";
  JsonSchemaKnownKeyword["additionalProperties"] = "additionalProperties";
  JsonSchemaKnownKeyword["unevaluatedProperties"] = "unevaluatedProperties";
  JsonSchemaKnownKeyword["type"] = "type";
  JsonSchemaKnownKeyword["oneOf"] = "oneOf";
  JsonSchemaKnownKeyword["enum"] = "enum";
  return JsonSchemaKnownKeyword;
}({});
class SchemaCompilationError extends Error {
  constructor(ajvError) {
    super(`Error compiling schema: ${ajvError.message}`);
    _ono.Ono.extend(this, ajvError);
    Object.setPrototypeOf(this, SchemaCompilationError.prototype);
  }
}
exports.SchemaCompilationError = SchemaCompilationError;
function prepareSchemaForDiff(input) {
  const schema = JSON.parse(JSON.stringify(input));
  (0, _jsonSchemaTraverse.default)(schema, {
    allKeys: true,
    cb: (schema, jsonPtr) => {
      /*
        Some developers don't set all the JSON Schema properties because it's quite verbose,
        effectively underspecifing their schemas. Optic tries to apply sensible defaults,
        which are easy to override by writing your schemas properly
       */
      const parts = _jsonPointerHelpers.jsonPointerHelpers.decode(jsonPtr);
      if (_openapiUtilities.OAS3.isObjectType(schema.type) && !schema.hasOwnProperty('additionalProperties') && parts[parts.length - 2] !== 'allOf' // excludes direct children of allOF
      ) {
        schema['additionalProperties'] = false;
      }
      if (schema.allOf) {
        schema['unevaluatedProperties'] = false;
      }

      // Fix case where nullable is set and there is no type key
      if (!schema.type && schema.nullable) {
        if (schema.oneOf || schema.anyOf || schema.allOf) {
          if (schema.oneOf || schema.anyOf) {
            (schema.oneOf || schema.anyOf).push({
              type: 'object',
              nullable: true
            });
          } else {
            schema.allOf = schema.allOf.map(s => ({
              ...s,
              nullable: true
            }));
          }
          delete schema.nullable;
        } else {
          // We set this to string since we're not sure what the actual type is; this should be fine for us since we'll use this schema for diffing purposes and update
          schema.type = 'string';
        }
      }

      // Handle case where exclusiveMaximum or exclusiveMinimum is boolean (valid in 3.0)
      // Note that this will generate diffs that may produce patches that need to consider the case that there may be exclusive maximums
      if (typeof schema.exclusiveMaximum === 'boolean') {
        if (typeof schema.maximum === 'number') {
          schema.maximum = schema.maximum - 1;
        }
        delete schema.exclusiveMaximum;
      }
      if (typeof schema.exclusiveMinimum === 'boolean') {
        if (typeof schema.minumum === 'number') {
          schema.minumum = schema.minumum + 1;
        }
        delete schema.exclusiveMinimum;
      }
    }
  });
  return schema;
}