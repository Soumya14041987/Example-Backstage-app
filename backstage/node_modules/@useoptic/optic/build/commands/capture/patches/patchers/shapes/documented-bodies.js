"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocumentedBody = exports.DocumentedBodies = void 0;
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _tsResults = require("ts-results");
var _whatwgMimetype = _interopRequireDefault(require("whatwg-mimetype"));
var _operations = require("../../../../oas/operations");
var _body = require("../../../sources/body");
var _logger = require("../../../../../logger");
var _schema = require("./schema");
class DocumentedBody {
  static applyShapePatch(body, patch) {
    return {
      ...body,
      schema: _schema.Schema.applyShapePatch(body.schema || {}, patch)
    };
  }
}
exports.DocumentedBody = DocumentedBody;
class DocumentedBodies {
  static async *fromDocumentedInteraction({
    interaction,
    specJsonPath,
    operation
  }) {
    var _interaction$response, _interaction$response2;
    const capturedStatusCode = interaction.response ? parseInt(interaction.response.statusCode, 10) : null;
    if (interaction.request.body && (!capturedStatusCode || capturedStatusCode >= 200 && capturedStatusCode < 400)) {
      // TODO: consider whether this belongs here, and not in something more specific to patches
      // (as it decides basically what and what not to generate patches for  from)
      let capturedBody = interaction.request.body;
      let {
        contentType: capturedContentType
      } = capturedBody;
      let decodedBodyResult = await decodeCapturedBody(capturedBody);
      if (decodedBodyResult.err) {
        console.warn('Could not decode request body of captured interaction:', decodedBodyResult.val);
        _logger.logger.debug('Failing interaction: ' + JSON.stringify(interaction));
      } else if (capturedContentType) {
        let [, matchedContentType] = operation.requestBody && (0, _operations.findBody)(operation.requestBody, capturedContentType) || [null, null];
        if (!matchedContentType) return; // TODO: consider whether silently failing to produce a documented body is right

        let shapeLocation = {
          path: operation.pathPattern,
          method: operation.method,
          inRequest: {
            body: {
              contentType: matchedContentType
            }
          }
        };
        let bodyOperationPath = _jsonPointerHelpers.jsonPointerHelpers.compile(['requestBody', 'content', matchedContentType]);
        let bodySpecPath = _jsonPointerHelpers.jsonPointerHelpers.join(specJsonPath, bodyOperationPath);
        let expectedSchemaPath = _jsonPointerHelpers.jsonPointerHelpers.append(bodyOperationPath, 'schema');
        let resolvedSchema = _jsonPointerHelpers.jsonPointerHelpers.tryGet(operation, expectedSchemaPath);
        yield {
          schema: resolvedSchema.match ? resolvedSchema.value : null,
          body: decodedBodyResult.unwrap(),
          bodySource: capturedBody,
          shapeLocation,
          specJsonPath: bodySpecPath,
          interaction
        };
      } // TODO: consider what to do when there's no content type (happens, as seen in the past)
    } else if (interaction.request.body) {
      _logger.logger.debug(`skipping documenting request body for ${interaction.request.method} ${interaction.request.path} because response status code is ${capturedStatusCode ? capturedStatusCode : 'null'}`);
    }
    if ((_interaction$response = interaction.response) !== null && _interaction$response !== void 0 && _interaction$response.body && capturedStatusCode && capturedStatusCode >= 200 && capturedStatusCode < 500) {
      // TODO: consider whether this belongs here, and not in something more specific to patches
      // (as it decides basically what and what not to generate patches for  from)
      let capturedBody = interaction.response.body;
      let {
        contentType: capturedContentType
      } = capturedBody;
      let matchedResponse = (0, _operations.findResponse)(operation, interaction.response.statusCode);
      let decodedBodyResult = await decodeCapturedBody(capturedBody);
      if (decodedBodyResult.err) {
        console.warn('Could not decode response body of captured interaction:', decodedBodyResult.val);
        _logger.logger.debug('Failing interaction: ' + JSON.stringify(interaction));
      } else if (capturedContentType && matchedResponse) {
        let [response, statusCode] = matchedResponse;
        let [, matchedContentType] = (0, _operations.findBody)(response, capturedContentType) || [null, null];
        if (!matchedContentType) return; // TODO: consider whether silently failing to produce a documented body is right

        let shapeLocation = {
          path: operation.pathPattern,
          method: operation.method,
          inResponse: {
            body: {
              contentType: matchedContentType
            },
            statusCode
          }
        };
        let bodyOperationPath = _jsonPointerHelpers.jsonPointerHelpers.compile(['responses', statusCode, 'content', matchedContentType]);
        let bodySpecPath = _jsonPointerHelpers.jsonPointerHelpers.join(specJsonPath, bodyOperationPath);
        let expectedSchemaPath = _jsonPointerHelpers.jsonPointerHelpers.append(bodyOperationPath, 'schema');
        let resolvedSchema = _jsonPointerHelpers.jsonPointerHelpers.tryGet(operation, expectedSchemaPath);
        yield {
          schema: resolvedSchema.match ? resolvedSchema.value : null,
          body: decodedBodyResult.unwrap(),
          bodySource: capturedBody,
          shapeLocation,
          specJsonPath: bodySpecPath,
          interaction
        };
      } else {
        _logger.logger.debug(`skipping documenting response body for ${interaction.request.method} ${interaction.request.path} because there is no content type`);
      }
    } else if ((_interaction$response2 = interaction.response) !== null && _interaction$response2 !== void 0 && _interaction$response2.body) {
      _logger.logger.debug(`skipping documenting response body for ${interaction.request.method} ${interaction.request.path} because response status code is ${capturedStatusCode ? capturedStatusCode : 'null'}`);
    }
  }
}
exports.DocumentedBodies = DocumentedBodies;
async function decodeCapturedBody(capturedBody) {
  // parse the interaction bytes
  let {
    contentType
  } = capturedBody;
  let parsedType = contentType && _whatwgMimetype.default.parse(contentType);
  if (!contentType || !parsedType) return (0, _tsResults.Ok)(_tsResults.None); // for now, we'll only attempt decoding when we know a content type
  if (parsedType.essence === 'application/json' ||
  // IETF RFC 4627
  parsedType.essence === 'text/json' ||
  // valid JSON type according to WHATWG-mimesniff  https://mimesniff.spec.whatwg.org/#mime-type-groups
  parsedType.subtype.endsWith('+json') // IETF RFC 6839
  ) {
    let value;
    try {
      value = await _body.CapturedBody.json(capturedBody);
    } catch (err) {
      _logger.logger.error;
      return (0, _tsResults.Err)(`Could not parse captured body as json. Tried to parse ${capturedBody.body} as JSON`);
    }
    return (0, _tsResults.Ok)((0, _tsResults.Some)({
      contentType,
      value
    }));
  } else if (parsedType.essence === 'multipart/form-data') {
    return (0, _tsResults.Ok)((0, _tsResults.Some)({
      contentType,
      value: capturedBody.body ? parseMultipartFormBody(capturedBody.contentType, capturedBody.body) : {}
    }));
  } else if (parsedType.essence === 'application/x-www-form-urlencoded') {
    const searchParams = new URLSearchParams(capturedBody.body ?? '');
    const parsed = {};
    for (const [key, v] of searchParams) parsed[key] = v;
    return (0, _tsResults.Ok)((0, _tsResults.Some)({
      contentType,
      value: parsed
    }));
  } else {
    return (0, _tsResults.Ok)((0, _tsResults.Some)({
      contentType,
      value: capturedBody.body
    }));
  }
}
function parseMultipartFormBody(contentType, body) {
  // Expected contentType to be format of
  // multipart/form-data; boundary=---------------------------123456789
  const boundary = contentType.split(';')[1].split('=')[1].trim();

  // the boundary could be padded with `-`
  const chunks = body.split(new RegExp(`-*${boundary}-*[\\r\\n]+`)).slice(1); // remove the header part of the body
  const parsed = {};
  for (let chunk of chunks) {
    var _disposition$split$fi;
    const disposition = chunk.split(/[\r\n]+/).find(l => /^Content-Disposition/i.test(l));
    // Example line:
    // Content-Disposition: form-data; name="file"; filename="upload.txt"
    const nameMatch = disposition === null || disposition === void 0 || (_disposition$split$fi = disposition.split(';').filter(l => /name=".+"/.test(l))[0]) === null || _disposition$split$fi === void 0 ? void 0 : _disposition$split$fi.match(/name="(.+)"/);
    if (!nameMatch || !nameMatch[1]) continue;
    const name = nameMatch[1];
    // Remove header rows to get the raw content and the trailing line breaks
    chunk = chunk.replace(/^Content-Disposition.+[\r\n]+/i, '').replace(/^Content-Type.+[\r\n]+/i, '') // Content-type is only set for files (i.e. has `filename="..."`)
    .replace(/[\r\n]+$/, '');
    parsed[name] = chunk;
  }
  return parsed;
}