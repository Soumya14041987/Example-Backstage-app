"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.additionalPropertiesDiffs = additionalPropertiesDiffs;
exports.additionalPropertiesPatches = additionalPropertiesPatches;
var _schema = require("../schema");
var _diff = require("../diff");
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _patches = require("../../spec/patches");
function* additionalPropertiesDiffs(validationError, example) {
  if (validationError.keyword !== _diff.JsonSchemaKnownKeyword.additionalProperties) return;
  const key = validationError.params.additionalProperty;
  const propertyExamplePath = _jsonPointerHelpers.jsonPointerHelpers.append(validationError.instancePath, key);
  const parentObjectPath = (() => {
    const parentObjectPath = _jsonPointerHelpers.jsonPointerHelpers.decode(validationError.schemaPath.substring(1));
    if (parentObjectPath[parentObjectPath.length - 1] === 'additionalProperties') {
      parentObjectPath.pop();
      return _jsonPointerHelpers.jsonPointerHelpers.compile([...parentObjectPath, 'properties']);
    }
    return _jsonPointerHelpers.jsonPointerHelpers.compile(parentObjectPath);
  })();
  const propertyPath = _jsonPointerHelpers.jsonPointerHelpers.append(parentObjectPath, key);
  const instancePath = _jsonPointerHelpers.jsonPointerHelpers.append(validationError.instancePath, key);
  yield {
    description: `'${key}' is not documented`,
    kind: _diff.ShapeDiffResultKind.AdditionalProperty,
    keyword: _diff.JsonSchemaKnownKeyword.additionalProperties,
    example: _jsonPointerHelpers.jsonPointerHelpers.get(example, instancePath),
    propertyPath,
    instancePath,
    parentObjectPath,
    propertyExamplePath,
    key
  };
}
function* additionalPropertiesPatches(diff, schema, interaction, shapeContext, openAPIVersion) {
  if (diff.kind !== _diff.ShapeDiffResultKind.AdditionalProperty) return;
  const parentPath = _jsonPointerHelpers.jsonPointerHelpers.pop(diff.parentObjectPath);
  const parentOption = _jsonPointerHelpers.jsonPointerHelpers.tryGet(schema, parentPath);
  if (!parentOption.match) return;
  const parent = parentOption.value;
  const propertiesPath = _jsonPointerHelpers.jsonPointerHelpers.append(parentPath, 'properties');
  const requiredPath = _jsonPointerHelpers.jsonPointerHelpers.append(parentPath, 'required');
  const newPropertyPath = _jsonPointerHelpers.jsonPointerHelpers.append(parentPath, 'properties', diff.key);

  // if properties is not set, create one with empty {}
  let groupedOperations = [];
  if (!parent.properties) {
    groupedOperations.push({
      op: 'add',
      path: propertiesPath,
      value: {}
    });
  }
  // if required is not set, create one with property in it
  if (!parent.required) {
    groupedOperations.push({
      op: 'add',
      path: requiredPath,
      value: [diff.key],
      // @ts-ignore
      extra: 'same'
    });
  } else if (!parent.required.includes(diff.key)) {
    groupedOperations.push({
      op: 'add',
      path: requiredPath + '/-',
      // append
      value: diff.key
    });
  }

  // ok now we're ready for the property
  if (!(parent.properties || {}).hasOwnProperty(diff.key)) {
    groupedOperations.push({
      op: 'add',
      path: newPropertyPath,
      value: _schema.Schema.baseFromValue(diff.example, openAPIVersion)
    });
  }
  if (groupedOperations.length < 1) return;
  yield {
    description: `add property ${diff.key}`,
    diff,
    impact: [_patches.PatchImpact.Addition, !shapeContext.location ? _patches.PatchImpact.BackwardsCompatibilityUnknown : 'inResponse' in shapeContext.location ? _patches.PatchImpact.BackwardsCompatible : _patches.PatchImpact.BackwardsIncompatible],
    groupedOperations,
    shouldRegeneratePatches: false,
    interaction
  };
}