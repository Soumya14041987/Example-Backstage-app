"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enumKeywordDiffs = enumKeywordDiffs;
exports.enumPatches = enumPatches;
var _diff = require("../diff");
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _patchOperations = require("../../../patch-operations");
function* enumKeywordDiffs(validationError, example) {
  if (validationError.keyword !== _diff.JsonSchemaKnownKeyword.enum) return;
  const propertyPath = validationError.schemaPath.substring(1);
  const parts = _jsonPointerHelpers.jsonPointerHelpers.decode(propertyPath);
  const key = parts[parts.length - 2];
  const unmatchedEnumValue = _jsonPointerHelpers.jsonPointerHelpers.get(example, validationError.instancePath);
  yield {
    description: `'${key}' does not have enum value ${unmatchedEnumValue}`,
    kind: _diff.ShapeDiffResultKind.MissingEnumValue,
    keyword: _diff.JsonSchemaKnownKeyword.enum,
    value: unmatchedEnumValue,
    example,
    propertyPath,
    instancePath: validationError.instancePath,
    key
  };
}
function* enumPatches(diff, schema, interaction) {
  if (diff.kind !== _diff.ShapeDiffResultKind.MissingEnumValue || diff.keyword !== _diff.JsonSchemaKnownKeyword.enum) return;
  let groupedOperations = [];
  groupedOperations.push({
    op: 'add',
    path: _jsonPointerHelpers.jsonPointerHelpers.append(diff.propertyPath, '-'),
    // "-" indicates append to array
    value: diff.value
  });
  // If the enum is inside of an array, we could have multiple instances of enum - this updates the enum and reruns diffs
  const shouldRegeneratePatches = _jsonPointerHelpers.jsonPointerHelpers.decode(diff.propertyPath).includes('items');
  yield {
    description: `add enum ${diff.value} to ${diff.key} `,
    diff,
    impact: [_patchOperations.PatchImpact.Addition],
    groupedOperations,
    shouldRegeneratePatches,
    interaction
  };
}