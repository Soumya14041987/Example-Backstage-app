"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.oneOfKeywordDiffs = oneOfKeywordDiffs;
exports.oneOfPatches = oneOfPatches;
var _schema = require("../schema");
var _diff = require("../diff");
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _patchOperations = require("../../../patch-operations");
function* oneOfKeywordDiffs(validationError, example) {
  if (validationError.keyword !== _diff.JsonSchemaKnownKeyword.oneOf) return;
  if (validationError.params.passingSchemas && validationError.params.passingSchemas.length > 0) return; // no diffs or patches for multiple matches yet
  const typeKeywordPath = _jsonPointerHelpers.jsonPointerHelpers.decode(validationError.schemaPath.substring(1));
  const oneOfIndex = typeKeywordPath.lastIndexOf('oneOf');
  const propertyPath = _jsonPointerHelpers.jsonPointerHelpers.compile(typeKeywordPath.slice(0, oneOfIndex + 1));
  const keyName = _jsonPointerHelpers.jsonPointerHelpers.decode(propertyPath).pop() || '';
  const unmatchedValue = _jsonPointerHelpers.jsonPointerHelpers.get(example, validationError.instancePath);
  yield {
    description: `'${keyName}' did not match schema`,
    expectedType: 'oneOf schema',
    kind: _diff.ShapeDiffResultKind.UnmatchedType,
    keyword: _diff.JsonSchemaKnownKeyword.oneOf,
    instancePath: validationError.instancePath,
    propertyPath: propertyPath,
    key: keyName,
    example: unmatchedValue
  };
}
function* oneOfPatches(diff, schema, interaction, shapeContext, openAPIVersion) {
  if (diff.kind !== _diff.ShapeDiffResultKind.UnmatchedType || diff.keyword !== _diff.JsonSchemaKnownKeyword.oneOf ||
  // @ts-ignore
  diff.keyword === _diff.JsonSchemaKnownKeyword.type && diff.example === null) return;
  let groupedOperations = [];
  groupedOperations.push({
    op: 'add',
    path: _jsonPointerHelpers.jsonPointerHelpers.append(diff.propertyPath, '-'),
    // "-" indicates append to array
    value: _schema.Schema.baseFromValue(diff.example, openAPIVersion)
  });

  // TODO: possibly clean up the newly generated schema, or perhaps try to not make that necessary

  yield {
    description: `expand one of for ${diff.key}`,
    diff,
    impact: [_patchOperations.PatchImpact.Addition, !shapeContext.location ? _patchOperations.PatchImpact.BackwardsCompatibilityUnknown : 'inRequest' in shapeContext.location ? _patchOperations.PatchImpact.BackwardsCompatible : _patchOperations.PatchImpact.BackwardsIncompatible],
    groupedOperations,
    shouldRegeneratePatches: false,
    interaction
  };
}