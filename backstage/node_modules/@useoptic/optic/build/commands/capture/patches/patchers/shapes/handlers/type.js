"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeKeywordDiffs = typeKeywordDiffs;
exports.typePatches = typePatches;
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _diff = require("../diff");
var _schema = require("../schema");
var _patches = require("../../spec/patches");
function* typeKeywordDiffs(validationError, example) {
  if (validationError.keyword !== _diff.JsonSchemaKnownKeyword.type) return;
  const typeKeywordPath = _jsonPointerHelpers.jsonPointerHelpers.decode(validationError.schemaPath.substring(1));
  const propertyPath = _jsonPointerHelpers.jsonPointerHelpers.pop(_jsonPointerHelpers.jsonPointerHelpers.compile(typeKeywordPath));
  const keyName = _jsonPointerHelpers.jsonPointerHelpers.decode(propertyPath).pop() || '';
  const unmatchedValue = _jsonPointerHelpers.jsonPointerHelpers.get(example, validationError.instancePath);
  yield {
    description: `'${keyName}' did not match schema`,
    expectedType: `${validationError.params.type}`,
    kind: _diff.ShapeDiffResultKind.UnmatchedType,
    keyword: _diff.JsonSchemaKnownKeyword.type,
    instancePath: validationError.instancePath,
    propertyPath: propertyPath,
    key: keyName,
    example: unmatchedValue
  };
}
function* typePatches(diff, schema, interaction, shapeContext, openAPIVersion) {
  if (diff.kind !== _diff.ShapeDiffResultKind.UnmatchedType || diff.keyword !== _diff.JsonSchemaKnownKeyword.type) return;
  const currentPropertySchema = _jsonPointerHelpers.jsonPointerHelpers.get(schema, diff.propertyPath);
  const alreadyOneOf = Array.isArray(currentPropertySchema.oneOf);
  function makeOneOfOperations() {
    const groupedOperations = [];
    if (alreadyOneOf) {
      let baseSchema = _schema.Schema.baseFromValue(diff.example, openAPIVersion);
      if (!currentPropertySchema.oneOf.find(branchSchema => _schema.Schema.equals(baseSchema, branchSchema))) {
        groupedOperations.push({
          op: 'add',
          path: _jsonPointerHelpers.jsonPointerHelpers.append(diff.propertyPath, 'oneOf', '-'),
          // "-" indicates append to array
          value: baseSchema
        });
      }
    } else {
      let mergeOperations = [..._schema.Schema.mergeOperations(_schema.Schema.clone(currentPropertySchema), {
        oneOf: [_schema.Schema.clone(currentPropertySchema), _schema.Schema.baseFromValue(diff.example, openAPIVersion)]
      })];
      groupedOperations.push(...mergeOperations.map(op => ({
        ...op,
        path: _jsonPointerHelpers.jsonPointerHelpers.join(diff.propertyPath, op.path)
      })));
    }
    return groupedOperations;
  }
  function changeTypeOperations() {
    return [{
      op: 'replace',
      path: _jsonPointerHelpers.jsonPointerHelpers.append(diff.propertyPath),
      // handles removal of keys that are no longer allowed
      value: _schema.Schema.merge(currentPropertySchema, _schema.Schema.baseFromValue(diff.example, openAPIVersion))
    }];
  }
  if (openAPIVersion === '3.0.x') {
    if (diff.example === null) {
      yield {
        description: `make ${diff.key} null`,
        diff,
        impact: [_patches.PatchImpact.Addition, !shapeContext.location ? _patches.PatchImpact.BackwardsCompatibilityUnknown : 'inRequest' in shapeContext.location ? _patches.PatchImpact.BackwardsCompatible : _patches.PatchImpact.BackwardsIncompatible],
        groupedOperations: [{
          op: 'replace',
          path: _jsonPointerHelpers.jsonPointerHelpers.append(diff.propertyPath, 'nullable'),
          // handles removal of keys that are no longer allowed
          value: true
        }],
        shouldRegeneratePatches: false,
        interaction
      };
    } else {
      // option one: convert to a one-off
      yield {
        description: `make ${diff.key} oneOf`,
        diff,
        impact: [_patches.PatchImpact.Addition, !shapeContext.location ? _patches.PatchImpact.BackwardsCompatibilityUnknown : 'inRequest' in shapeContext.location ? _patches.PatchImpact.BackwardsCompatible : _patches.PatchImpact.BackwardsIncompatible],
        groupedOperations: makeOneOfOperations(),
        shouldRegeneratePatches: true,
        interaction
      };

      // option two: change the type
      yield {
        diff,
        description: `change type of ${diff.key}`,
        impact: [_patches.PatchImpact.BackwardsIncompatible],
        groupedOperations: changeTypeOperations(),
        shouldRegeneratePatches: false,
        interaction
      };
    }
  } else if (openAPIVersion === '3.1.x') {
    if (diff.example === null) {
      const subschema = _jsonPointerHelpers.jsonPointerHelpers.get(schema, diff.propertyPath);
      const schemaType = Array.isArray(subschema.type) ? [...subschema.type, 'null'] : subschema.type ? [subschema.type, 'null'] : ['null'];
      yield {
        description: `make ${diff.key} null`,
        diff,
        impact: [_patches.PatchImpact.Addition, !shapeContext.location ? _patches.PatchImpact.BackwardsCompatibilityUnknown : 'inRequest' in shapeContext.location ? _patches.PatchImpact.BackwardsCompatible : _patches.PatchImpact.BackwardsIncompatible],
        groupedOperations: [{
          op: 'replace',
          path: _jsonPointerHelpers.jsonPointerHelpers.append(diff.propertyPath, 'type'),
          // handles removal of keys that are no longer allowed
          value: schemaType
        }],
        shouldRegeneratePatches: true,
        interaction
      };
    } else {
      yield {
        description: `make ${diff.key} oneOf`,
        diff,
        impact: [_patches.PatchImpact.Addition, !shapeContext.location ? _patches.PatchImpact.BackwardsCompatibilityUnknown : 'inRequest' in shapeContext.location ? _patches.PatchImpact.BackwardsCompatible : _patches.PatchImpact.BackwardsIncompatible],
        groupedOperations: makeOneOfOperations(),
        shouldRegeneratePatches: true,
        interaction
      };

      // option two: change the type
      yield {
        diff,
        description: `change type of ${diff.key}`,
        impact: [_patches.PatchImpact.BackwardsIncompatible],
        groupedOperations: changeTypeOperations(),
        shouldRegeneratePatches: false,
        interaction
      };
    }
  }
}