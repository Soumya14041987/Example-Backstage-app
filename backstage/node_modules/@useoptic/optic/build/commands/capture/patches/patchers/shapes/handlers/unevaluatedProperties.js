"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unevaluatedPropertiesDiffs = unevaluatedPropertiesDiffs;
var _diff = require("../diff");
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _openapiUtilities = require("@useoptic/openapi-utilities");
function* unevaluatedPropertiesDiffs(validationError, example, {
  specJsonPath,
  interaction,
  schema
}) {
  if (validationError.keyword !== _diff.JsonSchemaKnownKeyword.unevaluatedProperties) return;
  const key = validationError.params.unevaluatedProperty;
  const instancePath = _jsonPointerHelpers.jsonPointerHelpers.append(validationError.instancePath, key);
  const propertyExamplePath = _jsonPointerHelpers.jsonPointerHelpers.append(validationError.instancePath, key);
  const parts = _jsonPointerHelpers.jsonPointerHelpers.decode(validationError.schemaPath.substring(1));
  parts.pop();
  const baseSchemaPath = _jsonPointerHelpers.jsonPointerHelpers.compile(parts);
  const baseSchema = _jsonPointerHelpers.jsonPointerHelpers.tryGet(schema, baseSchemaPath);
  let pathToAllofVariant = null;
  if (baseSchema.match && baseSchema.value.allOf) {
    const allOfVariants = baseSchema.value.allOf;
    // TODO in the future we can use a more complicated heuristic to choose which allOf variant is most relevant
    const allOfIdx = allOfVariants.findIndex(schema => _openapiUtilities.OAS3.isObjectType(schema.type));
    if (allOfIdx > -1) {
      pathToAllofVariant = _jsonPointerHelpers.jsonPointerHelpers.compile(['allOf', String(allOfIdx), 'properties']);
    }
  }
  if (!pathToAllofVariant) {
    // This could happen if the allOf variant has a primitive type - in this case we surface that this is unpatchable and let the user resolve this
    // Or if a user sets unevalutedProperties to their schema, we don't know how to handle if unless there's an allOf
    const schemaPath = validationError.schemaPath.substring(1);
    yield {
      validationError,
      example: _jsonPointerHelpers.jsonPointerHelpers.get(example, validationError.instancePath),
      unpatchable: true,
      interaction,
      bodyPath: specJsonPath,
      schemaPath,
      path: _jsonPointerHelpers.jsonPointerHelpers.append(specJsonPath, 'schema', ..._jsonPointerHelpers.jsonPointerHelpers.decode(schemaPath))
    };
    return;
  }
  const parentObjectPath = _jsonPointerHelpers.jsonPointerHelpers.join(baseSchemaPath, pathToAllofVariant);
  const propertyPath = _jsonPointerHelpers.jsonPointerHelpers.append(parentObjectPath, key);
  yield {
    description: `'${key}' is not documented`,
    kind: _diff.ShapeDiffResultKind.AdditionalProperty,
    keyword: _diff.JsonSchemaKnownKeyword.additionalProperties,
    example: _jsonPointerHelpers.jsonPointerHelpers.get(example, instancePath),
    propertyPath,
    instancePath,
    parentObjectPath,
    propertyExamplePath,
    key
  };
}