"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShapePatches = exports.ShapePatch = void 0;
exports.generateShapePatchesByDiff = generateShapePatchesByDiff;
var _diff = require("./diff");
var _oneOf = require("./handlers/oneOf");
var _required = require("./handlers/required");
var _patchOperations = require("../../patch-operations");
var _logger = require("../../../../../logger");
var _sentry = require("../../../../../sentry");
var _newSchema = require("./handlers/newSchema");
var _enum = require("./handlers/enum");
var _type = require("./handlers/type");
var _additionalProperties = require("./handlers/additionalProperties");
var _schema = require("./schema");
function* generateShapePatchesByDiff(diff, schema, interaction, shapeContext, openAPIVersion) {
  for (let generator of [_oneOf.oneOfPatches, _required.requiredPatches, _enum.enumPatches, _type.typePatches, _additionalProperties.additionalPropertiesPatches]) {
    yield* generator(diff, schema, interaction, shapeContext, openAPIVersion);
  }
}
class ShapePatch {
  static *operations(patch) {
    for (let op of patch.groupedOperations) {
      yield op;
    }
  }
  static isAddition(patch) {
    return patch.impact.includes(_patchOperations.PatchImpact.Addition);
  }
}
exports.ShapePatch = ShapePatch;
const MAX_ITERATIONS = 100;
class ShapePatches {
  static *generateBodyAdditions(documentedBody, openAPIVersion) {
    let {
      body: optionalBody,
      schema,
      shapeLocation,
      specJsonPath
    } = documentedBody;
    if (optionalBody.none) return; // no patches if there is no body
    let body = optionalBody.unwrap();
    let patchesExhausted = false;
    let i = 0;
    while (!patchesExhausted) {
      i++;
      if (!schema || !schema.type && !_schema.Schema.isPolymorphic(schema)) {
        let newSchema = _schema.Schema.baseFromValue(body.value, openAPIVersion);
        let patch = (0, _newSchema.newSchemaPatch)(newSchema, schema || null, documentedBody.interaction, {
          location: shapeLocation || undefined
        });
        yield patch;
        schema = _schema.Schema.applyShapePatch(schema, patch);
      }
      let shapeDiffsOpt = (0, _diff.diffBodyBySchema)(body, schema, {
        specJsonPath,
        interaction: documentedBody.interaction
      });
      if (shapeDiffsOpt.err) {
        _logger.logger.error(`Could not update body at ${specJsonPath}`);
        _logger.logger.error(shapeDiffsOpt.val);
        _sentry.SentryClient.captureException(shapeDiffsOpt.val);
        break;
      }
      let shapeDiffs = shapeDiffsOpt.val;
      let patchCount = 0;
      let shouldRegenerate = false;
      for (let shapeDiff of shapeDiffs) {
        if ('unpatchable' in shapeDiff) continue;
        let diffPatches = generateShapePatchesByDiff(shapeDiff, schema, documentedBody.interaction, {
          location: shapeLocation || undefined
        }, openAPIVersion);
        for (let patch of diffPatches) {
          if (!ShapePatch.isAddition(patch)) continue;
          patchCount++;
          schema = _schema.Schema.applyShapePatch(schema, patch);
          yield patch;
          // If the patch changes the structure of the schema (e.g. removes / replaces with oneOf), we need to regenerate the patches because the target json path could have moved
          if (patch.shouldRegeneratePatches) shouldRegenerate = true;
        }
        if (shouldRegenerate) break;
      }
      patchesExhausted = patchCount === 0;
      if (patchesExhausted || i === MAX_ITERATIONS) {
        // diff the final schema + emit the results
        let shapeDiffsOpt = (0, _diff.diffBodyBySchema)(body, schema, {
          specJsonPath,
          interaction: documentedBody.interaction
        });
        if (!shapeDiffsOpt.err) {
          // TODO collect and dedupe by keyword + schema path
          for (const diff of shapeDiffsOpt.val) {
            if ('unpatchable' in diff) {
              yield diff;
            }
          }
        }
        if (i === MAX_ITERATIONS) {
          _sentry.SentryClient.captureException(new Error('max iterations in shape patches hit'), {
            extra: {
              body,
              schema
            }
          });
        }
        break;
      }
    }
  }
}
exports.ShapePatches = ShapePatches;