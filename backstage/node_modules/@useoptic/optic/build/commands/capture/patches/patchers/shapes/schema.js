"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isExtension = exports.allowedMetaDataForAll = exports.allowedKeysForString = exports.allowedKeysForOneOf = exports.allowedKeysForObject = exports.allowedKeysForInteger = exports.allowedKeysForArray = exports.Schema = void 0;
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _fastJsonPatch = _interopRequireDefault(require("fast-json-patch"));
var _sentry = require("../../../../../sentry");
var _logger = require("../../../../../logger");
class Schema {
  static baseFromValue(value, openAPIVersion) {
    const rootSchema = initialSchema(value, openAPIVersion);
    let schema = rootSchema;
    return schema;
  }
  static clone(value) {
    return _fastJsonPatch.default.deepClone(value);
  }
  static equals(a, b) {
    return !!Schema.mergeOperations(a, b).next().done;
  }
  static merge(currentSchema, newSchema) {
    const merged = {
      ...currentSchema,
      ...newSchema
    };
    let allowedKeys = [...allowedMetaDataForAll, 'type'];
    if (newSchema.type === 'object') allowedKeys = allowedKeysForObject;
    if (newSchema.type === 'array') allowedKeys = allowedKeysForArray;
    if (newSchema.type === 'string') allowedKeys = allowedKeysForString;
    if (newSchema.type === 'number' || newSchema.type === 'integer') allowedKeys = allowedKeysForInteger;
    if (newSchema.oneOf) allowedKeys = allowedKeysForOneOf;
    for (let key in merged) {
      if (!allowedKeys.includes(key) || isExtension(key)) {
        delete merged[key];
      }
    }
    return merged;
  }
  static *mergeOperations(currentSchema, newSchema) {
    if (currentSchema === null) {
      yield {
        op: 'add',
        path: '',
        value: {}
      };
      currentSchema = {};
    }
    const merged = {
      ...currentSchema,
      ...newSchema
    };
    const currentKeys = new Set(Object.keys(currentSchema));
    let allowedKeys = [...allowedMetaDataForAll, 'type'];
    if (newSchema.type === 'object') allowedKeys = allowedKeysForObject;
    if (newSchema.type === 'array') allowedKeys = allowedKeysForArray;
    if (newSchema.type === 'string') allowedKeys = allowedKeysForString;
    if (newSchema.type === 'number' || newSchema.type === 'integer') allowedKeys = allowedKeysForInteger;
    if (newSchema.oneOf) allowedKeys = allowedKeysForOneOf;
    for (let [key, value] of Object.entries(merged)) {
      let path = _jsonPointerHelpers.jsonPointerHelpers.append('', key);
      if (!allowedKeys.includes(key) || isExtension(key)) {
        yield {
          op: 'remove',
          path
        };
      } else if (!currentKeys.has(key)) {
        yield {
          op: 'add',
          path,
          value
        };
      } else if (value !== currentSchema[key]) {
        yield {
          op: 'replace',
          path,
          value
        };
      }
    }
  }
  static applyShapePatch(schema, patch) {
    const operations = _fastJsonPatch.default.deepClone(patch.groupedOperations.flatMap(operation => operation));
    try {
      const result = _fastJsonPatch.default.applyPatch(schema, operations, undefined, false // don't mutate the original schema
      );
      return result.newDocument;
    } catch (e) {
      _logger.logger.debug({
        location: 'schema',
        error: e,
        operations: JSON.stringify(operations),
        parsed: JSON.stringify(schema)
      });
      _sentry.SentryClient.captureException(e, {
        extra: {
          operations,
          schema
        }
      });
      throw e;
    }
  }
  static isPolymorphic(schema) {
    return !!(schema.allOf || schema.anyOf || schema.oneOf);
  }
}
exports.Schema = Schema;
function initialSchema(rootInput, openAPIVersion) {
  if (rootInput === null) {
    if (openAPIVersion === '3.0.x') return {
      nullable: true
    };
    // @ts-ignore we need to retype this as a union of 3 & 3.1
    return {
      type: 'null'
    };
  } else if (Array.isArray(rootInput)) {
    return {
      type: 'array',
      items: rootInput.length ? initialSchema(rootInput[0], openAPIVersion) : {}
    };
  } else if (typeof rootInput === 'object') {
    return {
      type: 'object'
    };
  } else if (typeof rootInput === 'string') {
    return {
      type: 'string'
    };
  } else if (typeof rootInput === 'number') {
    return {
      type: 'number'
    };
  } else if (typeof rootInput === 'boolean') {
    return {
      type: 'boolean'
    };
  } else {
    throw new Error('Could not learn JSON Schema');
  }
}
const allowedMetaDataForAll = exports.allowedMetaDataForAll = ['title', 'description', 'example', 'examples', 'default', 'deprecated', 'externalDocs'];
const allowedKeysForOneOf = exports.allowedKeysForOneOf = [...allowedMetaDataForAll, 'oneOf', 'allOf', 'not', 'discriminator'];
const allowedKeysForObject = exports.allowedKeysForObject = [...allowedMetaDataForAll, 'nullable', 'additionalProperties', 'type', 'maxProperties', 'minProperties', 'required', 'properties'];
const allowedKeysForArray = exports.allowedKeysForArray = [...allowedMetaDataForAll, 'nullable', 'type', 'items', 'maxItems', 'minItems', 'uniqueItems'];
const allowedKeysForString = exports.allowedKeysForString = [...allowedMetaDataForAll, 'nullable', 'type', 'format', 'pattern', 'maxLength', 'minLength'];
const allowedKeysForInteger = exports.allowedKeysForInteger = [...allowedMetaDataForAll, 'nullable', 'type', 'minimum', 'maximum', 'multipleOf'];
const isExtension = key => key.startsWith('x-');
exports.isExtension = isExtension;