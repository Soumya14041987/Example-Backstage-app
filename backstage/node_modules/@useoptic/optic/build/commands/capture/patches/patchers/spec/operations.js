"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateOperationPatches = generateOperationPatches;
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _operations = require("../../../../oas/operations");
var _patches = require("./patches");
var _types = require("./types");
function* generateOperationPatches(documentedInteraction) {
  yield* generateRequestPatches(documentedInteraction);
  yield* generateResponsePatches(documentedInteraction);
}
function* generateRequestPatches(documentedInteraction) {
  var _interaction$response, _operation$requestBod;
  const {
    operation,
    interaction
  } = documentedInteraction;
  // Skip interactions for request body when the status code is not 2xx - i.e. the captured interaction didn't result in a valid response
  const statusCode = (_interaction$response = interaction.response) !== null && _interaction$response !== void 0 && _interaction$response.statusCode ? Number(interaction.response.statusCode) : null;
  if (!statusCode || !(statusCode >= 200 && statusCode < 400)) {
    return;
  }

  // Handle requests
  if (!interaction.request.body && (_operation$requestBod = operation.requestBody) !== null && _operation$requestBod !== void 0 && _operation$requestBod.required) {
    yield {
      description: 'make request body optional',
      impact: [_patches.PatchImpact.Addition, _patches.PatchImpact.BackwardsCompatible],
      diff: {
        kind: _types.OperationDiffResultKind.MissingRequestBody
      },
      groupedOperations: [{
        op: 'replace',
        path: _jsonPointerHelpers.jsonPointerHelpers.compile(['requestBody', 'required']),
        value: false
      }]
    };
  } else if (!operation.requestBody && interaction.request.body && interaction.request.body.contentType) {
    const contentType = interaction.request.body.contentType;
    yield {
      description: `add '${contentType}' body as a valid request body type`,
      impact: [_patches.PatchImpact.Addition, _patches.PatchImpact.BackwardsCompatible],
      diff: {
        kind: _types.OperationDiffResultKind.UnmatchedRequestBody,
        contentType: contentType
      },
      groupedOperations: [{
        op: 'add',
        path: _jsonPointerHelpers.jsonPointerHelpers.compile(['requestBody']),
        value: {
          content: {}
        }
      }, {
        op: 'add',
        path: _jsonPointerHelpers.jsonPointerHelpers.compile(['requestBody', 'content', contentType]),
        value: {
          schema: {}
        }
      }]
    };
  } else if (operation.requestBody && interaction.request.body && interaction.request.body.contentType) {
    const matchedRequestBody = (0, _operations.findBody)(operation.requestBody, interaction.request.body.contentType);
    if (!matchedRequestBody) {
      const contentType = interaction.request.body.contentType;
      let groupedOperations = [];
      if (!operation.requestBody.content) {
        groupedOperations.push({
          op: 'add',
          path: _jsonPointerHelpers.jsonPointerHelpers.compile(['requestBody', 'content']),
          value: {}
        });
      }
      groupedOperations.push({
        op: 'add',
        path: _jsonPointerHelpers.jsonPointerHelpers.compile(['requestBody', 'content', contentType]),
        value: {
          schema: {}
        }
      });
      yield {
        description: `add '${contentType}' body as a valid request body type`,
        impact: [_patches.PatchImpact.Addition, _patches.PatchImpact.BackwardsCompatible],
        diff: {
          kind: _types.OperationDiffResultKind.UnmatchedRequestBody,
          contentType: contentType
        },
        groupedOperations
      };
    }
  }
}
function* generateResponsePatches(documentedInteraction) {
  var _interaction$response3, _interaction$response4;
  const {
    operation,
    interaction
  } = documentedInteraction;
  if (!interaction.response) return;
  const statusCode = interaction.response.statusCode;
  const responseMatch = (0, _operations.findResponse)(operation, statusCode);
  if (!responseMatch) {
    var _interaction$response2;
    const contentType = (_interaction$response2 = interaction.response.body) === null || _interaction$response2 === void 0 ? void 0 : _interaction$response2.contentType;
    const numericalStatusCode = parseInt(statusCode, 10);
    if (!isNaN(numericalStatusCode) && (numericalStatusCode < 200 || numericalStatusCode >= 500 || numericalStatusCode >= 300 && numericalStatusCode < 400)) {
      return; // only document 2xx and 4xx
    }
    const groupedOperations = [{
      op: 'add',
      path: _jsonPointerHelpers.jsonPointerHelpers.compile(['responses', statusCode]),
      value: {
        description: `${statusCode} response`
      }
    }];
    if (contentType) {
      groupedOperations.push({
        op: 'add',
        path: _jsonPointerHelpers.jsonPointerHelpers.compile(['responses', statusCode, 'content']),
        value: {
          [contentType]: {}
        }
      });
    }
    yield {
      description: `add ${statusCode} response`,
      impact: [_patches.PatchImpact.Addition, _patches.PatchImpact.BackwardsCompatible],
      diff: {
        kind: _types.OperationDiffResultKind.UnmatchedResponseStatusCode,
        statusCode: interaction.response.statusCode,
        contentType: contentType || null
      },
      groupedOperations
    };
    return; // no response, no more to diff
  }
  const [response] = responseMatch;
  const contentType = (_interaction$response3 = interaction.response.body) === null || _interaction$response3 === void 0 ? void 0 : _interaction$response3.contentType;
  const matchedBody = (0, _operations.findBody)(response, (_interaction$response4 = interaction.response.body) === null || _interaction$response4 === void 0 ? void 0 : _interaction$response4.contentType);
  if (!matchedBody && interaction.response.body && contentType) {
    const groupedOperations = [];
    if (!response.content) {
      groupedOperations.push({
        op: 'add',
        path: _jsonPointerHelpers.jsonPointerHelpers.compile(['responses', statusCode, 'content']),
        value: {}
      });
    }
    groupedOperations.push({
      op: 'add',
      path: _jsonPointerHelpers.jsonPointerHelpers.compile(['responses', statusCode, 'content', contentType]),
      value: {}
    });
    yield {
      description: `add ${contentType} response for ${statusCode}`,
      impact: [_patches.PatchImpact.Addition, _patches.PatchImpact.BackwardsCompatible],
      diff: {
        kind: _types.OperationDiffResultKind.UnmatchedResponseBody,
        contentType: contentType,
        statusCode: statusCode
      },
      groupedOperations
    };
  } else if (response.content && !interaction.response.body) {
    const contentSize = [...Object.keys(response.content || {})].length;
    yield {
      description: `remove response content for ${statusCode}`,
      impact: [contentSize > 0 ? _patches.PatchImpact.BackwardsIncompatible : _patches.PatchImpact.BackwardsCompatible],
      diff: {
        kind: _types.OperationDiffResultKind.MissingResponseBody,
        statusCode: statusCode
      },
      groupedOperations: [{
        op: 'remove',
        path: _jsonPointerHelpers.jsonPointerHelpers.compile(['responses', statusCode, 'content'])
      }]
    };
  }
}