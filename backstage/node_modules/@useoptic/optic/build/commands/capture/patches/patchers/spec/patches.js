"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "PatchImpact", {
  enumerable: true,
  get: function () {
    return _patchOperations.PatchImpact;
  }
});
exports.SpecPatches = exports.SpecPatch = void 0;
var _patchOperations = require("../../patch-operations");
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _fastJsonPatch = _interopRequireDefault(require("fast-json-patch"));
var _patches = require("../../patchers/shapes/patches");
var _documentedBodies = require("../../patchers/shapes/documented-bodies");
var _sentry = require("../../../../../sentry");
var _logger = require("../../../../../logger");
var _operations = require("./operations");
var _requestParams = require("./request-params");
var _responseHeaders = require("./response-headers");
class SpecPatch {
  static fromShapePatch(shapePatch, bodySpecPath, location) {
    const inResponse = ('inResponse' in location);
    const inComponentSchema = ('inComponentSchema' in location);
    const schemaPath = inComponentSchema ? bodySpecPath : _jsonPointerHelpers.jsonPointerHelpers.append(bodySpecPath, 'schema');
    return {
      description: `update ${inComponentSchema ? 'component schema' : inResponse ? 'response body' : 'request body'}: ${shapePatch.description}`,
      impact: shapePatch.impact,
      diff: shapePatch.diff,
      path: schemaPath,
      groupedOperations: shapePatch.groupedOperations.map(op => ({
        ...op,
        path: _jsonPointerHelpers.jsonPointerHelpers.join(schemaPath, op.path)
      })),
      interaction: shapePatch.interaction
    };
  }
  static fromOperationPatch(operationPatch, interaction, operationSpecPath) {
    return {
      description: `operation: ${operationPatch.description}`,
      impact: operationPatch.impact,
      diff: operationPatch.diff,
      path: operationSpecPath,
      groupedOperations: operationPatch.groupedOperations.map(op => ({
        ...op,
        path: _jsonPointerHelpers.jsonPointerHelpers.join(operationSpecPath, op.path)
      })),
      interaction
    };
  }
  static applyPatch(patch, spec) {
    const operations = _fastJsonPatch.default.deepClone([...SpecPatch.operations(patch)]);
    try {
      const result = _fastJsonPatch.default.applyPatch(spec, operations, undefined, false // don't mutate the original spec
      );
      return result.newDocument;
    } catch (e) {
      _logger.logger.debug({
        location: 'schema',
        error: e,
        operations: JSON.stringify(operations),
        parsed: JSON.stringify(spec)
      });
      _sentry.SentryClient.captureException(e, {
        extra: {
          operations
        }
      });
      throw e;
    }
  }
  static *operations(patch) {
    for (let op of patch.groupedOperations) {
      yield op;
    }
  }
}
exports.SpecPatch = SpecPatch;
class SpecPatches {
  static async *shapeAdditions(documentedBodies, openAPIVersion) {
    const updatedSchemasByPath = new Map();
    for await (let documentedBody of documentedBodies) {
      let {
        specJsonPath,
        shapeLocation
      } = documentedBody;
      if (updatedSchemasByPath.has(specJsonPath)) {
        documentedBody.schema = updatedSchemasByPath.get(specJsonPath) ?? null;
      }
      for (let patchOrDiff of _patches.ShapePatches.generateBodyAdditions(documentedBody, openAPIVersion)) {
        if ('unpatchable' in patchOrDiff) {
          yield patchOrDiff;
        } else {
          documentedBody = _documentedBodies.DocumentedBody.applyShapePatch(documentedBody, patchOrDiff);
          yield SpecPatch.fromShapePatch(patchOrDiff, specJsonPath, shapeLocation);
        }
      }
      updatedSchemasByPath.set(specJsonPath, documentedBody.schema);
    }
  }
  static async *operationAdditions(documentedInteraction) {
    const operationPatches = (0, _operations.generateOperationPatches)(documentedInteraction);
    for (let patch of operationPatches) {
      const specPatch = SpecPatch.fromOperationPatch(patch, documentedInteraction.interaction, documentedInteraction.specJsonPath);
      yield specPatch;
    }
  }
  static async *requestAdditions(interaction, operation) {
    yield* (0, _requestParams.generateRequestParameterPatches)(interaction, operation);
  }
  static async *responseAdditions(interaction, operation) {
    yield* (0, _responseHeaders.generateResponseHeaderPatches)(interaction, operation);
  }
}
exports.SpecPatches = SpecPatches;