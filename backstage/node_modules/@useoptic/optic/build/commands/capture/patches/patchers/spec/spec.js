"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMissingMethodPatch = createMissingMethodPatch;
exports.createMissingPathPatches = createMissingPathPatches;
exports.getIgnorePathPatch = getIgnorePathPatch;
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _constants = require("../../../../../constants");
var _patchOperations = require("../../patch-operations");
var _types = require("./types");
function getIgnorePathPatch(spec, ignorePaths) {
  const hasExistingIgnorePaths = Array.isArray(spec[_constants.OPTIC_PATH_IGNORE_KEY]);
  const operations = [];
  const basePath = _jsonPointerHelpers.jsonPointerHelpers.compile([_constants.OPTIC_PATH_IGNORE_KEY]);
  if (!hasExistingIgnorePaths) {
    operations.push({
      op: 'replace',
      path: basePath,
      value: []
    });
  }
  for (const path of ignorePaths) {
    operations.push({
      op: 'add',
      path: _jsonPointerHelpers.jsonPointerHelpers.compile([_constants.OPTIC_PATH_IGNORE_KEY, '-']),
      value: path
    });
  }
  return {
    description: 'add x-optic-path-ignore values',
    diff: undefined,
    impact: [_patchOperations.PatchImpact.Addition],
    groupedOperations: operations,
    path: basePath
  };
}
function createMissingPathPatches(undocumentedOperation) {
  const {
    specPath,
    methods,
    pathPattern,
    pathParameters
  } = undocumentedOperation;
  let groupedOperations = [];
  groupedOperations.push({
    op: 'add',
    path: specPath,
    value: {}
  });
  if (pathParameters.length > 0) {
    groupedOperations.push({
      op: 'add',
      path: _jsonPointerHelpers.jsonPointerHelpers.append(specPath, 'parameters'),
      value: pathParameters.map(parameterName => {
        return {
          in: 'path',
          name: parameterName,
          required: true,
          schema: {
            type: 'string'
          }
        };
      })
    });
  }
  let methodOperations = methods.map(method => ({
    op: 'add',
    path: _jsonPointerHelpers.jsonPointerHelpers.append(specPath, method),
    value: {
      responses: {}
    }
  }));
  groupedOperations.push(...methodOperations);
  return {
    diff: {
      kind: _types.OperationDiffResultKind.UnmatchedPath,
      subject: pathPattern
    },
    path: _jsonPointerHelpers.jsonPointerHelpers.compile(['paths']),
    description: `add '${pathPattern}' and method${methods.length > 1 ? 's' : ''} ${methods.map(m => m.toUpperCase()).join(', ')}`,
    impact: [_patchOperations.PatchImpact.Addition, _patchOperations.PatchImpact.BackwardsCompatible],
    groupedOperations
  };
}
function createMissingMethodPatch(undocumentedOperation) {
  const {
    specPath,
    method,
    pathPattern
  } = undocumentedOperation;
  let groupedOperations = [];
  groupedOperations.push({
    op: 'add',
    path: specPath,
    value: {
      responses: {}
    }
  });
  return {
    diff: {
      kind: _types.OperationDiffResultKind.UnmatchedMethod,
      subject: method,
      pathPattern: pathPattern
    },
    path: _jsonPointerHelpers.jsonPointerHelpers.compile(['paths', pathPattern]),
    description: `add '${method.toUpperCase()}' method for '${pathPattern}'`,
    impact: [_patchOperations.PatchImpact.Addition, _patchOperations.PatchImpact.BackwardsCompatible],
    groupedOperations
  };
}