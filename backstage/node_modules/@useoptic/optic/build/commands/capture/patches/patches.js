"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateEndpointSpecPatches = generateEndpointSpecPatches;
exports.generatePathAndMethodSpecPatches = generatePathAndMethodSpecPatches;
exports.generateRefRefactorPatches = generateRefRefactorPatches;
exports.jsonOpsFromSpecPatches = jsonOpsFromSpecPatches;
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _openapiIo = require("@useoptic/openapi-io");
var _patches = require("./patchers/spec/patches");
var _operations = require("../../oas/operations");
var _documentedBodies = require("./patchers/shapes/documented-bodies");
var _schemaInventory = require("./patchers/closeness/schema-inventory");
var _spec = require("./patchers/spec/spec");
async function* generatePathAndMethodSpecPatches(specHolder, endpoint) {
  var _specHolder$spec$path, _specHolder$spec$path2;
  const hasPath = !!((_specHolder$spec$path = specHolder.spec.paths) !== null && _specHolder$spec$path !== void 0 && _specHolder$spec$path[endpoint.path]);
  const hasMethod = !!((_specHolder$spec$path2 = specHolder.spec.paths) !== null && _specHolder$spec$path2 !== void 0 && (_specHolder$spec$path2 = _specHolder$spec$path2[endpoint.path]) !== null && _specHolder$spec$path2 !== void 0 && _specHolder$spec$path2[endpoint.method]);
  if (!hasPath) {
    const pathParameters = endpoint.path.split('/').filter(p => p.startsWith('{') && p.endsWith('}')).map(p => p.slice(1, -1));
    const patch = (0, _spec.createMissingPathPatches)({
      type: _operations.UndocumentedOperationType.MissingPath,
      pathPattern: endpoint.path,
      specPath: _jsonPointerHelpers.jsonPointerHelpers.compile(['paths', endpoint.path]),
      methods: [endpoint.method],
      pathParameters
    });
    specHolder.spec = _patches.SpecPatch.applyPatch(patch, specHolder.spec);
    yield patch;
  } else if (!hasMethod) {
    const patch = (0, _spec.createMissingMethodPatch)({
      type: _operations.UndocumentedOperationType.MissingMethod,
      pathPattern: endpoint.path,
      specPath: _jsonPointerHelpers.jsonPointerHelpers.compile(['paths', endpoint.path, endpoint.method]),
      method: endpoint.method
    });
    specHolder.spec = _patches.SpecPatch.applyPatch(patch, specHolder.spec);
    yield patch;
  }
}

// Generate spec patches for an endpoint in the spec
async function* generateEndpointSpecPatches(interactions, specHolder, endpoint, opts = {}) {
  // TODO move this to the top level
  const openAPIVersion = (0, _openapiIo.checkOpenAPIVersion)(specHolder.spec);
  const jsonPath = _jsonPointerHelpers.jsonPointerHelpers.compile(['paths', endpoint.path, endpoint.method]);
  for await (const interaction of interactions) {
    var _opts$coverage, _documentedInteractio;
    const operation = _operations.Operation.fromOperationObject(endpoint.path, endpoint.method, _jsonPointerHelpers.jsonPointerHelpers.get(specHolder.spec, jsonPath));
    let documentedInteraction = {
      interaction,
      operation,
      specJsonPath: jsonPath
    };
    (_opts$coverage = opts.coverage) === null || _opts$coverage === void 0 || _opts$coverage.operationInteraction(documentedInteraction.operation.pathPattern, documentedInteraction.operation.method, !!documentedInteraction.interaction.request.body, (_documentedInteractio = documentedInteraction.interaction.response) === null || _documentedInteractio === void 0 ? void 0 : _documentedInteractio.statusCode);

    // phase one: operation patches, making sure all requests / responses are documented
    let opPatches = _patches.SpecPatches.operationAdditions(documentedInteraction);
    for await (let patch of opPatches) {
      specHolder.spec = _patches.SpecPatch.applyPatch(patch, specHolder.spec);
      yield patch;
    }

    // phase two: request params and response headers
    let requestPatches = _patches.SpecPatches.requestAdditions(interaction, _operations.Operation.fromOperationObject(endpoint.path, endpoint.method, _jsonPointerHelpers.jsonPointerHelpers.get(specHolder.spec, jsonPath)));
    for await (let patch of requestPatches) {
      specHolder.spec = _patches.SpecPatch.applyPatch(patch, specHolder.spec);
      yield patch;
    }
    let responseAdditions = _patches.SpecPatches.responseAdditions(interaction, _operations.Operation.fromOperationObject(endpoint.path, endpoint.method, _jsonPointerHelpers.jsonPointerHelpers.get(specHolder.spec, jsonPath)));
    for await (let patch of responseAdditions) {
      specHolder.spec = _patches.SpecPatch.applyPatch(patch, specHolder.spec);
      yield patch;
    }

    // phase three: shape patches, describing request / response bodies in detail
    documentedInteraction.operation = _operations.Operation.fromOperationObject(endpoint.path, endpoint.method, _jsonPointerHelpers.jsonPointerHelpers.get(specHolder.spec, jsonPath));
    let documentedBodies = _documentedBodies.DocumentedBodies.fromDocumentedInteraction(documentedInteraction);
    let shapePatches = _patches.SpecPatches.shapeAdditions(documentedBodies, openAPIVersion);
    for await (let patch of shapePatches) {
      if (!('unpatchable' in patch)) {
        var _opts$schemaAdditions;
        (_opts$schemaAdditions = opts.schemaAdditionsSet) === null || _opts$schemaAdditions === void 0 || _opts$schemaAdditions.add(patch.path);
        specHolder.spec = _patches.SpecPatch.applyPatch(patch, specHolder.spec);
      }
      yield patch;
    }
  }
}

// Creates a new ref or uses an existing ref for added paths
async function* generateRefRefactorPatches(specHolder, meta) {
  var _specHolder$spec$comp;
  const schemaInventory = new _schemaInventory.SchemaInventory();
  schemaInventory.addSchemas(_jsonPointerHelpers.jsonPointerHelpers.compile(['components', 'schemas']), ((_specHolder$spec$comp = specHolder.spec.components) === null || _specHolder$spec$comp === void 0 ? void 0 : _specHolder$spec$comp.schemas) || {});
  const refRefactors = schemaInventory.refsForAdditions(meta.schemaAdditionsSet, specHolder.spec, meta);
  for await (let patch of refRefactors) {
    specHolder.spec = _patches.SpecPatch.applyPatch(patch, specHolder.spec);
    yield patch;
  }
}
async function jsonOpsFromSpecPatches(specPatches) {
  const ops = [];
  for await (const patch of specPatches) {
    for (const operation of patch.groupedOperations) {
      ops.push(operation);
    }
  }
  return ops;
}