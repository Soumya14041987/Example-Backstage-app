"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EndpointPatchSummaries = void 0;
var _chalk = _interopRequireDefault(require("chalk"));
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _logger = require("../../../logger");
var _openapiIo = require("@useoptic/openapi-io");
var _openapiUtilities = require("@useoptic/openapi-utilities");
function getShapeDiffDetails(description, pathToHighlight, error, pointerLogger) {
  const lines = `${_chalk.default.bgRed('  Diff  ')} ${description}
${pointerLogger.log(pathToHighlight, {
    highlightColor: 'yellow',
    observation: error
  })}\n`;
  return lines;
}
function locationFromPath(path) {
  // expected patterns:
  // /paths/:path/:method/requestBody
  // /paths/:path/:method/responses/:statusCode
  const parts = _jsonPointerHelpers.jsonPointerHelpers.decode(path);
  if (parts[3] === 'requestBody') {
    return {
      text: '[request body]',
      location: {
        type: 'request'
      }
    };
  } else if (parts[3] === 'responses' && parts[4]) {
    const statusCode = parts[4];
    return {
      text: `[${statusCode} response body]`,
      location: {
        type: 'response',
        statusCode: Number(statusCode)
      }
    };
  }
  return {
    text: '',
    location: {
      type: 'request'
    }
  };
}
function summarizePatch(patch, parseResult, options) {
  const verbose = options.verbose && options.mode === 'verify';
  const {
    jsonLike: spec,
    sourcemap
  } = parseResult;
  const pointerLogger = (0, _openapiIo.jsonPointerLogger)(sourcemap);
  const {
    diff,
    path,
    groupedOperations
  } = patch;
  const color = options.mode === 'update' ? _chalk.default.green : _chalk.default.red;
  if (!diff || groupedOperations.length === 0) return null;
  if (diff.kind === 'MissingRequestBody') {
    const action = options.mode === 'update' ? 'is now optional' : 'is required and missing';
    return {
      summarized: [color(`[request body] body ${action}`)],
      location: {
        type: 'request'
      }
    };
  } else if (diff.kind === 'UnmatchdResponseBody' || diff.kind === 'UnmatchedRequestBody' || diff.kind === 'UnmatchedResponseStatusCode') {
    const location = diff.kind === 'UnmatchedRequestBody' ? {
      type: 'request'
    } : {
      type: 'response',
      statusCode: Number(diff.statusCode)
    };
    const action = options.mode === 'update' ? 'has been added' : 'is not documented';
    return {
      location,
      summarized: [color(`${diff.kind === 'UnmatchedRequestBody' ? '[request body]' : `[${diff.statusCode} response body]`} body ${action}`)]
    };
  } else if (diff.kind === 'UnmatchedRequestParameter' || diff.kind === 'UnmatchedResponseHeader') {
    const location = diff.kind === 'UnmatchedRequestParameter' ? {
      type: 'request-param'
    } : {
      type: 'response-header',
      statusCode: Number(diff.statusCode)
    };
    const action = options.mode === 'update' ? 'has been added' : 'is not documented';
    return {
      location,
      summarized: [color(`${diff.kind === 'UnmatchedRequestParameter' ? `[${diff.in} parameter]` : `[${diff.statusCode} response header]`} ${diff.name} ${action}`)]
    };
  } else if (diff.kind === 'MissingRequiredRequiredParameter' || diff.kind === 'MissingRequiredResponseHeader') {
    const location = diff.kind === 'MissingRequiredRequiredParameter' ? {
      type: 'request-param'
    } : {
      type: 'response-header',
      statusCode: Number(diff.statusCode)
    };
    const action = options.mode === 'update' ? 'is now optional' : 'is required and missing';
    return {
      location,
      summarized: [color(`${diff.kind === 'MissingRequiredRequiredParameter' ? `[${diff.in} parameter]` : `[${diff.statusCode} response header]`} ${diff.name} ${action}`)]
    };
  } else {
    const location = locationFromPath(path);
    if (diff.kind === 'AdditionalProperty') {
      // filter out dependent diffs
      if (!_jsonPointerHelpers.jsonPointerHelpers.tryGet(spec, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.parentObjectPath)).match) return null;
      const action = options.mode === 'update' ? 'has been added' : 'is not documented';
      const propertyLocation = options.mode === 'update' ? `(${diff.propertyPath})` : diff.parentObjectPath ? `(${diff.parentObjectPath})` : '';
      return {
        summarized: [color(`${location.text} '${diff.key}' ${action} ${propertyLocation}`)],
        location: location.location
      };
    } else if (diff.kind === 'UnmatchedType') {
      // filter out dependent diffs
      if (!_jsonPointerHelpers.jsonPointerHelpers.tryGet(spec, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.propertyPath)).match) return null;
      let action;
      if (diff.keyword === 'oneOf') {
        action = options.mode === 'update' ? 'now matches schema' : `does not match schema`;
      } else {
        action = options.mode === 'update' ? `is now type ${diff.expectedType}` : `does not match type ${diff.expectedType}. Received ${diff.example}`;
      }
      const color = options.mode === 'update' ? _chalk.default.yellow : _chalk.default.red;
      const lines = [color(`${location.text} '${diff.key}' ${action} (${diff.propertyPath})`)];
      if (verbose) {
        lines.push(getShapeDiffDetails(diff.description, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.propertyPath), `[Actual] ${JSON.stringify(diff.example)}`, pointerLogger));
      }
      return {
        summarized: lines,
        location: location.location
      };
    } else if (diff.kind === 'MissingRequiredProperty') {
      // filter out dependent diffs
      if (!_jsonPointerHelpers.jsonPointerHelpers.tryGet(spec, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.propertyPath)).match) return null;
      const action = options.mode === 'update' ? `is now optional` : `is required and missing`;
      const color = options.mode === 'update' ? _chalk.default.yellow : _chalk.default.red;
      const lines = [color(`${location.text} '${diff.key}' ${action} (${diff.propertyPath})`)];
      if (verbose) {
        lines.push(getShapeDiffDetails(diff.description, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.propertyPath), `missing`, pointerLogger));
      }
      return {
        summarized: lines,
        location: location.location
      };
    } else if (diff.kind === 'MissingEnumValue') {
      if (!_jsonPointerHelpers.jsonPointerHelpers.tryGet(spec, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.propertyPath)).match) return null;
      const action = options.mode === 'update' ? `now has enum value '${diff.value}'` : `missing enum value '${diff.value}'`;
      const color = options.mode === 'update' ? _chalk.default.yellow : _chalk.default.red;
      const lines = [color(`${location.text} '${diff.key}' ${action} (${diff.propertyPath})`)];
      if (verbose) {
        lines.push(getShapeDiffDetails(diff.description, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.propertyPath), `missing enum value '${diff.value}'`, pointerLogger));
      }
      return {
        summarized: lines,
        location: location.location
      };
    }
  }
  return null;
}
function summarizeUnpatchableDiff(diff, parseResult, options) {
  const verbose = options.verbose && options.mode === 'verify';
  const pointerLogger = (0, _openapiIo.jsonPointerLogger)(parseResult.sourcemap);
  const reader = (0, _openapiUtilities.sourcemapReader)(parseResult.sourcemap);
  const {
    path: jsonPath,
    validationError,
    examples
  } = diff;
  const location = locationFromPath(jsonPath);
  const summarizedExamples = examples.slice(0, 3).map(e => JSON.stringify(e)).join(', ') + (examples.length > 3 ? ` and ${examples.length - 3} other values` : '');
  const lines = [_chalk.default.red(`${location.text} schema (${diff.schemaPath}) with keyword '${validationError.keyword}' and parameters ${JSON.stringify(validationError.params)} received invalid values ${summarizedExamples}`)];
  if (options.mode === 'update') {
    const sourcemap = reader.findFileAndLines(jsonPath);
    lines.push(_chalk.default.red(` ⛔️ schema could not be automatically updated. Update the schema manually` + (sourcemap ? ` at ${(0, _openapiUtilities.getSourcemapLink)(sourcemap)}` : '')));
  }
  if (verbose) {
    lines.push(getShapeDiffDetails('interaction did not match schema', jsonPath, `[Actual] ${summarizedExamples}`, pointerLogger));
  }
  return {
    summarized: lines,
    location: location.location
  };
}
class EndpointPatchSummaries {
  constructor(parseResult, options) {
    this.parseResult = parseResult;
    this.options = options;
    this.patches = {
      requestParams: [],
      requestBody: [],
      responses: new Map()
    };
  }
  addPatch(patchOrDiff) {
    const patchDetails = 'unpatchable' in patchOrDiff ? summarizeUnpatchableDiff(patchOrDiff, this.parseResult, {
      mode: this.options.update ? 'update' : 'verify',
      verbose: this.options.verbose
    }) : summarizePatch(patchOrDiff, this.parseResult, {
      mode: this.options.update ? 'update' : 'verify',
      verbose: this.options.verbose
    });
    if (patchDetails) {
      const {
        summarized,
        location
      } = patchDetails;
      if (_logger.logger.getLevel() <= 1 && patchOrDiff.interaction) {
        summarized.push(`Originating request: ${JSON.stringify(patchOrDiff.interaction)}`);
      }
      switch (location.type) {
        case 'request':
          {
            this.patches.requestBody.push(...summarized);
            break;
          }
        case 'request-param':
          {
            this.patches.requestParams.push(...summarized);
            break;
          }
        case 'response':
          {
            const responsePatches = this.patches.responses.get(location.statusCode) ?? {
              headers: [],
              body: []
            };
            responsePatches.body.push(...summarized);
            this.patches.responses.set(location.statusCode, responsePatches);
            break;
          }
        case 'response-header':
          {
            const responsePatches = this.patches.responses.get(location.statusCode) ?? {
              headers: [],
              body: []
            };
            responsePatches.headers.push(...summarized);
            break;
          }
      }
    }
  }
  getPatchSummaries() {
    const patchSummaries = [...this.patches.requestParams, ...this.patches.requestBody];

    // sort by asc status code
    const sortedResponses = [...this.patches.responses.entries()].sort(([a], [b]) => a - b);
    for (const [, response] of sortedResponses) {
      patchSummaries.push(...response.headers, ...response.body);
    }
    return patchSummaries;
  }
}
exports.EndpointPatchSummaries = EndpointPatchSummaries;