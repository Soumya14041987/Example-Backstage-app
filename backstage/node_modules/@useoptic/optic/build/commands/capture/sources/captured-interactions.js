"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CapturedInteractions = exports.CapturedInteraction = void 0;
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _url = require("url");
var _buffer = require("buffer");
var _body = require("./body");
var _logger = require("../../../logger");
class CapturedInteraction {
  static fromHarEntry(entry) {
    const url = new _url.URL(entry.request.url);
    const method = _openapiUtilities.OpenAPIV3.HttpMethods[entry.request.method];
    if (!method) {
      return null;
    }
    let requestBody = null;
    let responseBody = null;
    const requestPostData = entry.request.postData;
    if (requestPostData && requestPostData.text && (!requestPostData.encoding || _buffer.Buffer.isEncoding(requestPostData.encoding))) {
      let buffer = _buffer.Buffer.from(requestPostData.text, requestPostData.encoding);
      const asText = new TextDecoder().decode(buffer);
      requestBody = _body.CapturedBody.from(asText, requestPostData.mimeType);
    }
    const responseContent = entry.response.content;
    if (responseContent.text && (!responseContent.encoding || _buffer.Buffer.isEncoding(responseContent.encoding))) {
      let buffer = _buffer.Buffer.from(responseContent.text, responseContent.encoding);
      const asText = new TextDecoder().decode(buffer);
      responseBody = _body.CapturedBody.from(asText, responseContent.mimeType);
    }
    const headers = entry.request.headers.filter(h => h.name && h.value).map(h => ({
      name: h.name,
      value: h.value
    }));
    const query = entry.request.queryString.filter(q => q.name && q.value).map(q => ({
      name: q.name,
      value: q.value
    }));
    const responseHeaders = entry.response.headers.filter(h => h.name && h.value).map(h => ({
      name: h.name,
      value: h.value
    }));
    return {
      request: {
        host: url.host,
        method,
        path: url.pathname,
        body: requestBody,
        headers,
        query
      },
      response: {
        statusCode: '' + entry.response.status,
        body: responseBody,
        headers: responseHeaders
      }
    };
  }
  static fromPostmanCollection(postmanEntry) {
    var _request$method, _request$body, _request$body2;
    const {
      request,
      response,
      variableScope
    } = postmanEntry;
    const resolve = str => variableScope.replaceIn(str);
    const query = request.url.query.map(query => ({
      name: resolve(query.key || ''),
      value: resolve(query.value || '')
    }));
    const method = _openapiUtilities.OpenAPIV3.HttpMethods[((_request$method = request.method) === null || _request$method === void 0 ? void 0 : _request$method.toUpperCase()) || 'GET'];
    if (!method) {
      return null;
    }
    const languageMap = {
      json: 'application/json',
      xml: 'application/xml',
      html: 'text/html',
      javascript: 'text/javascript'
    };
    const language = (_request$body = request.body) === null || _request$body === void 0 || (_request$body = _request$body.options) === null || _request$body === void 0 || (_request$body = _request$body.raw) === null || _request$body === void 0 ? void 0 : _request$body.language;
    const modeMap = {
      urlencoded: 'application/x-www-form-urlencoded',
      formdata: 'multipart/formdata',
      graphql: 'application/json',
      raw: language && languageMap[language]
    };
    const mode = (_request$body2 = request.body) === null || _request$body2 === void 0 ? void 0 : _request$body2.mode;
    const requestContentTypeHeader = request.headers.get('Content-Type');

    // Postman doesn't always include a Content-Type header
    // in the request.  When no Content-Type header exists,
    // the content type may be inferred using other hints in
    // the format.
    const requestContentType = requestContentTypeHeader !== null && requestContentTypeHeader !== void 0 && requestContentTypeHeader.length ? resolve(requestContentTypeHeader) : mode && modeMap[mode] || 'text/plain';
    const requestBodySource = request.body ? resolve(request.body.toString()) : '';
    const responseBodySource = response !== null && response !== void 0 && response.body ? resolve(response.body.toString()) : null;
    return {
      request: {
        host: resolve(request.url.getHost()),
        method,
        path: resolve(request.url.getPath()),
        query,
        headers: request.headers.all().map(({
          key,
          value
        }) => ({
          name: resolve(key),
          value: resolve(value)
        })),
        body: requestBodySource.length ? _body.CapturedBody.from(requestBodySource, requestContentType) : null
      },
      response: response ? {
        statusCode: response.code.toString(),
        headers: response.headers.all().map(({
          key,
          value
        }) => ({
          name: resolve(key),
          value: resolve(value)
        })),
        body: response.body ? _body.CapturedBody.from(responseBodySource, response.contentInfo().contentType) : null
      } : undefined
    };
  }
}
exports.CapturedInteraction = CapturedInteraction;
class CapturedInteractions {
  static async *fromHarEntries(entries) {
    for await (let entry of entries) {
      const capturedInteraction = CapturedInteraction.fromHarEntry(entry);
      if (capturedInteraction) {
        yield capturedInteraction;
      } else {
        _logger.logger.debug(`skipping entry ${JSON.stringify(entry)}`);
      }
    }
  }
  static async *fromPostmanCollection(entries) {
    for await (let entry of entries) {
      const capturedInteraction = CapturedInteraction.fromPostmanCollection(entry);
      if (capturedInteraction) {
        yield capturedInteraction;
      } else {
        _logger.logger.debug(`skipping entry ${JSON.stringify(entry)}`);
      }
    }
  }
}
exports.CapturedInteractions = CapturedInteractions;