"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProxyServer = void 0;
var mockttp = _interopRequireWildcard(require("mockttp"));
var _url = require("url");
var _portfinder = _interopRequireDefault(require("portfinder"));
var _chalk = _interopRequireDefault(require("chalk"));
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _urlJoin = _interopRequireDefault(require("url-join"));
var _esnext = require("axax/esnext");
var _logger = require("../../../logger");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
class ProxyServer {
  capturingProxy = undefined;
  constructor(target) {
    try {
      this.url = new _url.URL(target);
    } catch (e) {
      _logger.logger.error(`${_chalk.default.red('Error:')} Invalid URL. Valid URLs must include the protocol and host, e.g. http://localhost:3030 or https://api.example.com, received: ${target}`);
      throw new _openapiUtilities.UserError();
    }
  }
  async start(port) {
    const {
      origin,
      pathname: serverPathnamePrefix
    } = this.url;
    const capturingProxy = mockttp.getLocal({
      cors: false,
      debug: false,
      recordTraffic: false
    });
    const interactionSubject = new _esnext.Subject();
    this.interactionSubject = interactionSubject;
    this.capturingProxy = capturingProxy;
    const requestsById = new Map();
    if (!port) {
      port = await _portfinder.default.getPortPromise({
        port: 8000,
        stopPort: 8999
      });
    }
    await capturingProxy.forAnyRequest().always().thenPassThrough({
      beforeRequest: capturedRequest => {
        const {
          matchedRuleId,
          remoteIpAddress,
          remotePort,
          tags,
          body,
          timingEvents,
          ...rest
        } = capturedRequest;
        // Sometimes we need to adjust the request url if the server url is not at the hostname root
        // e.g. `http://example.com/server-lives-here - requests going to the proxy root should be forwarded to `/server-lives-here`
        const urlObj = new _url.URL(rest.url);
        urlObj.pathname = (0, _urlJoin.default)(serverPathnamePrefix, urlObj.pathname);
        const prefixedUrl = urlObj.toString();
        _logger.logger.debug(`Forwarding request ${rest.path} to ${prefixedUrl} with headers: ${JSON.stringify(rest.headers)}. id: ${capturedRequest.id}`);
        const request = {
          ...rest,
          body: {
            buffer: body.buffer
          },
          timingEvents: timingEvents,
          url: prefixedUrl,
          path: urlObj.pathname
        };
        requestsById.set(request.id, request);
        return {
          url: prefixedUrl
        };
      },
      forwarding: {
        targetHost: origin,
        updateHostHeader: true
      }
    });
    await capturingProxy.on('response', capturedResponse => {
      const {
        id
      } = capturedResponse;
      const request = requestsById.get(id);
      if (!request) return;
      const {
        tags,
        body,
        timingEvents,
        ...rest
      } = capturedResponse;
      _logger.logger.debug(`Received response for request id ${id} status code: ${rest.statusCode} message: ${rest.statusMessage} headers: ${JSON.stringify(rest.rawHeaders)}`);
      const response = {
        ...rest,
        body: {
          buffer: body.buffer
        },
        timingEvents: timingEvents
      };
      interactionSubject.onNext({
        request,
        response
      });
      requestsById.delete(id);
    });
    await capturingProxy.start({
      startPort: port,
      endPort: port + 999
    });
    const stream = async function* () {
      yield* interactionSubject.iterator;
    }();
    return [stream, capturingProxy.url];
  }
  stop() {
    var _this$capturingProxy, _this$capturingProxy2, _this$interactionSubj;
    (_this$capturingProxy = this.capturingProxy) === null || _this$capturingProxy === void 0 || _this$capturingProxy.reset();
    (_this$capturingProxy2 = this.capturingProxy) === null || _this$capturingProxy2 === void 0 || _this$capturingProxy2.stop();
    (_this$interactionSubj = this.interactionSubject) === null || _this$interactionSubj === void 0 || _this$interactionSubj.onCompleted();
  }
}
exports.ProxyServer = ProxyServer;