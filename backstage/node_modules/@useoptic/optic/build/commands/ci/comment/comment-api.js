"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GitlabCommenter = exports.GithubCommenter = void 0;
var _rest = require("@octokit/rest");
var _urlJoin = _interopRequireDefault(require("url-join"));
var _JsonHttpClient = require("../../../client/JsonHttpClient");
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
class GithubCommenter {
  constructor(options) {
    this.options = options;
    this.octokit = new _rest.Octokit({
      auth: options.token,
      baseUrl: options.enterpriseBaseUrl,
      request: {
        fetch: _nodeFetch.default
      }
    });
  }
  async getComment(commentIdentifier) {
    const PER_PAGE = 100;
    let page = 1;
    const comments = [];

    // Issues refer to top level comments in the PR
    const {
      data
    } = await this.octokit.rest.issues.listComments({
      owner: this.options.owner,
      repo: this.options.repo,
      issue_number: Number(this.options.pullRequest),
      per_page: PER_PAGE,
      page
    });
    comments.push(...data);
    let moreData = data.length >= PER_PAGE;
    while (moreData) {
      page += 1;
      const {
        data
      } = await this.octokit.rest.issues.listComments({
        owner: this.options.owner,
        repo: this.options.repo,
        issue_number: Number(this.options.pullRequest),
        per_page: PER_PAGE,
        page
      });
      moreData = data.length >= PER_PAGE;
      comments.push(...data);
    }
    const maybeComment = comments.find(comment => new RegExp(commentIdentifier).test(comment.body || '')) || null;
    return maybeComment ? {
      body: maybeComment.body || '',
      id: String(maybeComment.id)
    } : null;
  }
  async updateComment(commentId, body) {
    await this.octokit.rest.issues.updateComment({
      owner: this.options.owner,
      repo: this.options.repo,
      comment_id: Number(commentId),
      body
    });
  }
  async createComment(body) {
    await this.octokit.rest.issues.createComment({
      owner: this.options.owner,
      repo: this.options.repo,
      issue_number: Number(this.options.pullRequest),
      body
    });
  }
}
exports.GithubCommenter = GithubCommenter;
class GitlabCommenter extends _JsonHttpClient.JsonHttpClient {
  constructor(options) {
    super();
    this.options = options;
    this.baseUrl = options.enterpriseBaseUrl ?? 'https://gitlab.com';
  }
  async getComment(commentIdentifier) {
    const comments = await this.getJson((0, _urlJoin.default)(this.baseUrl, `/api/v4/projects/${this.options.projectId}/merge_requests/${this.options.mergeRequestId}/notes`), {
      Authorization: `Bearer ${this.options.token}`
    });
    const maybeComment = comments.find(comment => new RegExp(commentIdentifier).test(comment.body || '')) || null;
    return maybeComment ? {
      body: maybeComment.body || '',
      id: String(maybeComment.id)
    } : null;
  }
  async updateComment(commentId, body) {
    await this.putJson((0, _urlJoin.default)(this.baseUrl, `/api/v4/projects/${this.options.projectId}/merge_requests/${this.options.mergeRequestId}/notes/${commentId}`), {
      body
    }, {
      Authorization: `Bearer ${this.options.token}`
    });
  }
  async createComment(body) {
    await this.postJson((0, _urlJoin.default)(this.baseUrl, `/api/v4/projects/${this.options.projectId}/merge_requests/${this.options.mergeRequestId}/notes`), {
      body
    }, {
      Authorization: `Bearer ${this.options.token}`
    });
  }
}
exports.GitlabCommenter = GitlabCommenter;