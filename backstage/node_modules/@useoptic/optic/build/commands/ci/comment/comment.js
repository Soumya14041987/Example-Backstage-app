"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerCiComment = void 0;
var _commander = require("commander");
var _ciData = require("../../../utils/ci-data");
var _common = require("./common");
var _logger = require("../../../logger");
var _commentApi = require("./comment-api");
var _errorHandler = require("../../../error-handler");
const usage = () => `
  GITHUB_TOKEN=<github-token> optic ci comment --provider github --owner <repo-owner> --repo <repo-name> --pull-request <pr-number> --sha <commit-sha>
  GITLAB_TOKEN=<gitlab-token> optic ci comment --provider gitlab --project-id <project-id> --merge-request-id <merge-request-id> --sha <commit-sha>
`;
const registerCiComment = (cli, config) => {
  cli.command('comment').configureHelp({
    commandUsage: usage
  }).addOption(new _commander.Option('--provider <provider>', `the git provider where you want to post this comment. supported providers are: 'github', 'gitlab'`).choices(['github', 'gitlab']).makeOptionMandatory()).option('--owner <owner>', '[github only] the owner of the repo (this can be an organization or a user)').option('--repo <repo>', '[github only] the name of the repo').option('--pull-request <pull-request>', '[github only] the pull request number on the repo').requiredOption('--sha <sha>', 'the git sha of this run').option('--project-id <project-id>', '[gitlab only] the project id of the project').option('--merge-request-id <merge-request-id>', '[gitlab only] the merge request iid in the repo').option('--enterprise-base-url <enterprise-base-url>', '(only for enterprise versions of github or gitlab) - the base url to your enterprise github / gitlab instance').option('--comment-url <comment-url>', 'override the url of the comment').option('--verbose', 'show all operations changed in each API', false).description('comment on a pull request / merge request').action((0, _errorHandler.errorHandler)(getCiCommentAction(config), {
    command: 'ci-comment'
  }));
};
exports.registerCiComment = registerCiComment;
const getCiCommentAction = config => async _options => {
  const githubToken = process.env.GITHUB_TOKEN;
  const gitlabToken = process.env.GITLAB_TOKEN;
  if (_options.provider === 'github' && (!_options.owner || !_options.repo || !_options.pullRequest || !_options.sha)) {
    _logger.logger.error('option --provider github must include --owner, --repo, --pull-request and --sha');
    process.exitCode = 1;
    return;
  } else if (_options.provider === 'gitlab' && (!_options.projectId || !_options.mergeRequestId || !_options.sha)) {
    _logger.logger.error('option --provider gitlab must include --project-id, --merge-request-id and --sha');
    process.exitCode = 1;
    return;
  } else if (_options.provider === 'github' && !githubToken) {
    _logger.logger.error('no github token was found. Ensure that the environment variable GITHUB_TOKEN is set');
    process.exitCode = 1;
    return;
  } else if (_options.provider === 'gitlab' && !gitlabToken) {
    _logger.logger.error('no gitlab token was found. Ensure that the environment variable GITLAB_TOKEN is set');
    process.exitCode = 1;
    return;
  }
  const options = _options;
  let data;
  try {
    data = await (0, _ciData.readDataForCi)();
  } catch (e) {
    _logger.logger.error('Could not find a valid ci run details file. CI run detail files are generated from `optic diff` and `optic diff-all` when run in ci (`CI=true`)');
    _logger.logger.error(e);
    process.exitCode = 1;
    return;
  }
  const commenter = options.provider === 'github' ? new _commentApi.GithubCommenter({
    ...options,
    token: githubToken
  }) : new _commentApi.GitlabCommenter({
    ...options,
    token: gitlabToken
  });
  const maybeComment = await commenter.getComment(_common.COMPARE_SUMMARY_IDENTIFIER);
  const body = (0, _common.generateCompareSummaryMarkdown)({
    sha: options.sha
  }, data, {
    verbose: options.verbose,
    overrideUrl: options.commentUrl
  });
  if (maybeComment) {
    // If there's a comment already, we need to check whether this session newer than the posted comment
    await commenter.updateComment(maybeComment.id, body);
  } else {
    // if does not have comment, we should only comment when there is a completed or failed session
    if (data.completed.length > 0 || data.failed.length > 0) {
      await commenter.createComment(body);
    }
  }
};