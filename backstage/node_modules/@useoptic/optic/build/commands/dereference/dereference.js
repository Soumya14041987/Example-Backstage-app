"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerDereference = void 0;
var _commander = require("commander");
var _specLoaders = require("../../utils/spec-loaders");
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _openapiIo = require("@useoptic/openapi-io");
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _path = _interopRequireDefault(require("path"));
var _errorHandler = require("../../error-handler");
const description = `dereference an OpenAPI specification`;
const usage = () => `
  optic dereference <file_path>
  optic dereference <file_path> > dereference.yml
  optic dereference <file_path> -o dereference.yml
`;
const helpText = `
Example usage:
  $ optic dereference openapi-spec.yml > dereference.yml
  `;
const registerDereference = (cli, config) => {
  // TODO remove june 2023
  const filterXExtensions = new _commander.Option('--filter-x-extensions [extensions]', 'extensions to filter when truthy value set').hideHelp(true);
  const includeXExtensions = new _commander.Option('--include-x-extensions [extensions]', 'extensions to filter when truthy value set').hideHelp(true);
  cli.command('dereference', {
    hidden: true
  }).configureHelp({
    commandUsage: usage
  }).addHelpText('after', helpText).description(description).argument('[file_path]', 'openapi file to dereference').option('-o [output]', 'output file name').addOption(filterXExtensions).addOption(includeXExtensions).action((0, _errorHandler.errorHandler)(deferenceAction(config), {
    command: 'dereference'
  }));
};
exports.registerDereference = registerDereference;
const getDereferencedSpec = async (file1, config) => {
  try {
    return (0, _specLoaders.loadSpec)(file1, config, {
      strict: false,
      denormalize: false
    });
  } catch (e) {
    console.error(e instanceof Error ? e.message : e);
    throw new _openapiUtilities.UserError();
  }
};
const deferenceAction = config => async (filePath, options) => {
  const {
    o,
    filterXExtensions,
    includeXExtensions
  } = options;
  const filterExtensions = (filterXExtensions || '').split(/[ ,]+/).filter(extension => extension.startsWith('x-'));
  const includeExtensions = (includeXExtensions || '').split(/[ ,]+/).filter(extension => extension.startsWith('x-'));
  let parsedFile;
  if (filePath) {
    parsedFile = await getDereferencedSpec(filePath, config);
    const specJson = parsedFile.jsonLike;
    if (includeExtensions.length) {
      Object.entries(specJson.paths ?? {}).forEach(([path, operations]) => {
        Object.entries(operations).forEach(([key, operation]) => {
          if (key === 'parameters') return;
          if (operation && !includeExtensions.some(extension => Boolean(operation[extension]))) {
            // @ts-ignore
            delete specJson.paths[path][key];
            const otherKeys = Object.keys(specJson.paths[path] || {});
            if (otherKeys.length === 0 || otherKeys.length === 1 && otherKeys[0] === 'parameters') {
              delete specJson.paths[path];
            }
          }
        });
      });
    }
    if (filterExtensions.length) {
      Object.entries(specJson.paths ?? {}).forEach(([path, operations]) => {
        Object.entries(operations).forEach(([key, operation]) => {
          if (key === 'parameters') return;
          // should filter
          if (operation && filterExtensions.some(extension => Boolean(operation[extension]))) {
            // @ts-ignore
            delete specJson.paths[path][key];
            const otherKeys = Object.keys(specJson.paths[path] || {});
            if (otherKeys.length === 0 || otherKeys.length === 1 && otherKeys[0] === 'parameters') {
              delete specJson.paths[path];
            }
          }
        });
      });
    }
    if (o) {
      // write to file
      const outputPath = _path.default.resolve(o);
      await _promises.default.writeFile(outputPath, (0, _openapiIo.isYaml)(o) ? (0, _openapiIo.writeYaml)(specJson) : JSON.stringify(specJson, null, 2));
      console.log('wrote dereferenced spec to ' + _path.default.resolve(o));
    } else {
      // assume pipe >
      if ((0, _openapiIo.isYaml)(filePath)) {
        console.log((0, _openapiIo.writeYaml)(specJson));
      } else {
        console.log(JSON.stringify(specJson, null, 2));
      }
    }
  } else {
    console.error('No specification found');
    process.exitCode = 1;
    return;
  }
};