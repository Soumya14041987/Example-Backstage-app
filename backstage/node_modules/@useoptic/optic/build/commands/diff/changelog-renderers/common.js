"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRootBodyPath = getRootBodyPath;
exports.interpretFieldLevelDiffs = interpretFieldLevelDiffs;
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
function getRootBodyPath(path) {
  const parts = _jsonPointerHelpers.jsonPointerHelpers.decode(path);
  if (parts[3] === 'responses') {
    return _jsonPointerHelpers.jsonPointerHelpers.compile(parts.slice(0, 7));
  } else {
    return _jsonPointerHelpers.jsonPointerHelpers.compile(parts.slice(0, 6));
  }
}
function interpretFieldLevelDiffs(specs, diffs) {
  return Object.entries(diffs).filter(([_, {
    diffs
  }]) => diffs.length > 0).map(([key, {
    diffs
  }]) => {
    const firstDiffPath = diffs[0].after ?? diffs[0].before;

    // TODO figure out if we need to handle path reconciliation here
    // This might only be an issue with nested enums + rearranging + removing keys with oneOf/anyOf/allOf
    const absolutePath = _jsonPointerHelpers.jsonPointerHelpers.join(getRootBodyPath(firstDiffPath), key);
    const beforeRaw = _jsonPointerHelpers.jsonPointerHelpers.tryGet(specs.from, absolutePath);
    const afterRaw = _jsonPointerHelpers.jsonPointerHelpers.tryGet(specs.to, absolutePath);
    const before = beforeRaw.match ? absolutePath : undefined;
    const after = afterRaw.match ? absolutePath : undefined;
    return {
      before,
      after,
      trail: key,
      change: before && after ? 'changed' : before ? 'removed' : 'added'
    };
  });
}