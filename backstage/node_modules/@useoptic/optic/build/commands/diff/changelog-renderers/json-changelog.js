"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.jsonChangelog = jsonChangelog;
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _groupDiff = require("@useoptic/openapi-utilities/build/openapi3/group-diff");
var _common = require("./common");
var _lodash = _interopRequireDefault(require("lodash.isequal"));
function endpointHasDiffs(endpoint) {
  return (0, _groupDiff.getEndpointDiffs)(endpoint).length > 0;
}
function isObject(a) {
  return typeof a === 'object' && a !== null && !Array.isArray(a);
}

// This function mutates and removes keys
function omitSameValueKeys(a, b) {
  const keysToOmit = new Set();
  const keysToContinue = new Set();
  if (isObject(a) && isObject(b)) {
    const clonedA = {
      ...a
    };
    const clonedB = {
      ...b
    };
    for (const key of new Set([...Object.keys(a), ...Object.keys(b)])) {
      if ((0, _lodash.default)(a[key], b[key])) {
        keysToOmit.add(key);
      } else if (isObject(a[key]) && isObject(b[key])) {
        keysToContinue.add(key);
      }
    }
    for (const key of keysToOmit) {
      delete clonedA[key];
      delete clonedB[key];
    }
    for (const key of keysToContinue) {
      const [aValue, bValue] = omitSameValueKeys(a[key], b[key]);
      clonedA[key] = aValue;
      clonedB[key] = bValue;
    }
    return [clonedA, clonedB];
  }
  return [a, b];
}
const getDetailsDiff = change => {
  if (change.changed) {
    const [before, after] = omitSameValueKeys(change.changed.before, change.changed.after);
    return [{
      key: change.key,
      change: 'changed',
      before,
      after
    }];
  }
  return [{
    key: change.key,
    ...(change.added ? {
      before: undefined,
      after: change.added,
      change: 'added'
    } : {
      before: change.removed,
      after: undefined,
      change: 'removed'
    })
  }];
};
function attachRequiredToField(specs, diff, rawChange) {
  let beforeRequired = false;
  let afterRequired = false;
  if (diff.after) {
    const parts = _jsonPointerHelpers.jsonPointerHelpers.decode(diff.after);
    const pointer = parts.slice(0, -2);
    const key = parts[parts.length - 1];
    const raw = _jsonPointerHelpers.jsonPointerHelpers.tryGet(specs.to, _jsonPointerHelpers.jsonPointerHelpers.compile([...pointer, 'required']));
    if (raw.match && Array.isArray(raw.value) && raw.value.includes(key)) {
      afterRequired = true;
    }
  }
  if (diff.before) {
    const parts = _jsonPointerHelpers.jsonPointerHelpers.decode(diff.before);
    const pointer = parts.slice(0, -2);
    const key = parts[parts.length - 1];
    const raw = _jsonPointerHelpers.jsonPointerHelpers.tryGet(specs.from, _jsonPointerHelpers.jsonPointerHelpers.compile([...pointer, 'required']));
    if (raw.match && Array.isArray(raw.value) && raw.value.includes(key)) {
      beforeRequired = true;
    }
  }
  if (rawChange.added) {
    rawChange.added = {
      ...rawChange.added,
      required: afterRequired
    };
  } else if (rawChange.changed) {
    rawChange.changed = {
      before: {
        ...rawChange.changed.before,
        required: beforeRequired
      },
      after: {
        ...rawChange.changed.after,
        required: afterRequired
      }
    };
  } else if (rawChange.removed) {
    rawChange.removed = {
      ...rawChange.removed,
      required: beforeRequired
    };
  }
}
function jsonChangelog(specs, groupedChanges) {
  const results = {
    operations: []
  };
  for (const endpoint of Object.values(groupedChanges.endpoints)) {
    if (endpointHasDiffs(endpoint)) results.operations.push(getEndpointLogs(specs, endpoint));
  }
  return results;
}
function getEndpointLogs(specs, endpointChange) {
  const {
    method,
    path,
    request,
    responses,
    cookieParameters,
    diffs,
    headerParameters,
    pathParameters,
    queryParameters
  } = endpointChange;
  const operationChange = (0, _groupDiff.typeofV3Diffs)(diffs);
  const parameterChanges = [];
  for (const [name, {
    diffs
  }] of Object.entries(queryParameters)) {
    if (diffs.length > 0) {
      parameterChanges.push(getParameterLogs(specs, {
        type: 'query',
        name,
        method,
        path
      }, diffs));
    }
  }
  for (const [name, {
    diffs
  }] of Object.entries(cookieParameters)) {
    if (diffs.length > 0) {
      parameterChanges.push(getParameterLogs(specs, {
        type: 'cookie',
        name,
        method,
        path
      }, diffs));
    }
  }
  for (const [name, {
    diffs
  }] of Object.entries(pathParameters)) {
    if (diffs.length > 0) {
      parameterChanges.push(getParameterLogs(specs, {
        type: 'path',
        name,
        method,
        path
      }, diffs));
    }
  }
  for (const [name, {
    diffs
  }] of Object.entries(headerParameters)) {
    if (diffs.length > 0) {
      parameterChanges.push(getParameterLogs(specs, {
        type: 'header',
        name,
        method,
        path
      }, diffs));
    }
  }
  const responseChanges = [];
  for (const [statusCode, response] of Object.entries(responses)) {
    const diffs = [...response.diffs, ...Object.values(response.headers).flatMap(r => r.diffs)];
    for (const content of Object.values(response.contents)) {
      diffs.push(...content.examples.diffs);
      diffs.push(...Object.values(content.fields).flatMap(r => r.diffs));
    }
    if (diffs.length > 0) {
      responseChanges.push(getResponseChangeLogs(specs, response, statusCode));
    }
  }
  const requestChangelogs = getRequestChangeLogs(specs, request);
  return {
    name: `${method} ${path}`,
    change: operationChange ?? 'changed',
    attributes: operationChange ? diffs.flatMap(diff => {
      const rawChange = getRawChange(diff, specs);
      return getDetailsDiff(rawChange);
    }) : [],
    parameters: parameterChanges,
    requestBody: requestChangelogs.attributes.length || requestChangelogs.contentTypes.length ? requestChangelogs : undefined,
    responses: responseChanges
  };
}
function getResponseChangeLogs(specs, response, statusCode) {
  const contentTypeChanges = [];
  const responseLevelDiffs = [...response.diffs];
  const responseChange = (0, _groupDiff.typeofV3Diffs)(responseLevelDiffs);
  for (const [contentType, body] of Object.entries(response.contents)) {
    if ([...body.examples.diffs, ...Object.values(body.fields).flatMap(r => r.diffs)].length > 0) {
      contentTypeChanges.push(getBodyChangeLogs(specs, body, contentType));
    }
  }
  return {
    name: `${statusCode} response`,
    change: responseChange ?? 'changed',
    attributes: responseChange ? responseLevelDiffs.flatMap(diff => {
      const rawChange = getRawChange(diff, specs);
      return getDetailsDiff(rawChange);
    }) : [],
    contentTypes: contentTypeChanges,
    headers: getResponseHeaderChangelogs(specs, response.headers)
  };
}
function getResponseHeaderChangelogs(specs, node) {
  return Object.entries(node).map(([name, node]) => {
    const change = (0, _groupDiff.typeofV3Diffs)(node.diffs) ?? 'changed';
    return {
      name: `response header ${name}`,
      change,
      attributes: change ? node.diffs.flatMap(d => {
        const rawChange = getRawChange(d, specs);
        return getDetailsDiff(rawChange);
      }) : []
    };
  });
}
function getRequestChangeLogs(specs, request) {
  const contentTypes = [];
  const requestChange = (0, _groupDiff.typeofV3Diffs)(request.diffs);
  for (const [contentType, body] of Object.entries(request.contents)) {
    if ([...body.examples.diffs, ...Object.values(body.fields).flatMap(r => r.diffs)].length > 0) {
      contentTypes.push(getBodyChangeLogs(specs, body, contentType));
    }
  }
  return {
    name: `Request Body`,
    change: requestChange ?? 'changed',
    attributes: requestChange ? request.diffs.flatMap(diff => {
      const rawChange = getRawChange(diff, specs);
      return getDetailsDiff(rawChange);
    }) : [],
    contentTypes: contentTypes
  };
}
function getBodyChangeLogs(specs, body, contentType) {
  const fieldDiffs = (0, _common.interpretFieldLevelDiffs)(specs, body.fields);
  const exampleDiffs = body.examples.diffs;

  // Group body diffs by trail and then log based on that

  const bodyChange = (0, _groupDiff.typeofV3Diffs)([...fieldDiffs, ...exampleDiffs]);
  return {
    name: `${contentType}`,
    change: bodyChange,
    attributes: bodyChange ? fieldDiffs.flatMap(diff => {
      const rawChange = getRawChange(diff, specs);
      if (diff.trail !== '') {
        attachRequiredToField(specs, diff, rawChange);
      }
      return getDetailsDiff(rawChange);
    }).concat(exampleDiffs.flatMap(diff => {
      const rawChange = getRawChange(diff, specs);
      return getDetailsDiff(rawChange);
    })) : []
  };
}
function getParameterIndices(specs, location) {
  const beforeParameters = _jsonPointerHelpers.jsonPointerHelpers.tryGet(specs.from, location.operation);
  const afterParameters = _jsonPointerHelpers.jsonPointerHelpers.tryGet(specs.to, location.operation);
  const before = beforeParameters.match ? beforeParameters.value.findIndex(p => p.name === location.name && p.in === location.type) : -1;
  const after = afterParameters.match ? afterParameters.value.findIndex(p => p.name === location.name && p.in === location.type) : -1;
  return {
    before,
    after
  };
}
function groupParameterDiffs(specs, {
  type,
  name,
  operationTrail
}, keysToGroup, diffs) {
  const groupedDiffs = [];
  const pathsToGroup = new Set();
  for (const diff of diffs) {
    const trail = diff.after ?? diff.before;
    const parts = _jsonPointerHelpers.jsonPointerHelpers.decode(trail);
    const index = parts.findIndex(p => keysToGroup.includes(p));
    if (index !== -1) {
      // /paths/:path/:method/parameters/:index
      const key = _jsonPointerHelpers.jsonPointerHelpers.compile(parts.slice(5, index + 1));
      pathsToGroup.add(key);
    } else {
      groupedDiffs.push(diff);
    }
  }
  for (const path of pathsToGroup) {
    // find the enum in both before and after
    const indices = getParameterIndices(specs, {
      operation: operationTrail,
      name,
      type
    });
    const before = _jsonPointerHelpers.jsonPointerHelpers.append(operationTrail, String(indices.before), ..._jsonPointerHelpers.jsonPointerHelpers.decode(path));
    const after = _jsonPointerHelpers.jsonPointerHelpers.append(operationTrail, String(indices.after), ..._jsonPointerHelpers.jsonPointerHelpers.decode(path));
    const beforeValue = _jsonPointerHelpers.jsonPointerHelpers.tryGet(specs.from, before);
    const afterValue = _jsonPointerHelpers.jsonPointerHelpers.tryGet(specs.to, after);
    groupedDiffs.push({
      trail: path,
      change: beforeValue.match && afterValue.match ? 'changed' : beforeValue.match ? 'removed' : 'added',
      before: beforeValue.match ? before : undefined,
      after: afterValue.match ? after : undefined
    });
  }
  return groupedDiffs;
}
function getParameterLogs(specs, {
  type,
  name,
  path,
  method
}, diffs) {
  const operationTrail = _jsonPointerHelpers.jsonPointerHelpers.compile(['paths', path, method.toLowerCase(), 'parameters']);
  return {
    name: `${type} parameter '${name}'`,
    change: (0, _groupDiff.typeofV3Diffs)(diffs),
    attributes: groupParameterDiffs(specs, {
      name,
      type,
      operationTrail
    }, ['enum'], diffs).flatMap(diff => {
      const rawChange = getRawChange(diff, specs);
      return getDetailsDiff(rawChange);
    })
  };
}
function getRawChange(diff, specs) {
  if (diff.before !== undefined && diff.after !== undefined) {
    return {
      key: diff.trail,
      changed: {
        before: _jsonPointerHelpers.jsonPointerHelpers.get(specs.from, diff.before),
        after: _jsonPointerHelpers.jsonPointerHelpers.get(specs.to, diff.after)
      }
    };
  } else if (diff.before !== undefined) {
    return {
      key: diff.trail,
      removed: _jsonPointerHelpers.jsonPointerHelpers.get(specs.from, diff.before)
    };
  } else {
    return {
      key: diff.trail,
      added: _jsonPointerHelpers.jsonPointerHelpers.get(specs.to, diff.after)
    };
  }
}