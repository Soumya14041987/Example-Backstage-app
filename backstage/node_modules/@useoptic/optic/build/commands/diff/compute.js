"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compute = compute;
exports.setGenerateContext = setGenerateContext;
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _generateRuleRunner = require("./generate-rule-runner");
var _constants = require("../../constants");
var _specLoaders = require("../../utils/spec-loaders");
var _segment = require("../../segment");
var _logger = require("../../logger");
var _groupDiff = require("@useoptic/openapi-utilities/build/openapi3/group-diff");
let generateContext = () => ({});
function setGenerateContext(fn) {
  generateContext = fn;
}
async function compute([baseFile, headFile], config, options) {
  if (baseFile.version === '2.x.x' || headFile.version === '2.x.x') {
    const warnings = [];
    if (baseFile.version === '2.x.x') warnings.push(`before file spec version 2.x.x. diffing and rule running is not supported yet`);
    if (headFile.version === '2.x.x') warnings.push(`after file spec version 2.x.x. diffing and rule running is not supported yet`);
    return {
      standard: [],
      warnings,
      specResults: {
        diffs: [],
        results: [],
        version: ''
      },
      changelogData: new _groupDiff.GroupedDiffs(),
      checks: {
        total: 0,
        passed: 0,
        exempted: 0,
        failed: {
          info: 0,
          error: 0,
          warn: 0
        }
      }
    };
  }
  const {
    runner,
    ruleNames,
    warnings,
    standard
  } = await (0, _generateRuleRunner.generateRuleRunner)({
    rulesetArg: options.standard,
    specRuleset: headFile.isEmptySpec ? baseFile.jsonLike[_constants.OPTIC_STANDARD_KEY] : headFile.jsonLike[_constants.OPTIC_STANDARD_KEY],
    config,
    specVersion: headFile.isEmptySpec ? headFile.version : baseFile.version
  }, options.check);
  (0, _segment.trackEvent)('diff.rulesets', {
    ruleset: ruleNames
  });
  let context = {};
  if (process.env.OPTIC_DIFF_CONTEXT) {
    try {
      context = JSON.parse(process.env.OPTIC_DIFF_CONTEXT);
    } catch (e) {
      _logger.logger.error('Error generating context');
      _logger.logger.error(e);
    }
  } else {
    const parsed = (0, _specLoaders.parseOpticRef)(options.path);
    const filePath = parsed.from === 'git' ? parsed.name : parsed.from === 'file' ? parsed.filePath : null;
    if (filePath) {
      try {
        context = generateContext(filePath);
      } catch (e) {
        _logger.logger.error('Error generating context');
        _logger.logger.error(e);
      }
    }
  }
  const specResults = await (0, _openapiUtilities.compareSpecs)(baseFile, headFile, runner, context);
  const changelogData = (0, _openapiUtilities.groupDiffsByEndpoint)({
    from: baseFile.jsonLike,
    to: headFile.jsonLike
  }, specResults.diffs, specResults.results);
  return {
    standard,
    warnings,
    specResults,
    changelogData,
    checks: {
      total: specResults.results.length,
      passed: specResults.results.filter(check => check.passed).length,
      exempted: specResults.results.filter(check => !check.passed && check.exempted).length,
      failed: {
        info: specResults.results.filter(check => !check.passed && !check.exempted && check.severity === _openapiUtilities.Severity.Info).length,
        error: specResults.results.filter(check => !check.passed && !check.exempted && check.severity === _openapiUtilities.Severity.Error).length,
        warn: specResults.results.filter(check => !check.passed && !check.exempted && check.severity === _openapiUtilities.Severity.Warn).length
      }
    }
  };
}