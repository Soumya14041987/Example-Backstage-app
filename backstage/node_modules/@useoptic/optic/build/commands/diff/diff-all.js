"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchSpecCandidates = matchSpecCandidates;
exports.registerDiffAll = void 0;
var _commander = require("commander");
var _micromatch = _interopRequireDefault(require("micromatch"));
var _fastGlob = _interopRequireDefault(require("fast-glob"));
var _config = require("../../config");
var Git = _interopRequireWildcard(require("../../utils/git-utils"));
var _specLoaders = require("../../utils/spec-loaders");
var _logger = require("../../logger");
var _constants = require("../../constants");
var _compute = require("./compute");
var _chalk = _interopRequireDefault(require("chalk"));
var _segment = require("../../segment");
var _compressResults = require("./compressResults");
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _cloudUrls = require("../../utils/cloud-urls");
var _ciData = require("../../utils/ci-data");
var _errorHandler = require("../../error-handler");
var _openapiIo = require("@useoptic/openapi-io");
var _path = _interopRequireDefault(require("path"));
var _terminalChangelog = require("./changelog-renderers/terminal-changelog");
var _jsonChangelog = require("./changelog-renderers/json-changelog");
var _openUrl = require("../../utils/open-url");
var _renderCloud = require("../../utils/render-cloud");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const usage = () => `
  optic diff-all
  optic diff-all --compare-from main --compare-to feat/new-api --check --web --standard @org/example-standard`;
const helpText = `
Example usage:
  Diff all specs with \`x-optic-url\` in the current repo against HEAD~1
  $ optic diff-all

  Diff all specs with \`x-optic-url\` in the current repo from main to feature/1
  $ optic diff-all --compare-from main --compare-to feature/1

  Diff all specs with a standard, run checks and open up in a web browser
  $ optic diff-all --standard @org/example-standard --web --check
  `;
const registerDiffAll = (cli, config, options) => {
  cli.command('diff-all').configureHelp({
    commandUsage: usage
  }).addHelpText('after', helpText).description('Run a diff on all specs with `x-optic-url`').option('--compare-to <compare-to>', 'the head ref to compare against. Defaults to the current working directory').option('--compare-from <compare-from>', 'the base ref to compare against. Defaults to HEAD~1. Also supports optic cloud tags (cloud:tag_name)', 'HEAD~1').option('--head-tag <head-tag>', 'Adds additional tags to the HEAD spec. Should be used in conjunction with `--upload`').option('--match <match>', 'a glob to match specs (e.g. "**/*.yml" or "**/specifications/*.json"). Also takes \
      comma separated values (e.g. "**/*.yml,**/*.json")').option('--ignore <ignore>', 'an ignore glob to ignore certain matches (e.g. "**/*.yml" or "**/specifications/*.json"). Also takes \
comma separated values (e.g. "**/*.yml,**/*.json")').option('--standard <standard>', 'run comparison with a locally defined standard, if not set, looks for the standard on the [x-optic-standard] key on the spec, and then the optic.dev.yml file.').addOption(new _commander.Option('--validation <validation>', 'specify the level of validation on HEAD specs').choices(['strict', 'loose']).default('strict')).addOption(new _commander.Option('--severity <severity>', 'specify the severity level to exit with exit code, options are error, warn and info').choices(['error', 'warn', 'info']).default('error')).option('--check', 'enable checks', false).option('--upload', 'upload specs', false).option('--web', 'view the diff in the optic changelog web view', false).option('--json', 'output as json', false).option('--generated', "[deprecated] Optic doesn't make a difference between generated and non generated specifications anymore").option('--fail-on-untracked-openapi', '[deprecated] all matching APIs are now added by default', false).action((0, _errorHandler.errorHandler)(getDiffAllAction(config, options), {
    command: 'diff-all'
  }));
};
exports.registerDiffAll = registerDiffAll;
function getCandidatesFromCloudTag(tag, to, root) {
  const results = new Map();
  for (const toPath of to.paths) {
    const hasRef = to.ref && toPath.startsWith(`${to.ref}:`);
    const strippedPath = hasRef ? toPath.replace(`${to.ref}:`, '') : toPath;
    const pathFromRoot = _path.default.relative(root, strippedPath);
    const refAndPathFromRoot = hasRef ? `${to.ref}:${pathFromRoot}` : toPath;
    results.set(pathFromRoot, {
      from: tag,
      to: refAndPathFromRoot
    });
  }
  return results;
}

// Match up the to and from candidates
// This will return the comparisons we can try to run
function matchCandidates(from, to, root) {
  const results = new Map();
  for (const fromPath of from.paths) {
    const strippedPath = fromPath.replace(`${from.ref}:`, '');
    const pathFromRoot = _path.default.relative(root, strippedPath);
    results.set(pathFromRoot, {
      from: `${from.ref}:${pathFromRoot}`
    });
  }
  for (const toPath of to.paths) {
    const hasRef = to.ref && toPath.startsWith(`${to.ref}:`);
    const strippedPath = hasRef ? toPath.replace(`${to.ref}:`, '') : toPath;
    const pathFromRoot = _path.default.relative(root, strippedPath);
    const refAndPathFromRoot = hasRef ? `${to.ref}:${pathFromRoot}` : toPath;
    const maybePathObject = results.get(pathFromRoot);
    if (maybePathObject) {
      maybePathObject.to = refAndPathFromRoot;
    } else {
      results.set(pathFromRoot, {
        to: refAndPathFromRoot
      });
    }
  }
  return results;
}
async function computeAll(candidateMap, config, options, customOptions) {
  const allWarnings = {
    missingOpticUrl: [],
    unparseableFromSpec: [],
    unparseableToSpec: []
  };
  const results = [];
  const comparisons = new Map();
  for await (const [candidatePath, candidate] of candidateMap) {
    var _rawSpec;
    // We load the raw spec and discard the comparison if there is no optic url or is in an invalid version
    // Cases we run the comparison:
    // - if to spec has x-optic-url
    // - if from spec has x-optic-url AND to spec is empty
    const specPathToLoad = candidate.to ?? candidate.from;
    if (!specPathToLoad) {
      _logger.logger.debug(`Skipping comparison from ${candidate.from} to ${candidate.to} both are undefined`);
      continue;
    }
    let rawSpec;
    try {
      rawSpec = await (0, _specLoaders.loadRaw)(specPathToLoad, config);
    } catch (e) {
      if (e instanceof Error && e['probablySpec']) {
        _logger.logger.error(`Error parsing ${specPathToLoad}:`);
        _logger.logger.error(e.message);
        process.exitCode = 1;
      }
      _logger.logger.debug(`Skipping comparison from ${candidate.from} to ${candidate.to} because parsing failed`);
      _logger.logger.debug(e);
      continue;
    }
    const opticUrl = rawSpec[_constants.OPTIC_URL_KEY];
    const name = (_rawSpec = rawSpec) === null || _rawSpec === void 0 || (_rawSpec = _rawSpec.info) === null || _rawSpec === void 0 ? void 0 : _rawSpec.title;
    try {
      (0, _openapiIo.checkOpenAPIVersion)(rawSpec);
    } catch (e) {
      _logger.logger.debug(`Skipping comparison from ${candidate.from} to ${candidate.to} because of error: `);
      _logger.logger.debug(e);
      continue;
    }
    comparisons.set(candidatePath, {
      from: candidate.from,
      to: candidate.to,
      opticUrl,
      name
    });
  }
  for (let {
    from,
    to,
    opticUrl
  } of comparisons.values()) {
    var _config$vcs;
    const cloudTag = !!from && /^cloud:/.test(from) ? from.replace(/^cloud:/, '') : null;
    const specDetails = (0, _cloudUrls.getApiFromOpticUrl)(opticUrl);
    if (!specDetails && (options.upload || cloudTag)) {
      _logger.logger.debug(`Skipping comparison from ${from} to ${to} because there was no x-optic-url`);
      allWarnings.missingOpticUrl.push({
        path: to
      });
      continue;
    } else if (specDetails && cloudTag) {
      from = `cloud:${specDetails.apiId}@${cloudTag}`;
    }

    // try load both from + to spec
    let fromParseResults;
    let toParseResults;
    try {
      fromParseResults = await (0, _specLoaders.loadSpec)(from, config, {
        strict: false,
        denormalize: true
      });
    } catch (e) {
      allWarnings.unparseableFromSpec.push({
        path: from,
        error: e
      });
      continue;
    }
    try {
      toParseResults = await (0, _specLoaders.loadSpec)(to, config, {
        strict: options.validation === 'strict',
        denormalize: true
      });
    } catch (e) {
      allWarnings.unparseableToSpec.push({
        path: to,
        error: e
      });
      continue;
    }
    if (fromParseResults.version === '2.x.x' || toParseResults.version === '2.x.x') {
      _logger.logger.error('Swagger 2 is not supported');
      fromParseResults.version === '2.x.x' && allWarnings.unparseableFromSpec.push({
        path: from,
        error: new Error('Swagger 2 is not supported')
      });
      toParseResults.version === '2.x.x' && allWarnings.unparseableToSpec.push({
        path: to,
        error: new Error('Swagger 2 is not supported')
      });
      continue;
    }
    _logger.logger.info(_chalk.default.blue(`Diffing ${from ?? 'empty spec'} to ${to ?? 'empty spec'}`));
    const {
      specResults,
      checks,
      changelogData,
      warnings,
      standard
    } = await (0, _compute.compute)([fromParseResults, toParseResults], config, {
      ...options,
      path: to ?? from ?? null
    });
    for (const warning of warnings) {
      _logger.logger.warn(warning);
    }
    _logger.logger.info('');
    let changelogUrl = null;
    let specUrl = null;
    if (options.upload) {
      if (customOptions.customUpload) {
        await customOptions.customUpload(toParseResults);
      } else {
        console.log('upload diff is no longer supported');
        specUrl = null;
        changelogUrl = null;
      }
    }
    let sourcemapOptions = {
      ciProvider: undefined
    };
    if (config.isInCi && ((_config$vcs = config.vcs) === null || _config$vcs === void 0 ? void 0 : _config$vcs.type) === _config.VCS.Git) {
      const remote = await Git.guessRemoteOrigin();
      if (remote) {
        sourcemapOptions = {
          ciProvider: remote.provider,
          remote: remote.web_url,
          sha: config.vcs.sha,
          root: config.root
        };
      }
    }
    for (const log of (0, _terminalChangelog.terminalChangelog)({
      from: fromParseResults,
      to: toParseResults
    }, changelogData, specResults, {
      ...sourcemapOptions,
      path: to ?? from ?? '',
      check: options.check,
      inCi: config.isInCi,
      output: 'pretty',
      verbose: false,
      severity: (0, _openapiUtilities.textToSev)(options.severity),
      previewDocsLink: specUrl
    })) {
      _logger.logger.info(log);
    }
    results.push({
      warnings,
      fromParseResults,
      toParseResults,
      specResults,
      checks,
      changelogData,
      from,
      to,
      changelogUrl,
      specUrl,
      standard
    });
  }
  return {
    warnings: allWarnings,
    results
  };
}
function handleWarnings(warnings, options, isCloudDiff) {
  if (warnings.missingOpticUrl.length > 0) {
    _logger.logger.info(_chalk.default.yellow(`Warning - the following OpenAPI specs were detected but did not have valid x-optic-url keys. ${isCloudDiff ? `optic diff-all --compare-from cloud:{tag}' can only runs on specs that have been added to optic` : `'optic diff-all --upload' can only runs on specs that have been added to optic`}`));
    _logger.logger.info('');
    _logger.logger.info('Run the `optic api add` command to add these specs to optic');
    _logger.logger.info(warnings.missingOpticUrl.map(f => `${f.path} ${_chalk.default.red('(untracked)')}`).join('\n'));
    _logger.logger.info('');
  }
  if (warnings.unparseableFromSpec.length > 0) {
    _logger.logger.error(_chalk.default.red(`Error - the following specs could not be parsed from the ref ${options.compareFrom}`));
    for (const unparseableFrom of warnings.unparseableFromSpec) {
      _logger.logger.error(`spec: ${unparseableFrom.path}`);
      _logger.logger.error(unparseableFrom.error.message);
      _logger.logger.error('');
    }
  }
  if (warnings.unparseableToSpec.length > 0) {
    _logger.logger.error(_chalk.default.red(`Error - the following specs could not be parsed from the ${options.compareTo ? `ref ${options.compareTo}` : 'current working directory'}`));
    for (const unparseableTo of warnings.unparseableToSpec) {
      _logger.logger.error(`spec: ${unparseableTo.path}`);
      _logger.logger.error(unparseableTo.error.message);
      _logger.logger.error('');
    }
    process.exitCode = 1;
  }
}
async function openWebpage(url, {
  fromParseResults,
  toParseResults,
  specResults,
  changelogData
}, config) {
  const analyticsData = {
    isInCi: config.isInCi
  };
  if (!url) {
    const meta = {
      createdAt: new Date(),
      command: ['optic', ...process.argv.slice(2)].join(' ')
    };
    const compressedData = (0, _compressResults.compressDataV2)(fromParseResults, toParseResults, specResults, meta, changelogData);
    analyticsData.compressedDataLength = compressedData.length;
    const baseHtml = _path.default.resolve(__dirname, '../../../web/build/index.html');
    url = `${baseHtml}#${compressedData}`;
  }
  (0, _segment.trackEvent)('optic.diff_all.view_web', analyticsData);
  await (0, _openUrl.openUrl)(url);
}
function sanitizeRef(maybeGitRef) {
  return maybeGitRef.includes(':') ? maybeGitRef.split(':')[1] : maybeGitRef;
}
async function matchSpecCandidates(matchesOption, ignoresOption) {
  const matches = (matchesOption === null || matchesOption === void 0 ? void 0 : matchesOption.split(',').filter(g => g !== '')) ?? [];
  const ignores = (ignoresOption === null || ignoresOption === void 0 ? void 0 : ignoresOption.split(',').filter(g => g !== '')) ?? [];
  const candidates = await (0, _fastGlob.default)(matches, {
    ignore: ignores
  });
  return candidates.filter(c => /\.(json|ya?ml)$/i.test(c));
}
function applyGlobFilter(filePaths, globs) {
  var _globs$matches, _globs$ignores;
  const matches = ((_globs$matches = globs.matches) === null || _globs$matches === void 0 ? void 0 : _globs$matches.split(',').filter(g => g !== '')) ?? [];
  const ignores = ((_globs$ignores = globs.ignores) === null || _globs$ignores === void 0 ? void 0 : _globs$ignores.split(',').filter(g => g !== '')) ?? [];
  const globMatchers = matches.map(g => _micromatch.default.matcher(g));
  const ignoreMatchers = ignores.map(i => _micromatch.default.matcher(i));
  const matchedFiles = new Set(filePaths.filter(name => globMatchers.length === 0 ? true : globMatchers.some(globFilter => globFilter(sanitizeRef(name)))).filter(name => ignoreMatchers.every(ignoreFilter => !ignoreFilter(sanitizeRef(name)))));
  return [...matchedFiles];
}
const getDiffAllAction = (config, customOptions) => async options => {
  var _config$vcs2, _config$vcs3;
  if (options.generated) {
    _logger.logger.warn(_chalk.default.yellow.bold(`the --generated option is deprecated, diff-all works without the --generated option`));
  }
  if (options.failOnUntrackedOpenapi) {
    _logger.logger.warn(_chalk.default.yellow.bold(`the --fail-on-untracked-openapi option is deprecated, all matching APIs are now tracked by default`));
  }
  if (((_config$vcs2 = config.vcs) === null || _config$vcs2 === void 0 ? void 0 : _config$vcs2.type) !== _config.VCS.Git) {
    _logger.logger.error(`Error: optic diff-all must be called from a git repository.`);
    process.exitCode = 1;
    return;
  } else if (options.upload && !config.isAuthenticated && !customOptions.customUpload) {
    _logger.logger.error(_chalk.default.bold.red('Error: Must be logged in to upload results. Run optic login to authenticate.'));
    process.exitCode = 1;
    return;
  }
  if (options.json) {
    // For json output we only want to render json
    _logger.logger.setLevel('silent');
  }
  let candidateMap;
  let compareToCandidates;
  try {
    if (!options.compareTo && options.match) {
      compareToCandidates = await matchSpecCandidates(options.match, options.ignore);
    } else {
      options.compareTo && (await Git.assertRefExists(options.compareTo));
      compareToCandidates = await Git.findOpenApiSpecsCandidates(options.compareTo);
    }
  } catch (e) {
    _logger.logger.error(`Error reading files from git history for --compare-to ${options.compareTo}`);
    _logger.logger.error(e);
    process.exitCode = 1;
    return;
  }
  if (/^cloud:/.test(options.compareFrom)) {
    candidateMap = getCandidatesFromCloudTag(options.compareFrom, {
      ref: options.compareTo,
      paths: applyGlobFilter(compareToCandidates, {
        matches: options.match,
        ignores: options.ignore
      })
    }, config.root);
  } else {
    let compareFromCandidates;
    try {
      await Git.assertRefExists(options.compareFrom);
      compareFromCandidates = await Git.findOpenApiSpecsCandidates(options.compareFrom);
    } catch (e) {
      _logger.logger.error(`Error reading files from git history for --compare-from ${options.compareFrom}`);
      _logger.logger.error(e);
      process.exitCode = 1;
      return;
    }
    candidateMap = matchCandidates({
      ref: options.compareFrom,
      paths: applyGlobFilter(compareFromCandidates, {
        matches: options.match,
        ignores: options.ignore
      })
    }, {
      ref: options.compareTo,
      paths: applyGlobFilter(compareToCandidates, {
        matches: options.match,
        ignores: options.ignore
      })
    }, config.root);
  }
  const {
    warnings,
    results
  } = await computeAll(candidateMap, config, options, customOptions);
  for (const result of results) {
    const {
      specResults,
      changelogUrl
    } = result;
    if (options.web && (specResults.diffs.length > 0 || !options.check && specResults.results.length > 0)) {
      openWebpage(changelogUrl, result, config);
    }
  }
  const isCloudDiff = /^cloud:/.test(options.compareFrom);
  handleWarnings(warnings, options, isCloudDiff);
  if (config.isInCi) {
    const errors = [...warnings.unparseableFromSpec.map(spec => ({
      name: spec.path,
      error: `Could not parse spec ${spec.path} from the ref ${options.compareFrom}

${spec.error.message}`
    })), ...warnings.unparseableToSpec.map(spec => ({
      name: spec.path,
      error: `Could not parse spec ${spec.path}

${spec.error.message}`
    }))];
    const completedComparisons = results.map(result => ({
      warnings: result.warnings,
      groupedDiffs: result.changelogData,
      results: result.specResults.results,
      name: result.to ?? result.from ?? 'Unknown comparison',
      specUrl: result.specUrl,
      changelogUrl: result.changelogUrl
    }));
    await (0, _ciData.writeDataForCi)([...completedComparisons, ...errors], {
      severity: (0, _openapiUtilities.textToSev)(options.severity)
    });
  }
  const comparisonsWithResults = results.filter(result => result.specResults.diffs.length > 0 || !options.check && result.specResults.results.length > 0);
  const maybeOrigin = ((_config$vcs3 = config.vcs) === null || _config$vcs3 === void 0 ? void 0 : _config$vcs3.type) === _config.VCS.Git ? await Git.guessRemoteOrigin() : null;
  for (const result of results) {
    const filePath = result.to ?? result.from;
    const relativePath = _path.default.relative(config.root, _path.default.resolve(filePath));
    (0, _segment.trackEvent)('optic.diff.completed', {
      specPath: relativePath,
      diffs: result.specResults.diffs.length,
      checks: result.specResults.results.length,
      isCloudRun: options.upload,
      isInCi: config.isInCi,
      ...(maybeOrigin !== null && maybeOrigin !== void 0 && maybeOrigin.web_url ? {
        webUrlAndPath: `${maybeOrigin.web_url}.${relativePath}`,
        webUrl: maybeOrigin.web_url
      } : {})
    });
  }
  (0, _segment.trackEvent)('optic.diff-all.completed', {
    numberOfComparisonsWithResults: comparisonsWithResults.length,
    numberOfComparisons: results.length,
    isInCi: config.isInCi,
    webUrl: maybeOrigin === null || maybeOrigin === void 0 ? void 0 : maybeOrigin.web_url
  });
  if (options.json) {
    // Needs to be a console.log call to render over the logger.level
    console.log(JSON.stringify({
      results: results.reduce((acc, next) => {
        var _next$to;
        const strippedPath = next.from ? next.from.replace(`${options.compareFrom}:`, '') : ((_next$to = next.to) === null || _next$to === void 0 ? void 0 : _next$to.replace(`${options.compareTo}:`, '')) ?? 'empty diff';
        acc[strippedPath] = (0, _jsonChangelog.jsonChangelog)({
          from: next.fromParseResults.jsonLike,
          to: next.toParseResults.jsonLike
        }, next.changelogData);
        return acc;
      }, {}),
      warnings
    }));
  }
  if (results.length === 0) {
    _logger.logger.error(_chalk.default.red.bold('No OpenAPI specs were detected - exiting with error code 1'));
    process.exitCode = 1;
  } else if (!config.isInCi) {
    if (options.check) {
      _logger.logger.info(`Configure check standards in optic cloud or your local optic.dev.yml file.`);
    }
    if (!options.web) {
      _logger.logger.info(_chalk.default.blue(`Rerun this command with the --web flag to view the detailed changes in your browser`));
    }
  }
  await (0, _segment.flushEvents)();
  if (config.isInCi && !options.upload) (0, _renderCloud.renderCloudSetup)();
  if (results.some(result => {
    const failures = result.checks.failed;
    const failuresForSeverity = options.severity === 'error' ? failures.error : options.severity === 'warn' ? failures.warn + failures.error : failures.warn + failures.error + failures.info;
    return failuresForSeverity > 0;
  }) && options.check) process.exitCode = 1;
};