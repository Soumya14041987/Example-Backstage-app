"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerDiff = void 0;
var _commander = require("commander");
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _specLoaders = require("../../utils/spec-loaders");
var _config = require("../../config");
var _chalk = _interopRequireDefault(require("chalk"));
var _segment = require("../../segment");
var _terminalChangelog = require("./changelog-renderers/terminal-changelog");
var _jsonChangelog = require("./changelog-renderers/json-changelog");
var _compute = require("./compute");
var _compressResults = require("./compressResults");
var _ciData = require("../../utils/ci-data");
var _logger = require("../../logger");
var _errorHandler = require("../../error-handler");
var _path = _interopRequireDefault(require("path"));
var Git = _interopRequireWildcard(require("../../utils/git-utils"));
var GitCandidates = _interopRequireWildcard(require("../api/git-get-file-candidates"));
var _jsonStableStringify = _interopRequireDefault(require("json-stable-stringify"));
var _checksum = require("../../utils/checksum");
var _openUrl = require("../../utils/open-url");
var _spinner = require("../../utils/spinner");
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _os = _interopRequireDefault(require("os"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const description = 'Run a diff between two API specs';
const usage = () => `
  optic diff [file] --base <base>
  optic diff [file1] [file2]
  optic diff [file1] [file2] --check`;
const helpText = `
Examples:
  Diff \`specs/openapi-spec.yml\` against master
  $ optic diff openapi-spec.yml --base master

  Diff \`openapi-spec-v0.yml\` against \`openapi-spec-v1.yml\`
  $ optic diff openapi-spec-v0.yml openapi-spec-v1.yml

  Run a diff and check the changes against the detected standard (looks at --standard, then 'x-optic-standard' in the spec, then the optic.dev.yml file)):
  $ optic diff openapi-spec-v0.yml openapi-spec-v1.yml --check

  Specify a different standard config to run against
  $ optic diff openapi-spec-v0.yml openapi-spec-v1.yml --check --standard ./other_config.yml
  `;
const registerDiff = (cli, config, options) => {
  cli.command('diff').configureHelp({
    commandUsage: usage
  }).addHelpText('after', helpText).description(description).argument('[file1]', 'Path to file to compare with').argument('[file2]', 'Path to file to compare').addOption(new _commander.Option('-b, --base <base>', 'The base ref to compare against, also supports optic cloud tags (cloud:tag_name)').default('HEAD')).option('-S, --standard <standard>', 'Run comparison with a locally defined standard, if not set, looks for the standard on the [x-optic-standard] key in the spec and then the optic.dev.yml file').option('-H, --head-tag <head-tag>', 'Adds additional tags to the HEAD spec, used in conjunction with `--upload`').addOption(new _commander.Option('--ruleset <ruleset>', '').hideHelp()).addOption(new _commander.Option('-s, --severity <severity>', 'Specify the severity level to exit with exit code: info=0, warn=1, error=2').choices(['info', 'warn', 'error']).default('error')).addOption(new _commander.Option('-v, --validation <validation>', 'Specify the level of validation to run').choices(['strict', 'loose']).default('strict')).option('-c, --check', 'Enable checks', true).option('-u, --upload', 'Upload run to cloud', false).option('-w, --web', 'View the diff in the Optic changelog web view', false).option('-o, --out <file>', 'write a self-contained HTML diff. use with --web').option('--json', 'Output as json', false).option('--last-change', 'Find the last change for this spec', false).option('--generated', '[deprecated] Optic no longer differentiates generated and non-generated specifications').action((0, _errorHandler.errorHandler)(getDiffAction(config, options), {
    command: 'diff'
  }));
};
exports.registerDiff = registerDiff;
const getHeadAndLastChanged = async (file, config, options) => {
  try {
    const absolutePath = _path.default.resolve(file);
    const pathRelativeToRoot = _path.default.relative(config.root, absolutePath);
    let shaWithChange = null;
    let baseFile = await (0, _specLoaders.loadSpec)('null:', config, {
      strict: false,
      denormalize: true
    });
    const headFile = await (0, _specLoaders.loadSpec)(file, config, {
      strict: options.validation === 'strict',
      denormalize: true
    });
    const stableSpecString = (0, _jsonStableStringify.default)(headFile.jsonLike);
    const headChecksum = (0, _checksum.computeChecksumForAws)(stableSpecString);
    const candidates = await GitCandidates.getShasCandidatesForPath(file, '0');
    for (const sha of candidates.shas) {
      const baseFileForSha = await (0, _specLoaders.loadSpec)(`${sha}:${pathRelativeToRoot}`, config, {
        strict: false,
        denormalize: true
      });
      const stableSpecString = (0, _jsonStableStringify.default)(baseFileForSha.jsonLike);
      const baseChecksum = (0, _checksum.computeChecksumForAws)(stableSpecString);
      if (baseChecksum !== headChecksum) {
        shaWithChange = sha;
        baseFile = baseFileForSha;
        break;
      }
    }
    const specDetails = null;
    return {
      specs: [baseFile, headFile, specDetails],
      meta: {
        sha: shaWithChange
      }
    };
  } catch (e) {
    throw new _openapiUtilities.UserError({
      initialError: e instanceof Error ? e : undefined
    });
  }
};
const getBaseAndHeadFromFiles = async (file1, file2, config, options) => {
  try {
    const [baseFile, headFile] = await Promise.all([(0, _specLoaders.loadSpec)(file1, config, {
      strict: options.validation === 'strict',
      denormalize: true
    }), (0, _specLoaders.loadSpec)(file2, config, {
      strict: options.validation === 'strict',
      denormalize: true
    })]);
    const specDetails = null;
    return [baseFile, headFile, specDetails];
  } catch (e) {
    throw new _openapiUtilities.UserError({
      initialError: e instanceof Error ? e : undefined
    });
  }
};
const getBaseAndHeadFromFileAndBase = async (file1, base, root, config, options) => {
  try {
    if (/^cloud:/.test(base)) {
      throw new Error('cloud refs are not supported');
    } else {
      const {
        baseFile,
        headFile
      } = await (0, _specLoaders.parseFilesFromRef)(file1, base, root, config, {
        denormalize: true,
        headStrict: options.validation === 'strict'
      });
      const specDetails = null;
      return [baseFile, headFile, specDetails];
    }
  } catch (e) {
    throw new _openapiUtilities.UserError({
      initialError: e instanceof Error ? e : undefined
    });
  }
};
const runDiff = async ([baseFile, headFile], config, options, filepath) => {
  const {
    specResults,
    checks,
    changelogData,
    warnings,
    standard
  } = await (0, _compute.compute)([baseFile, headFile], config, {
    ...options,
    path: filepath
  });
  return {
    checks,
    specResults,
    changelogData,
    warnings,
    standard
  };
};
const getDiffAction = (config, customOptions) => async (file1, file2, options) => {
  var _config$vcs4;
  if (options.generated) {
    _logger.logger.warn(_chalk.default.yellow.bold(`the --generated option is deprecated, diff works without the --generated option`));
  }
  if (options.json) {
    // For json output we only want to render json
    _logger.logger.setLevel('silent');
  }
  if (options.upload && !config.isAuthenticated && !customOptions.customUpload) {
    _logger.logger.error(_chalk.default.bold.red('Error: Must be logged in to upload results. Run optic login to authenticate.'));
    return;
  }
  if (options.ruleset && !options.standard) {
    options.standard = options.ruleset;
  }
  let parsedFiles;
  if (file1 && options.lastChange) {
    var _config$vcs;
    if (((_config$vcs = config.vcs) === null || _config$vcs === void 0 ? void 0 : _config$vcs.type) !== _config.VCS.Git) {
      const commandVariant = `optic diff <file> --last-change`;
      _logger.logger.error(`Error: ${commandVariant} must be called from a git repository.`);
      process.exitCode = 1;
      return;
    }
    const spinner = (0, _spinner.getSpinner)({
      text: `Finding last change...`,
      color: 'blue'
    });
    spinner === null || spinner === void 0 || spinner.start();
    const {
      meta: {
        sha
      },
      specs
    } = await getHeadAndLastChanged(file1, config, options);
    parsedFiles = specs;
    spinner === null || spinner === void 0 || spinner.succeed(sha ? `Found last change at ${sha}` : 'No changes found, comparing against an empty spec');
  } else if (file1 && file2) {
    parsedFiles = await getBaseAndHeadFromFiles(file1, file2, config, options);
  } else if (file1) {
    var _config$vcs2;
    if (((_config$vcs2 = config.vcs) === null || _config$vcs2 === void 0 ? void 0 : _config$vcs2.type) !== _config.VCS.Git) {
      const commandVariant = `optic diff <file> --base <ref>`;
      _logger.logger.error(`Error: ${commandVariant} must be called from a git repository.`);
      process.exitCode = 1;
      return;
    }
    parsedFiles = await getBaseAndHeadFromFileAndBase(file1, options.base, config.root, config, options);
  } else {
    _logger.logger.error('Command removed: optic diff (no args) has been removed, please use optic diff <file_path> --base <base> instead');
    process.exitCode = 1;
    return;
  }
  if (parsedFiles[0].version === '2.x.x' || parsedFiles[1].version === '2.x.x') {
    _logger.logger.error('Swagger 2 is not supported');
    process.exitCode = 1;
    return;
  }
  const diffResult = await runDiff(parsedFiles, config, options, file1);
  let maybeChangelogUrl = null;
  let indexPath = null;
  let compressedData = null;
  let specUrl = null;
  let [baseParseResult, headParseResult, specDetails] = parsedFiles;
  if (options.upload) {
    if (customOptions.customUpload) {
      await customOptions.customUpload(headParseResult);
    } else {
      console.log('upload diff is no longer supported');
      specUrl = null;
      maybeChangelogUrl = null;
    }
  }
  if (options.json) {
    console.log(JSON.stringify((0, _jsonChangelog.jsonChangelog)({
      from: baseParseResult.jsonLike,
      to: headParseResult.jsonLike
    }, diffResult.changelogData)));
  } else {
    var _config$vcs3;
    for (const warning of diffResult.warnings) {
      _logger.logger.warn(warning);
    }
    let sourcemapOptions = {
      ciProvider: undefined
    };
    if (config.isInCi && ((_config$vcs3 = config.vcs) === null || _config$vcs3 === void 0 ? void 0 : _config$vcs3.type) === _config.VCS.Git) {
      const remote = await Git.guessRemoteOrigin();
      if (remote) {
        sourcemapOptions = {
          ciProvider: remote.provider,
          remote: remote.web_url,
          sha: config.vcs.sha,
          root: config.root
        };
      }
    }
    for (const log of (0, _terminalChangelog.terminalChangelog)({
      from: baseParseResult,
      to: headParseResult
    }, diffResult.changelogData, diffResult.specResults, {
      ...sourcemapOptions,
      path: file1,
      check: options.check,
      inCi: config.isInCi,
      output: 'pretty',
      verbose: false,
      severity: (0, _openapiUtilities.textToSev)(options.severity),
      previewDocsLink: specUrl
    })) {
      _logger.logger.info(log);
    }
  }
  if (options.web) {
    if (diffResult.specResults.diffs.length === 0 && (!options.check || diffResult.specResults.results.length === 0)) {
      _logger.logger.info('Empty changelog: not opening web view');
    } else {
      const analyticsData = {
        isInCi: config.isInCi
      };
      if (!maybeChangelogUrl) {
        const meta = {
          createdAt: new Date(),
          command: ['optic', ...process.argv.slice(2)].join(' '),
          file1,
          file2,
          base: options.base
        };
        compressedData = (0, _compressResults.compressDataV2)(baseParseResult, headParseResult, diffResult.specResults, meta, diffResult.changelogData);
        analyticsData.compressedDataLength = compressedData.length;
        const copyPath = _path.default.join(_os.default.tmpdir(), 'optic-changelog');

        // This steps is for supporting versions of Optic that use pkg to compile all assets into a binary. Copies it from the virtual file system into userland
        await _fsExtra.default.copy(_path.default.resolve(_path.default.join(__dirname, '../../../web/build')), copyPath, {
          errorOnExist: false,
          overwrite: false
        });
        indexPath = _path.default.join(_path.default.resolve(_path.default.join(__dirname, '../../../web/build')), 'index.html');
        const baseHtml = _path.default.resolve(indexPath);
        maybeChangelogUrl = `${baseHtml}#${compressedData}`;
        await (0, _segment.flushEvents)();
      }
      (0, _segment.trackEvent)('optic.diff.view_web', analyticsData);
      if (options.out && indexPath) {
        const indexContents = (await _fsExtra.default.readFile(indexPath)).toString();
        const newContents = indexContents.replace(`<div id="root"></div>`, `<div id="root"></div><script>window.diffData ='${compressedData}'</script>`);
        const out = _path.default.resolve(process.cwd(), options.out);
        _logger.logger.info('Diff HTML written to ' + out);
        await _fsExtra.default.writeFile(out, newContents);
      } else {
        _logger.logger.info('Opening up diff in web view');
        await (0, _openUrl.openUrl)(maybeChangelogUrl);
      }
    }
  }
  if (config.isInCi) {
    await (0, _ciData.writeDataForCi)([{
      warnings: diffResult.warnings,
      groupedDiffs: diffResult.changelogData,
      name: file1,
      results: diffResult.specResults.results,
      specUrl,
      changelogUrl: maybeChangelogUrl
    }], {
      severity: (0, _openapiUtilities.textToSev)(options.severity)
    });
  } else if (!options.web && !options.json) {
    _logger.logger.info(_chalk.default.blue(`Rerun this command with the --web flag to view the detailed changes in your browser`));
  }
  const maybeOrigin = ((_config$vcs4 = config.vcs) === null || _config$vcs4 === void 0 ? void 0 : _config$vcs4.type) === _config.VCS.Git ? await Git.guessRemoteOrigin() : null;
  const relativePath = _path.default.relative(config.root, _path.default.resolve(file1));
  (0, _segment.trackEvent)('optic.diff.completed', {
    specPath: relativePath,
    diffs: diffResult.specResults.diffs.length,
    checks: diffResult.specResults.results.length,
    isCloudRun: options.upload,
    isInCi: config.isInCi,
    ...(maybeOrigin !== null && maybeOrigin !== void 0 && maybeOrigin.web_url ? {
      webUrlAndPath: `${maybeOrigin.web_url}.${relativePath}`,
      webUrl: maybeOrigin.web_url
    } : {})
  });
  const failures = diffResult.checks.failed;
  const failuresForSeverity = options.severity === 'error' ? failures.error : options.severity === 'warn' ? failures.warn + failures.error : failures.warn + failures.error + failures.info;
  if (failuresForSeverity > 0 && options.check) process.exitCode = 1;
};