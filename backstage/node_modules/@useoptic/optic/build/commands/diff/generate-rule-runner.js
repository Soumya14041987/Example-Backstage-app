"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateRuleRunner = void 0;
exports.setRulesets = setRulesets;
var _path = _interopRequireDefault(require("path"));
var _config = require("../../config");
var _standardRulesets = require("@useoptic/standard-rulesets");
var _rulesetsBase = require("@useoptic/rulesets-base");
var _logger = require("../../logger");
var _chalk = _interopRequireDefault(require("chalk"));
const injectedRulesets = [];
function setRulesets(rulesets) {
  injectedRulesets.push(...rulesets);
}
const isLocalJsFile = name => name.endsWith('.js');
const isUrl = name => {
  try {
    const parsed = new URL(name);
    if (parsed.protocol === 'http:' || parsed.protocol === 'https:') return true;
    return false;
  } catch (e) {
    return false;
  }
};
const getStandardToUse = async options => {
  // We always take the --ruleset arg as priority, then the ruleset on the API spec (from the head), then fallback to the optic.dev.yml config
  if (options.rulesetArg) {
    const config = await (0, _config.loadCliConfig)(options.rulesetArg, options.config.client);
    return config.ruleset;
  } else if (options.specRuleset) {
    if (options.specRuleset.startsWith('@')) {
      try {
        _logger.logger.error('Cloud rulesets are not supported');
        return [];
      } catch (e) {
        _logger.logger.warn(`${_chalk.default.red('Warning:')} Could not download standard ${options.specRuleset}. Please check the ruleset name and whether you are authenticated (run: optic login).`);
        process.exitCode = 1;
        return [];
      }
    } else {
      const rules = {
        extends: options.specRuleset
      };
      await (0, _config.initializeRules)(rules, options.config.client);
      return rules.ruleset;
    }
  } else {
    return options.config.ruleset;
  }
};
const generateRuleRunner = async (options, checksEnabled) => {
  _logger.logger.debug('Initializing rule runner with the following options');
  _logger.logger.debug({
    options,
    checksEnabled
  });
  let rulesets = [];
  let ruleNames = [];
  let warnings = [];
  let standardUsed = [];
  if (checksEnabled) {
    let defaultStandard = [];
    if (injectedRulesets.length > 0) {
      _logger.logger.debug('Using injected rulesets from CLI bundle');
      rulesets.push(...injectedRulesets);
    } else {
      defaultStandard = [{
        name: 'breaking-changes',
        config: {}
      }];
    }
    const standard = (await getStandardToUse(options)) ?? defaultStandard;
    standardUsed = standard;
    _logger.logger.debug({
      standard
    });
    ruleNames.push(...standard.map(s => s.name));
    const rulesToFetch = [];
    const localRulesets = {};
    const hostedRulesets = {};
    for (const rule of standard) {
      if (rule.name in _standardRulesets.StandardRulesets) {
        continue;
      } else if (isLocalJsFile(rule.name)) {
        const rootPath = options.config.configPath ? _path.default.dirname(options.config.configPath) : process.cwd();
        localRulesets[rule.name] = _path.default.resolve(rootPath, rule.name); // the path is the name
      } else if (isUrl(rule.name)) {
        hostedRulesets[rule.name] = {
          uploaded_at: String(Math.random()),
          url: rule.name,
          should_decompress: false
        };
      } else {
        rulesToFetch.push(rule.name);
      }
    }
    if (rulesToFetch.length) {
      _logger.logger.error('Hosted rules are not supported');
    }
    _logger.logger.debug({
      rulesToFetch,
      localRulesets,
      hostedRulesets
    });
    const results = await (0, _rulesetsBase.prepareRulesets)({
      ruleset: standard,
      localRulesets,
      standardRulesets: _standardRulesets.StandardRulesets,
      hostedRulesets
    }, {
      client: options.config.client,
      specVersion: options.specVersion
    });
    rulesets.push(...results.rulesets);
    warnings.push(...results.warnings);
  }
  return {
    runner: new _rulesetsBase.RuleRunner(rulesets),
    ruleNames,
    warnings,
    standard: standardUsed
  };
};
exports.generateRuleRunner = generateRuleRunner;