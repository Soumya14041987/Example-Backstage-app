"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerHistory = exports.getHistoryAction = void 0;
var _config = require("../config");
var _errorHandler = require("../error-handler");
var _logger = require("../logger");
var _chalk = _interopRequireDefault(require("chalk"));
var GitCandidates = _interopRequireWildcard(require("./api/git-get-file-candidates"));
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _specLoaders = require("../utils/spec-loaders");
var _jsonStableStringify = _interopRequireDefault(require("json-stable-stringify"));
var _checksum = require("../utils/checksum");
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _rulesetsBase = require("@useoptic/rulesets-base");
var _standardRulesets = require("@useoptic/standard-rulesets");
var _child_process = require("child_process");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const usage = () => `
  optic history [path_to_spec]`;
const helpText = `
Example usage:
  Export api history to changelog.md file
  $ optic history <path_to_spec.yml> > changelog.md`;
function short(sha) {
  return sha.slice(0, 8);
}
const registerHistory = (cli, config) => {
  cli.command('history').configureHelp({
    commandUsage: usage
  }).addHelpText('after', helpText).description('Browse spec history and create a text changelog').argument('[path_to_spec]', 'Path to OpenAPI file').option('-D, --history-depth <history-depth>', 'Sets the depth of how far to crawl through to historic API data. history-depth=0 will crawl the entire history', '0').action((0, _errorHandler.errorHandler)(getHistoryAction(config), {
    command: 'history'
  }));
};
exports.registerHistory = registerHistory;
const getCommitInfo = sha => {
  return new Promise((resolve, reject) => {
    (0, _child_process.exec)(`git show --format="%cd" ${sha} -s`, (error, stdout, stderr) => {
      if (error || stderr) reject(error || stderr);
      resolve({
        commitDate: new Date(stdout)
      });
    });
  });
};
const isSameDay = (date1, date2) => {
  if (!date1 || !date2) return false;
  const utcDate1 = Date.UTC(date1.getUTCFullYear(), date1.getUTCMonth(), date1.getUTCDate());
  const utcDate2 = Date.UTC(date2.getUTCFullYear(), date2.getUTCMonth(), date2.getUTCDate());
  return utcDate1 == utcDate2;
};
const logDiffs = async (baseSpec, headSpec, headDate) => {
  if (baseSpec.version === '2.x.x' || headSpec.version === '2.x.x') {
    if (headSpec.version === '2.x.x') _logger.logger.warn(`skipping: ${headDate === null || headDate === void 0 ? void 0 : headDate.toDateString()} - swagger 2.0 specs are not supported`);
    return false;
  }
  const rulesRunner = new _rulesetsBase.RuleRunner([new _standardRulesets.BreakingChangesRuleset()]);
  const comparison = await (0, _openapiUtilities.compareSpecs)(baseSpec, headSpec, rulesRunner, {});
  let hasChanges = false;
  for (const {
    method,
    path,
    changes
  } of (0, _openapiUtilities.getEndpointsChanges)(baseSpec.jsonLike, headSpec.jsonLike, comparison.diffs)) {
    if (!hasChanges) {
      console.log(`### ${headDate === null || headDate === void 0 ? void 0 : headDate.toDateString()}`);
      hasChanges = true;
    }
    if (changes.size > 1) {
      console.log(`- \`${method.toUpperCase()}\` \`${path}\`:`);
      for (const change of changes) {
        console.log(`  - ${change}`);
      }
    } else {
      var _changes$Symbol$itera;
      const change = (_changes$Symbol$itera = changes[Symbol.iterator]().next()) === null || _changes$Symbol$itera === void 0 ? void 0 : _changes$Symbol$itera.value;
      const addedOrRemoved = change === 'added' || change === 'removed';
      const suffix = addedOrRemoved ? `` : `: ${change}`;
      const prefix = addedOrRemoved ? `${change} ` : '';
      console.log(`- ${prefix}\`${method.toUpperCase()}\` \`${path}\`${suffix}`);
    }
  }
  return hasChanges;
};
const getHistoryAction = config => async (path_to_spec, options) => {
  var _config$vcs;
  if (((_config$vcs = config.vcs) === null || _config$vcs === void 0 ? void 0 : _config$vcs.type) !== _config.VCS.Git) {
    _logger.logger.error(_chalk.default.red('the history command must be called from inside a git repository'));
    process.exitCode = 1;
    return;
  }
  if (!path_to_spec) {
    _logger.logger.error(_chalk.default.red('path_to_spec is undefined.'));
    process.exitCode = 1;
    return;
  }
  const absolutePath = _path.default.resolve(path_to_spec);
  if (!absolutePath.startsWith(config.root)) {
    _logger.logger.error(_chalk.default.red('path_to_spec must belong to the current git repository'));
    process.exitCode = 1;
    return;
  }
  const stats = _fs.default.statSync(path_to_spec, {
    throwIfNoEntry: false
  });
  const isFile = stats === null || stats === void 0 ? void 0 : stats.isFile();
  if (!isFile) {
    _logger.logger.error(_chalk.default.red('path_to_spec is not a valid specification file path'));
    process.exitCode = 1;
    return;
  }
  if (isNaN(Number(options.historyDepth))) {
    _logger.logger.error(_chalk.default.red('--history-depth, -D is not a number. history-depth must be a number'));
    process.exitCode = 1;
    return;
  }
  const candidates = await GitCandidates.getShasCandidatesForPath(path_to_spec, options.historyDepth);
  const shaPaths = await GitCandidates.followFile(path_to_spec, options.historyDepth);
  let nextShaPathIndex = 0;
  const pathRelativeToRoot = _path.default.relative(config.root, absolutePath);
  let headChecksum = undefined;
  let headSpec = undefined;
  let headDate = undefined;
  let hasAnyChange = false;
  for (const [ix, baseSha] of candidates.shas.entries()) {
    var _shaPaths$nextShaPath;
    let baseSpec;
    const path = ((_shaPaths$nextShaPath = shaPaths[nextShaPathIndex]) === null || _shaPaths$nextShaPath === void 0 ? void 0 : _shaPaths$nextShaPath[1]) ?? pathRelativeToRoot;
    const shaPathIndex = shaPaths.findIndex(p => p[0] === baseSha);
    if (shaPathIndex > -1) nextShaPathIndex = Math.min(nextShaPathIndex + 1, shaPaths.length - 1);
    try {
      baseSpec = await (0, _specLoaders.loadSpec)(`${baseSha}:${path}`, config, {
        strict: false,
        denormalize: true
      });
    } catch (e) {
      _logger.logger.debug(`${short(baseSha)}:${pathRelativeToRoot} is not a valid OpenAPI file, skipping sha version`, e);
      continue;
    }
    const stableSpecString = (0, _jsonStableStringify.default)(baseSpec.jsonLike);
    const baseChecksum = (0, _checksum.computeChecksumForAws)(stableSpecString);
    const {
      commitDate: baseDate
    } = await getCommitInfo(baseSha);
    const sameDay = isSameDay(headDate, baseDate);
    const sameChecksum = baseChecksum === headChecksum;
    const lastCandidate = ix === candidates.shas.length - 1;
    if (lastCandidate && !sameChecksum && headSpec) {
      const hasChange = await logDiffs(baseSpec, headSpec, headDate);
      if (hasChange) hasAnyChange = true;
      continue;
    }
    if (sameChecksum) continue;
    if (!headSpec) {
      headSpec = baseSpec;
      headDate = baseDate;
      const title = baseSpec.jsonLike.info.title;
      console.log(`# ${title}`);
      continue;
    }
    if (sameDay) continue;
    const hasChange = await logDiffs(baseSpec, headSpec, headDate);
    if (hasChange) hasAnyChange = true;
    headChecksum = baseChecksum;
    headDate = baseDate;
    headSpec = baseSpec;
  }
  if (!hasAnyChange) console.log('No changes found');
};
exports.getHistoryAction = getHistoryAction;