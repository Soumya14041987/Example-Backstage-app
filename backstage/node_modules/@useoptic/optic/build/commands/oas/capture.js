"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CaptureObservationKind = void 0;
exports.captureCommand = captureCommand;
exports.captureV1 = captureV1;
exports.writeInteractions = writeInteractions;
var _commander = require("commander");
var _path = _interopRequireDefault(require("path"));
var _fs = _interopRequireDefault(require("fs"));
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _readline = _interopRequireDefault(require("readline"));
var _asyncExitHook = _interopRequireDefault(require("async-exit-hook"));
var AT = _interopRequireWildcard(require("./lib/async-tools"));
var _feedback = require("./reporters/feedback");
var _segment = require("../../segment");
var _logNode = _interopRequireDefault(require("log-node"));
var _openapiIo = require("@useoptic/openapi-io");
var _setupTls = require("./setup-tls");
var _systemProxy = require("./captures/system-proxy");
var _captureStorage = require("./captures/capture-storage");
var _runCommand = require("./captures/run-command");
var _shellUtils = require("./lib/shell-utils");
var _chalk = _interopRequireDefault(require("chalk"));
var _verify = require("./verify");
var _captureClear = require("./capture-clear");
var _specs = require("../../utils/specs");
var _logger = require("../../logger");
var _har = require("../capture/sources/har");
var _proxy = require("./captures/proxy");
var _capturedInteractions = require("../capture/sources/captured-interactions");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
async function captureV1(filePath, targetUrl, config, command) {
  const feedback = (0, _feedback.createCommandFeedback)(command);
  const {
    openApiExists,
    trafficDirectory
  } = await (0, _captureStorage.captureStorage)(filePath);
  if (!openApiExists) {
    const specFile = (0, _specs.createNewSpecFile)('3.1.0');
    if ((0, _openapiIo.isJson)(filePath)) {
      _logger.logger.info(`Initializing OpenAPI file at ${filePath}`);
      await _promises.default.mkdir(_path.default.dirname(filePath), {
        recursive: true
      });
      await _promises.default.writeFile(filePath, JSON.stringify(specFile, null, 2));
    } else if ((0, _openapiIo.isYaml)(filePath)) {
      await _promises.default.mkdir(_path.default.dirname(filePath), {
        recursive: true
      });
      _logger.logger.info(`Initializing OpenAPI file at ${filePath}`);
      await _promises.default.writeFile(filePath, (0, _openapiIo.writeYaml)(specFile));
    } else {
      return await feedback.inputError('OpenAPI file not found', _feedback.InputErrors.SPEC_FILE_NOT_FOUND);
    }
  }
  const timestamp = Date.now().toString();
  const inProgressName = _path.default.join(trafficDirectory, `${timestamp}.incomplete`);
  const completedName = _path.default.join(trafficDirectory, `${timestamp}.har`);
  const options = command.opts();
  if (options.proxyPort && isNaN(Number(options.proxyPort))) {
    _logger.logger.error(`--proxy-port must be a number - received ${options.proxyPort}`);
    process.exitCode = 1;
    return;
  }
  if (options.debug) {
    (0, _logNode.default)();
  }
  let sourcesController = new AbortController();
  const sources = []; // this should be CapturedInteractions, but those aren't detailed enough yet to not lose information later

  let interactiveCapture = false;
  let ca;
  if (options.tls) {
    const certStore = (0, _setupTls.getCertStore)();
    let maybeCa = certStore.get();
    if (maybeCa.none || _proxy.ProxyCertAuthority.hasExpired(maybeCa.val, new Date())) {
      ca = await _proxy.ProxyCertAuthority.generate();
      certStore.set(ca);
    } else {
      ca = maybeCa.val;
    }
  }
  let [proxyInteractions, proxyUrl] = await _proxy.ProxyInteractions.create(targetUrl, sourcesController.signal, {
    ca,
    mode: options.reverseProxy ? 'reverse-proxy' : 'system-proxy',
    proxyPort: options.proxyPort && Number(options.proxyPort)
  });
  const runningCommand = Boolean(options.command);
  const systemProxy = new _systemProxy.SystemProxy(proxyUrl, feedback);
  if (!runningCommand && !options.reverseProxy) {
    await systemProxy.start(undefined);
  } else {
    _logger.logger.info(`${_chalk.default.blue.bold('Proxy URL:')} ${proxyUrl} (send traffic here)`);
    _logger.logger.info(`${_chalk.default.blue.bold('Forwarding URL:')} ${targetUrl} (traffic will be forwarded here)`);
  }
  sources.push(_har.HarEntries.fromProxyInteractions(proxyInteractions));
  if (!runningCommand) interactiveCapture = true;
  if (sources.length < 1) {
    return await feedback.inputError('choose a method of capturing traffic to create a capture', _feedback.InputErrors.CAPTURE_METHOD_MISSING);
  }
  let destination = _fs.default.createWriteStream(inProgressName);
  const commandRunner = new _runCommand.RunCommand(proxyUrl, feedback, {
    reverseProxy: options.reverseProxy
  });
  let exitCode = undefined;
  if (options.command) {
    const runningCommand = await commandRunner.run(options.command);
    exitCode = runningCommand.exitCode;
    sourcesController.abort();
  }
  const harEntries = AT.merge(...sources);
  const handleUserSignals = async function () {
    if (interactiveCapture) {
      // wait for an empty new line on input, which should indicate hitting Enter / Return (or signal of other process)
      let lines = _readline.default.createInterface({
        input: process.stdin
      });
      let onAbort = () => {
        lines.close();
      };
      if (runningCommand) await commandRunner.kill();
      sourcesController.signal.addEventListener('abort', onAbort);
      for await (let line of lines) {
        if (line.trim().length === 0) {
          // @todo get this working on windows. It cleans up the incremental request count but fails on windows. It's not essential
          if (process.stdin.isTTY && _shellUtils.platform !== 'windows') {
            _readline.default.moveCursor(process.stdin, 0, -1);
            _readline.default.clearLine(process.stdin, 1);
          }
          sourcesController.abort();
        }
      }
    }
  }();
  const observations = writeInteractions(harEntries, destination);
  const observationsFork = AT.forkable(observations);
  const renderingStats = renderCaptureProgress(feedback, observationsFork.fork(), {
    interactiveCapture,
    debug: options.debug,
    reverseProxy: options.reverseProxy
  });
  const trackingStats = trackStats(observationsFork.fork(), sourcesController.signal);
  observationsFork.start();
  const completing = Promise.all([handleUserSignals, renderingStats, trackingStats]);
  (0, _asyncExitHook.default)(callback => {
    sourcesController.abort();
    completing.then(async () => Promise.all([!runningCommand ? await systemProxy.stop() : Promise.resolve(), (async () => {
      if (options.output) {
        const outputPath = _path.default.resolve(options.output);
        feedback.success(`Wrote har to ${outputPath}`);
        return await _promises.default.rename(inProgressName, outputPath);
      }
      await _promises.default.rename(inProgressName, completedName);
      try {
        await (0, _verify.runVerify)(filePath, {
          exit0: true,
          har: options.output ? _path.default.resolve(options.output) : undefined
        }, config, feedback, {
          printCoverage: false
        });
      } catch (e) {
        console.log(e);
      }
      await (0, _segment.flushEvents)();
      if (!interactiveCapture) {
        // Log next steps
        feedback.success(`Wrote har traffic to ${completedName}`);
        feedback.log(`\nRun "${_chalk.default.bold(`optic verify ${filePath}`)}" to diff the captured traffic`);
      }
    })()])).then(() => {
      callback();
    }, err => callback(err));
  });
  await completing;
  if (exitCode) process.exit(exitCode);
}
async function captureCommand(config) {
  const command = new _commander.Command('capture');
  command.addCommand((0, _captureClear.clearCommand)());
  command.argument('<openapi-file>', 'an OpenAPI spec file to add an operation to').argument('[target-url]', 'the url to capture...').description('capture observed traffic as a HAR (HttpArchive v1.3) file').option('--no-tls', 'disable TLS support for --proxy and prevent generation of new CA certificates').option('-r, --reverse-proxy', 'run optic capture in reverse proxy mode - send traffic to a port that gets forwarded to your server').option('--proxy-port <proxy-port>', 'specify the port the proxy should be running on').option('--command <command>', 'command to run with the http_proxy and http_proxy configured').option('-d, --debug', `output debug information (on stderr). Use LOG_LEVEL env with 'debug', 'info' to increase verbosity`).option('-o, --output <output>', 'file name for output').action(async (filePath, targetUrl) => {
    _logger.logger.warn(_chalk.default.yellow.bold('optic oas capture is deprecated. Use optic capture instead'));
    await captureV1(filePath, targetUrl, config, command);
  });
  return command;
}
function writeInteractions(harEntries, destination) {
  const observing = new AT.Subject();
  const observers = {
    captureHarEntry(entry) {
      const interaction = _capturedInteractions.CapturedInteraction.fromHarEntry(entry); // inefficient, but okay until CapturedInteraction becomes the common source type
      interaction && observing.onNext({
        kind: CaptureObservationKind.InteractionCaptured,
        path: interaction.request.path,
        method: interaction.request.method
      });
    }
  };
  let harJSON = _har.HarEntries.toHarJSON(AT.tap(observers.captureHarEntry)(harEntries));
  function onWriteComplete() {
    observing.onNext({
      kind: CaptureObservationKind.CaptureWritten
    });
    observing.onCompleted();
  }

  // if (destination.fd == 1) {
  //   // if writing to stdout
  //   // stdout won't close until the process detaches, so we can't use it to measure completion
  harJSON.once('end', onWriteComplete);
  // } else {
  //   destination.once('end', onWriteComplete);
  // }

  harJSON.pipe(destination);
  return observing.iterator;
}
let CaptureObservationKind = exports.CaptureObservationKind = /*#__PURE__*/function (CaptureObservationKind) {
  CaptureObservationKind["InteractionCaptured"] = "interaction-captured";
  CaptureObservationKind["CaptureWritten"] = "capture-written";
  return CaptureObservationKind;
}({});
async function renderCaptureProgress(feedback, observations, config) {
  const ora = (await Promise.resolve().then(() => _interopRequireWildcard(require('ora')))).default;
  let interactionCount = 0;
  if (config.interactiveCapture) {
    feedback.instruction('Press [ Enter ] to finish capturing requests');
  }
  let spinner = ora({
    text: '0 requests captured',
    isEnabled: !config.debug
  });
  spinner.start();
  let timer;
  if (config.interactiveCapture && !config.reverseProxy) {
    timer = setTimeout(() => {
      if (interactionCount === 0) {
        spinner.clear();
        console.log('\nNot seeing any traffic captured? Make sure your HTTP Client is using the proxy: ' + _chalk.default.underline.blue('https://www.useoptic.com/docs/oas-reference/client-guides'));
        spinner.start();
      }
    }, 13000);
  }
  for await (let observation of observations) {
    if (observation.kind === CaptureObservationKind.InteractionCaptured) {
      if (interactionCount === 0) clearTimeout(timer);
      interactionCount += 1;
      spinner.text = `${interactionCount} requests captured`;
    } else if (observation.kind === CaptureObservationKind.CaptureWritten) {}
  }
  clearTimeout(timer);
  if (interactionCount === 0) {
    spinner.info('No requests captured');
  } else {
    spinner.succeed(`${interactionCount} requests captured`);
  }
}
async function trackStats(observations, abort) {
  const stats = {
    capturedInteractionsCount: 0
  };
  for await (let observation of observations) {
    if (observation.kind === CaptureObservationKind.InteractionCaptured) {
      stats.capturedInteractionsCount += 1;
    }
  }
  (0, _segment.trackEvent)('openapi_cli.capture.completed', stats);
}