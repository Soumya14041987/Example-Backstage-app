"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInteractions = getInteractions;
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _captureStorage = require("./capture-storage");
var _feedback = require("../reporters/feedback");
var AT = _interopRequireWildcard(require("../lib/async-tools"));
var _capturedInteractions = require("../../capture/sources/captured-interactions");
var _postman = require("../../capture/sources/postman");
var _har = require("../../capture/sources/har");
var _groupedInteractions = require("../../capture/interactions/grouped-interactions");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
async function getInteractions(options, spec, specPath, feedback) {
  const sources = [];
  const {
    trafficDirectory
  } = await (0, _captureStorage.captureStorage)(specPath);
  const captureDirectoryContents = (await _promises.default.readdir(trafficDirectory)).sort();

  // check
  if (options.har) {
    // override with a har
    let absoluteHarPath = _path.default.resolve(options.har);
    if (!_fs.default.existsSync(absoluteHarPath)) {
      return await feedback.inputError('Provided HAR path is invalid', _feedback.InputErrors.HAR_FILE_NOT_FOUND);
    }
    const isDir = _fs.default.lstatSync(absoluteHarPath).isDirectory();
    const harPaths = isDir ? _fs.default.readdirSync(absoluteHarPath).filter(filePath => _path.default.extname(filePath).toLowerCase() === '.har').map(filePath => _path.default.join(absoluteHarPath, filePath)) : [absoluteHarPath];
    for (const path of harPaths) {
      let harFile = _fs.default.createReadStream(path);
      let harEntryResults = _har.HarEntries.fromReadable(harFile);
      let harEntries = AT.unwrapOr(harEntryResults, err => {});
      sources.push(_capturedInteractions.CapturedInteractions.fromHarEntries(harEntries));
    }
  } else if (options.postman) {
    const absolutePath = _path.default.resolve(options.postman);
    if (!_fs.default.existsSync(absolutePath)) {
      return await feedback.inputError('Postman collection file could not be found at given path', _feedback.InputErrors.POSTMAN_FILE_NOT_FOUND);
    }
    let collectionFile = _fs.default.createReadStream(absolutePath);
    let postmanEntryResults = _postman.PostmanCollectionEntries.fromReadable(collectionFile);
    let postmanEntries = AT.unwrapOr(postmanEntryResults, err => {
      let message = `Postman collection entry skipped: ${err.message}`;
      console.warn(message); // warn, skip and keep going
    });
    sources.push(_capturedInteractions.CapturedInteractions.fromPostmanCollection(postmanEntries));
  } else {
    // default is capture directory
    captureDirectoryContents.forEach(potentialCapture => {
      // completed captures only
      if (potentialCapture.endsWith('.har')) {
        let harFile = _fs.default.createReadStream(_path.default.join(trafficDirectory, potentialCapture));
        let harEntryResults = _har.HarEntries.fromReadable(harFile);
        let harEntries = AT.unwrapOr(harEntryResults, err => {});
        sources.push(_capturedInteractions.CapturedInteractions.fromHarEntries(harEntries));
      }
    });
  }
  if (sources.length < 1) {
    return await feedback.inputError('no traffic captured for this OpenAPI spec. Run "oas capture" command', _feedback.InputErrors.CAPTURE_METHOD_MISSING);
  }
  return (0, _groupedInteractions.handleServerPathPrefix)((0, _groupedInteractions.filterIgnoredInteractions)(AT.merge(...sources), spec), (0, _groupedInteractions.createHostBaseMap)(spec));
}