/// <reference types="node" />
/// <reference types="node" />
import { Readable } from 'stream';
import globalLog from 'log';
import { ProxySource } from '../../capture/sources/proxy';
type Logger = typeof globalLog;
export declare const log: Logger;
export interface ProxyInteractions extends AsyncIterable<ProxySource.Interaction> {
}
export declare class ProxyInteractions {
    static create(targetHost: string, abort: AbortSignal, // required, we don't want to ever let a proxy run indefinitely
    options: {
        ca?: ProxyCertAuthority;
        targetCA?: Array<{
            cert: Buffer | string;
        }>;
        mode: 'reverse-proxy' | 'system-proxy';
        proxyPort?: number;
    }): Promise<[ProxyInteractions, string, string]>;
}
export interface ProxyCertAuthority {
    cert: string;
    key: string;
    keyLength?: number;
}
export declare class ProxyCertAuthority {
    static generate(): Promise<ProxyCertAuthority>;
    static hasExpired(self: ProxyCertAuthority, dateTime: Date): boolean;
    static readableCert(self: ProxyCertAuthority): Readable;
}
export {};
//# sourceMappingURL=proxy.d.ts.map