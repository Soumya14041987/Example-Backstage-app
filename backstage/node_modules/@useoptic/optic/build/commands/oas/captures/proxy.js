"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = exports.ProxyInteractions = exports.ProxyCertAuthority = void 0;
var mockttp = _interopRequireWildcard(require("mockttp"));
var _events = _interopRequireDefault(require("events"));
var _asyncTools = require("../lib/async-tools");
var _nodeForge = require("node-forge");
var _crypto = require("crypto");
var _stream = require("stream");
var _net = _interopRequireDefault(require("net"));
var _url = require("url");
var httpolyglot = _interopRequireWildcard(require("@httptoolkit/httpolyglot"));
var _portfinder = _interopRequireDefault(require("portfinder"));
var _log = _interopRequireDefault(require("log"));
var _chalk = _interopRequireDefault(require("chalk"));
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _logger = require("../../../logger");
var _urlJoin = _interopRequireDefault(require("url-join"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const log = exports.log = _log.default.get('captures:streams:sources:proxy'); // export so it can be enabled in testing

class ProxyInteractions {
  static async create(targetHost, abort,
  // required, we don't want to ever let a proxy run indefinitely
  options) {
    let host;
    let protocol;
    let origin;
    let serverPathnamePrefix;
    try {
      ({
        host,
        protocol,
        origin,
        pathname: serverPathnamePrefix
      } = new _url.URL(targetHost));
    } catch (e) {
      _logger.logger.error(`${_chalk.default.red('Error:')} Invalid URL. Valid URLs must include the protocol and host, e.g. http://localhost:3030 or https://api.example.com, received: ${targetHost}`);
      throw new _openapiUtilities.UserError();
    }
    targetHost = host;
    const forwardHost = options.mode === 'reverse-proxy' ? origin : targetHost;
    const capturingProxy = mockttp.getLocal({
      cors: false,
      debug: false,
      recordTraffic: false,
      https: options.ca && {
        cert: options.ca.cert.toString(),
        key: options.ca.key.toString()
      }
    });
    let forwardedHosts = [forwardHost];
    await capturingProxy.forAnyRequest().always().matching(request => {
      // our own matching, adapted from mockttp's HostMatcher, so we can forward
      // direct requests to the proxy to the target as well
      const parsedUrl = new _url.URL(request.url);
      let result = false;
      for (let host of forwardedHosts) {
        if (host.endsWith(':80') && request.protocol === 'http' || host.endsWith(':443') && request.protocol === 'https') {
          // On default ports, our URL normalization erases an explicit port, so that a
          // :80 here will never match anything. This handles that case: if you send HTTP
          // traffic on port 80 then the port is blank, but it should match for 'hostname:80'.
          result = result || parsedUrl.hostname === host.split(':')[0] && parsedUrl.port === '';
        } else {
          result = result || parsedUrl.host === host;
        }
        if (result) break;
      }
      return result;
    }).thenPassThrough({
      beforeRequest: onTargetedRequest,
      forwarding: {
        targetHost: forwardHost,
        updateHostHeader: true
      },
      trustAdditionalCAs: options.targetCA || []
    });
    await capturingProxy.forUnmatchedRequest().thenPassThrough({
      beforeRequest(capturedRequest) {
        console.log(capturedRequest.url);
        log.info('proxying request to ' + capturedRequest.url);
      }
    });
    await capturingProxy.forAnyWebSocket().thenPassThrough();
    const interactions = new _asyncTools.Subject();
    const requestsById = new Map();
    function onTargetedRequest(capturedRequest) {
      const {
        matchedRuleId,
        remoteIpAddress,
        remotePort,
        tags,
        body,
        timingEvents,
        ...rest
      } = capturedRequest;
      // Sometimes we need to adjust the request url if the server url is not at the hostname root
      // e.g. `http://example.com/server-lives-here - requests going to the proxy root should be forwarded to `/server-lives-here`
      const urlObj = new _url.URL(rest.url);
      urlObj.pathname = (0, _urlJoin.default)(serverPathnamePrefix, urlObj.pathname);
      const prefixedUrl = urlObj.toString();
      _logger.logger.debug(`Forwarding request ${rest.path} ${prefixedUrl} with headers: ${JSON.stringify(rest.headers)}. id: ${capturedRequest.id}`);
      const request = {
        ...rest,
        body: {
          buffer: body.buffer
        },
        timingEvents: timingEvents
      };
      requestsById.set(request.id, request);
      return {
        url: prefixedUrl
      };
    }
    function onResponse(capturedResponse) {
      const {
        id
      } = capturedResponse;
      const request = requestsById.get(id);
      if (!request) return;
      const {
        tags,
        body,
        timingEvents,
        ...rest
      } = capturedResponse;
      _logger.logger.debug(`Received response for request id ${id} status code: ${rest.statusCode} message: ${rest.statusMessage} headers: ${JSON.stringify(rest.rawHeaders)}`);
      const response = {
        ...rest,
        body: {
          buffer: body.buffer
        },
        timingEvents: timingEvents
      };
      interactions.onNext({
        request,
        response
      });
      requestsById.delete(id);
    }
    let alreadyLoggedTlsError = false;
    function onTLSError(error) {
      if (!alreadyLoggedTlsError && protocol === 'https:' && error.failureCause === 'cert-rejected' && targetHost === error.hostname) {
        alreadyLoggedTlsError = true;
        console.error(_chalk.default.red('\nYou are trying to intercept a https host without a trusted certificate for the Optic Proxy.\nYou need to run "optic setup-tls" to generate and trust a certificate'));
      }
    }
    await Promise.all([capturingProxy.on('response', onResponse), capturingProxy.on('tls-client-error', onTLSError)]);
    abort.addEventListener('abort', onAbort);
    interactions.finally(() => {
      abort.removeEventListener('abort', onAbort);
    });
    function onAbort(e) {
      capturingProxy.reset();
      capturingProxy.stop();
      transparentProxy.stop();
      interactions.onCompleted();
    }
    let transparentPort = options.proxyPort ? options.proxyPort : await _portfinder.default.getPortPromise({
      port: 8000,
      stopPort: 8999
    });
    await capturingProxy.start({
      startPort: transparentPort + 1,
      endPort: transparentPort + 999
    });
    forwardedHosts.push(`localhost:${capturingProxy.port}`);
    log.info('capturing proxy started at %s', capturingProxy.url);

    // sits in front of the capturing proxy to only direct target host traffic
    // and transparently forward the rest
    // @ts-ignore
    let capturingApp = capturingProxy.app;
    // @ts-ignore
    let capturingServer = capturingProxy.server;
    // @ts-ignore
    const tlsServer = capturingServer._tlsServer;
    const transparentProxy = new TransparentProxy(targetHost, capturingApp, capturingServer, {
      https: options.ca && {
        ca: [options.ca.cert],
        cert: tlsServer.cert,
        key: tlsServer.key
      }
    });
    await transparentProxy.start(transparentPort);
    forwardedHosts.push(`localhost:${transparentProxy.port}`);
    log.info('transparent proxy started at %s', transparentProxy.url);
    const stream = async function* () {
      yield* interactions.iterator;
    }();
    return [stream, transparentProxy.url, capturingProxy.url];
  }
}
exports.ProxyInteractions = ProxyInteractions;
class ProxyCertAuthority {
  static async generate() {
    const keyPair = await new Promise((resolve, reject) => {
      _nodeForge.pki.rsa.generateKeyPair({
        bits: 2048
      }, (err, keypair) => {
        if (err) {
          reject(err);
        } else {
          resolve(keypair);
        }
      });
    });
    const cert = _nodeForge.pki.createCertificate();
    cert.publicKey = keyPair.publicKey;
    cert.serialNumber = generateSerialNumber();
    const curYear = new Date().getFullYear();
    cert.validity.notBefore = new Date();
    cert.validity.notBefore.setDate(cert.validity.notBefore.getDate() - 1); // account for wonky time keeping
    cert.validity.notAfter = new Date();
    cert.validity.notAfter.setFullYear(curYear + 2);
    cert.setSubject([{
      name: 'commonName',
      value: `Optic CLI CA (locally generated ${new Date().toISOString()})`
    }, {
      name: 'countryName',
      value: 'US'
    }, {
      name: 'stateOrProvinceName',
      value: 'NY'
    }, {
      name: 'localityName',
      value: 'New York City'
    }, {
      name: 'organizationName',
      value: 'Optic Labs Corporation'
    }, {
      name: 'organizationalUnitName',
      value: 'https://useoptic.com'
    }]);
    cert.setIssuer(cert.subject.attributes); // self-signed

    cert.setExtensions([{
      name: 'basicConstraints',
      cA: true,
      critical: true
    }, {
      name: 'keyUsage',
      keyCertSign: true,
      digitalSignature: true,
      nonRepudiation: true,
      cRLSign: true,
      critical: true
    }, {
      name: 'extKeyUsage',
      serverAuth: true,
      clientAuth: true
    }, {
      name: 'subjectKeyIdentifier'
    }]);
    cert.sign(keyPair.privateKey, _nodeForge.md.sha256.create());
    return {
      cert: _nodeForge.pki.certificateToPem(cert),
      key: _nodeForge.pki.privateKeyToPem(keyPair.privateKey)
    };
  }
  static hasExpired(self, dateTime) {
    const cert = _nodeForge.pki.certificateFromPem(self.cert);
    return dateTime < cert.validity.notBefore || dateTime > cert.validity.notAfter;
  }
  static readableCert(self) {
    return _stream.Readable.from(Buffer.from(self.cert));
  }
}
exports.ProxyCertAuthority = ProxyCertAuthority;
function generateSerialNumber() {
  // hexadecimal serial number of at most 20 octets, and preferably positive.
  // starting with A should get a positive number
  return 'A' + (0, _crypto.randomBytes)(18).toString('hex').toUpperCase();
}
class TransparentProxy {
  constructor(targetHost, captureRequest, capturingServer, options = {}) {
    this.server = httpolyglot.createServer({
      ALPNProtocols: ['http/1.1'],
      ...(options.https ? options.https : {})
    }, captureRequest);
    this.serverDestroy = destroyCommandForServer(this.server);
    this.tlsEnabled = !!options.https;
    _events.default.setMaxListeners(Infinity);
    _events.default.defaultMaxListeners = Infinity;
    const tunnelAbort = this.tunnelAbort = new AbortController(); // control aborting of tunnels separately
    // small hack to prevent warnings, because the AbortController polyfill doesn't setup EventEmitter according to spec
    // @ts-ignore
    if (tunnelAbort.signal.eventEmitter) {
      // @ts-ignore
      tunnelAbort.signal.eventEmitter.setMaxListeners(Infinity);
    }
    let [targetHostname, targetPort] = targetHost.split(':');
    this.server.on('connect', (req, resOrSocket, reqHead) => {
      if (resOrSocket instanceof _net.default.Socket) {
        let clientSocket = resOrSocket;
        // clients disconnecting causes errors, but there's not much to do for us
        // than the default behaviour of stopping the tunnel
        clientSocket.once('error', err => {
          if (isTransitiveSocketError(err)) {
            // connections get broken sometimes, nothing special
            clientSocket.destroy();
            log.info('Handled error on client socket by destroying it: %s', err);
            return;
          }
          this.server.emit('error', err); // forward any errors we can't handle
        });
        destroySocketOnAbort(clientSocket, tunnelAbort.signal);
        if (!req.url) {
          // TODO: see if we could go just of the `host` header
          clientSocket.write(`HTTP/${req.httpVersion} 400 Bad Request\r\n\r\n`, 'utf-8');
          clientSocket.end();
          return;
        }
        const {
          port,
          host,
          hostname
        } = new _url.URL(`http://${req.url}`);
        if (host !== targetHost && !(targetHostname === hostname && (port === targetPort || !targetPort && port === '80' || !targetPort && port === '443'))) {
          // transparently tunnel all non-target traffic directly through TCP sockets
          log.info('transparently tunneling connection to %s', host);
          const serverSocket = _net.default.connect(port && parseInt(port) || 80, hostname, () => {
            log.info('tunnel to %s established', host);
            clientSocket.once('error', err => {
              serverSocket.destroy();
            });
            clientSocket.write(`HTTP/${req.httpVersion} 200 Connection Established\r\nProxy-agent: Optic Transparent proxy\r\n\r\n`);
            serverSocket.write(reqHead);
            clientSocket.pipe(serverSocket);
            serverSocket.pipe(clientSocket);
          });
          serverSocket.once('error', err => {
            let errorCode = isCodedError(err) ? err.code : null;
            if ((errorCode === 'ENOTFOUND' || errorCode === 'ECONNREFUSED') && serverSocket.connecting) {
              clientSocket.write(`HTTP/${req.httpVersion} 502 Bad Gateway\r\nProxy-agent: Optic Transparent proxy\r\n\r\n`);
              log.notice('tunnel to %s could not be established: %s', host, errorCode);
              return;
            } else if (errorCode === 'ETIMEDOUT' && serverSocket.connecting) {
              clientSocket.write(`HTTP/${req.httpVersion} 504 Gateway Timeout\r\nProxy-agent: Optic Transparent proxy\r\n\r\n`);
              log.notice('tunnel to %s could not be established: %s', host, errorCode);
              return;
            } else if (isTransitiveSocketError(err)) {
              // connections get broken sometimes, nothing special
              clientSocket.destroy();
              log.info('tunnel to %s interrupted: %s', host, errorCode);
              return;
            }
            this.server.emit('error', err); // forward error to transparentProxy server, give downstream a chance to handle it
          });
          destroySocketOnAbort(serverSocket, tunnelAbort.signal);
        } else {
          log.notice('capturing connection to target (%s)', host);
          // tunnel target traffic to the capturing proxy
          // @ts-ignore
          clientSocket.write(`HTTP/${req.httpVersion} 200 Connection Established\r\nProxy-agent: Optic Transparent proxy\r\n\r\n`);
          capturingServer.emit('connection', clientSocket);
        }
      } else {
        throw new Error('HTTP/2 CONNECT unimplemented');
      }
    });
  }
  start(port) {
    const server = this.server;
    return new Promise((resolve, reject) => {
      const onListening = () => {
        cleanup();
        this.port = port;
        this.url = `${this.tlsEnabled ? 'https' : 'http'}://localhost:${port}`;
        resolve();
      };
      const onListenError = err => {
        let errorCode = isCodedError(err) && err.code;
        if (errorCode && errorCode === 'EADDRINUSE') {
          // port got taken since we last found it as un-used, try again
          log.notice('attempting another port for transparentProxy');
          _portfinder.default.getPortPromise({
            port: 8000,
            stopPort: 8999
          }).then(availablePort => {
            port = availablePort;
            server.close();
            server.listen(port);
          });
        } else {
          cleanup();
          reject(err);
        }
      };
      const cleanup = () => {
        this.server.removeListener('listening', onListening);
        this.server.removeListener('error', onListenError);
      };
      server.on('listening', onListening);
      server.on('error', onListenError);
      server.listen(port);
    });
  }
  stop() {
    return new Promise((resolve, reject) => {
      this.serverDestroy(err => {
        // stops accepting new connections, waits for tunnels to finish
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
      this.tunnelAbort.abort(); // abort all open tunnels so tunneling proxy can close
    });
  }
}
function destroySocketOnAbort(socket, abort) {
  socket.once('close', err => {
    abort.removeEventListener('abort', onAbort);
  });
  abort.addEventListener('abort', onAbort);
  function onAbort() {
    if (!socket.destroyed) socket.destroy();
  }
}
function isCodedError(error) {
  return typeof error.code === 'string';
}
function isTransitiveSocketError(err) {
  return isCodedError(err) && transitiveSocketErrors.includes(err.code);
}
const transitiveSocketErrors = Object.freeze(['ECONNRESET', 'ENOTFOUND', 'EPIPE', 'ETIMEDOUT']);
function destroyCommandForServer(server) {
  let connections = {};
  server.on('connection', function (conn) {
    var key = conn.remoteAddress + ':' + conn.remotePort;
    connections[key] = conn;
    conn.on('close', function () {
      delete connections[key];
    });
  });
  return function (cb) {
    server.close(cb);
    for (var key in connections) connections[key].destroy();
  };
}