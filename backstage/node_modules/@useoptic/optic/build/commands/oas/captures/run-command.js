"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RunCommand = void 0;
var _child_process = require("child_process");
var _url = _interopRequireDefault(require("url"));
class RunCommand {
  constructor(proxyUrl, feedback, options) {
    this.proxyUrl = proxyUrl;
    this.feedback = feedback;
    this.options = options;
  }
  completed = false;
  process = undefined;
  async run(command) {
    const {
      port,
      hostname
    } = _url.default.parse(this.proxyUrl);
    const [commandStart] = command.split(/ +/);
    const commandProcess = (0, _child_process.spawn)(command, {
      cwd: process.cwd(),
      env: {
        ...process.env,
        ...(this.options.reverseProxy ? {
          OPTIC_HOST: this.proxyUrl
        } : {
          http_proxy: `http://${hostname}:${port}`,
          https_proxy: `https://${hostname}:${port}`
        })
      },
      shell: true
    });
    this.feedback.notable('Running command: ' + command);
    this.process = commandProcess;
    commandProcess.stdout.setEncoding('utf8');
    commandProcess.stdout.on('data', data => {
      const str = data.toString(),
        lines = str.split(/(\r?\n)/g);
      lines.forEach(line => line.trim() && this.feedback.logChild(commandStart, line));
    });
    commandProcess.stderr.on('data', data => {
      const str = data.toString(),
        lines = str.split(/(\r?\n)/g);
      lines.forEach(line => line.trim() && this.feedback.logChild(commandStart, line));
    });
    return new Promise(resolve => {
      const endIt = code => {
        this.completed = true;
        resolve({
          exitCode: (commandProcess === null || commandProcess === void 0 ? void 0 : commandProcess.exitCode) || 0
        });
        commandProcess.removeAllListeners('error');
        commandProcess.removeAllListeners('data');
        commandProcess.removeAllListeners('exit');
      };
      commandProcess.once('exit', code => endIt(code || undefined));
      commandProcess.once('end', endIt);
      commandProcess.once('close', endIt);
    });
  }
  async kill() {
    if (!this.completed && this.process) {
      this.process.kill(1);
    }
  }
}
exports.RunCommand = RunCommand;