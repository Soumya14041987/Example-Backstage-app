"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatusObservationKind = exports.AddObservationKind = void 0;
exports.addIfUndocumented = addIfUndocumented;
exports.addOperations = addOperations;
exports.matchInteractions = matchInteractions;
exports.observationToUndocumented = observationToUndocumented;
exports.parseAddOperations = parseAddOperations;
exports.updateSpecFiles = updateSpecFiles;
var _tsResults = require("ts-results");
var _operations = require("../operations");
var _inferPathStructureLegacy = require("./infer-path-structure-legacy");
var AT = _interopRequireWildcard(require("../lib/async-tools"));
var _specs = require("../specs");
var _documentedBodies = require("../../capture/patches/patchers/shapes/documented-bodies");
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _apiCoverage = require("../../capture/coverage/api-coverage");
var _schemaInventory = require("../../capture/patches/patchers/closeness/schema-inventory");
var _queries = require("../../capture/operations/queries");
var _openapiIo = require("@useoptic/openapi-io");
var _patches = require("../../capture/patches/patchers/spec/patches");
var _patches2 = require("../specs/streams/patches");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function parseAddOperations(input) {
  const components = input.filter(s => s.length > 0);
  const pairs = [];
  const regex = /(get|post|put|delete|patch|options|head)( +)(\/.*)/i;
  components.forEach(comp => {
    const groups = regex.exec(comp);
    if (groups !== null) {
      const method = groups[1];
      const pathPattern = groups[3];
      pairs.push({
        methods: [_operations.HttpMethods[method.toUpperCase()]],
        pathPattern: pathPattern.length > 1 && pathPattern.endsWith('/') ? pathPattern.substring(0, pathPattern.length - 1) : pathPattern
      });
    }
  });
  if (pairs.length !== input.length) {
    return (0, _tsResults.Err)('Invalid format for endpoint documentation');
  }
  return (0, _tsResults.Ok)(pairs);
}
async function addIfUndocumented(operationsToAdd, isAddAll, statusObservations, interactions, spec, sourcemap) {
  const operationsToUpdate = isAddAll ? await observationToUndocumented(statusObservations, (0, _queries.specToPaths)(spec)) : operationsToAdd;
  let {
    results: addPatches,
    observations: addObservations
  } = addOperations(spec, operationsToUpdate, interactions);
  let {
    results: updatedSpecFiles,
    observations: fileObservations
  } = updateSpecFiles(addPatches, sourcemap);
  let observations = AT.forkable(AT.merge(addObservations, fileObservations));
  const stats = collectStats(observations.fork());
  observations.start();
  for await (let _ of _specs.SpecFiles.writeFiles(updatedSpecFiles)) {}
  return (0, _tsResults.Ok)(await stats);
}

// observations to diffs

async function observationToUndocumented(observations, operations) {
  let pathDiffs = {
    matchedOperations: new Map(),
    matchedInteractionCountByOperation: new Map(),
    unmatchedMethods: new Map(),
    unmatchedPaths: new Map()
  };
  for await (let observation of observations) {
    if (observation.kind === StatusObservationKind.InteractionUnmatchedPath) {
      let opId = operationId(observation);
      const {
        path,
        method
      } = observation;
      pathDiffs.unmatchedPaths.set(opId, {
        path,
        method
      });
    } else if (observation.kind === StatusObservationKind.InteractionUnmatchedMethod) {
      let opId = operationId(observation);
      if (!pathDiffs.unmatchedMethods.has(opId)) {
        const {
          path,
          method
        } = observation;
        pathDiffs.unmatchedMethods.set(opId, {
          path,
          methods: [method]
        });
      } else {
        let methods = pathDiffs.unmatchedMethods.get(opId).methods;
        methods.push(observation.method);
      }
    }
  }
  const inferredPathStructure = new _inferPathStructureLegacy.InferPathStructureLegacy(operations);
  [...pathDiffs.unmatchedPaths.values()].forEach(observed => inferredPathStructure.includeObservedUrlPath(observed.method, observed.path));
  [...pathDiffs.unmatchedMethods.values()].forEach(observed => {
    observed.methods.forEach(method => {
      inferredPathStructure.includeObservedUrlPath(method, observed.path);
    });
  });
  inferredPathStructure.replaceConstantsWithVariables();
  const pathsToAdd = inferredPathStructure.undocumentedPaths();
  return pathsToAdd;
  function operationId({
    path,
    method
  }) {
    return `${method}${path}`;
  }
}
function matchInteractions(spec, interactions, coverage = new _apiCoverage.ApiCoverageCounter(spec)) {
  const interactionsFork = AT.forkable(
  // TODO: figure out why this prevents `forkable` from producing an empty object as the last interaction
  AT.tap(() => {})(interactions));
  const documentedInteractions = _operations.DocumentedInteractions.fromCapturedInteractions(interactionsFork.fork(), spec);
  const undocumentedOperations = _operations.UndocumentedOperations.fromCapturedInteractions(interactionsFork.fork(), spec);
  const capturedInteractions = interactionsFork.fork();
  interactionsFork.start();
  const matchingObservations = async function* () {
    for await (let documentedInteractionOption of documentedInteractions) {
      var _documentedInteractio;
      if (documentedInteractionOption.none) continue;
      let documentedInteraction = documentedInteractionOption.unwrap();
      coverage.operationInteraction(documentedInteraction.operation.pathPattern, documentedInteraction.operation.method, Boolean(documentedInteraction.interaction.request.body), (_documentedInteractio = documentedInteraction.interaction.response) === null || _documentedInteractio === void 0 ? void 0 : _documentedInteractio.statusCode);
      yield {
        kind: StatusObservationKind.InteractionMatchedOperation,
        capturedPath: documentedInteraction.interaction.request.path,
        path: documentedInteraction.operation.pathPattern,
        method: documentedInteraction.operation.method
      };
    }
  }();
  const unmatchingObservations = async function* () {
    for await (let undocumentedOperation of undocumentedOperations) {
      if (undocumentedOperation.type === _operations.UndocumentedOperationType.MissingMethod) {
        yield {
          kind: StatusObservationKind.InteractionUnmatchedMethod,
          path: undocumentedOperation.pathPattern,
          method: undocumentedOperation.method
        };
      } else if (undocumentedOperation.type === _operations.UndocumentedOperationType.MissingPath) {
        for (let method of undocumentedOperation.methods) {
          yield {
            kind: StatusObservationKind.InteractionUnmatchedPath,
            path: undocumentedOperation.pathPattern,
            method
          };
        }
      }
    }
  }();
  const captureObservations = AT.map(function (interaction) {
    return {
      kind: StatusObservationKind.InteractionCaptured,
      path: interaction.request.path,
      method: interaction.request.method
    };
  })(capturedInteractions);
  return {
    observations: AT.merge(captureObservations, matchingObservations, unmatchingObservations),
    coverage
  };
}
let StatusObservationKind = exports.StatusObservationKind = /*#__PURE__*/function (StatusObservationKind) {
  StatusObservationKind["InteractionCaptured"] = "interaction-captured";
  StatusObservationKind["InteractionMatchedOperation"] = "interaction-matched-operation";
  StatusObservationKind["InteractionUnmatchedMethod"] = "interaction-unmatched-method";
  StatusObservationKind["InteractionUnmatchedPath"] = "interaction-unmatched-path";
  return StatusObservationKind;
}({});
function addOperations(spec, requiredOperations, interactions) {
  const openAPIVersion = (0, _openapiIo.checkOpenAPIVersion)(spec);
  const observing = new AT.Subject();
  const observers = {
    // operations
    requiredOperations(operations) {
      observing.onNext({
        kind: AddObservationKind.RequiredOperations,
        operations
      });
    },
    undocumentedOperation(op) {
      if (op.type === _operations.UndocumentedOperationType.MissingPath) {
        observing.onNext({
          kind: AddObservationKind.UnmatchedPath,
          requiredPath: op.pathPattern
        });
      } else if (op.type === _operations.UndocumentedOperationType.MissingMethod) {
        observing.onNext({
          kind: AddObservationKind.UnmatchedMethod,
          matchedPathPattern: op.pathPattern,
          requiredMethod: op.method
        });
      }
    },
    newOperation(op) {
      observing.onNext({
        kind: AddObservationKind.NewOperation,
        pathPattern: op.pathPattern,
        method: op.method
      });
    },
    // interactions

    capturedInteraction(interaction) {
      observing.onNext({
        kind: AddObservationKind.InteractionCaptured,
        path: interaction.request.path,
        method: interaction.request.method
      });
    },
    documentedInteraction(interaction) {
      observing.onNext({
        kind: AddObservationKind.InteractionMatchedOperation,
        capturedPath: interaction.interaction.request.path,
        pathPattern: interaction.operation.pathPattern,
        method: interaction.operation.method
      });
    },
    documentedInteractionBody(interaction, body) {
      observing.onNext({
        kind: AddObservationKind.InteractionBodyMatched,
        capturedPath: interaction.interaction.request.path,
        pathPattern: interaction.operation.pathPattern,
        method: interaction.operation.method,
        decodable: body.body.some,
        capturedContentType: body.bodySource.contentType
      });
    },
    interactionPatch(interaction, patch) {
      observing.onNext({
        kind: AddObservationKind.InteractionPatchGenerated,
        capturedPath: interaction.interaction.request.path,
        pathPattern: interaction.operation.pathPattern,
        method: interaction.operation.method,
        description: patch.description
      });
    }
  };
  const specPatches = async function* () {
    let patchedSpec = spec;
    let addedOperations = [];

    // phase one: documented all undocumented operations
    let updatingSpec = new AT.Subject();
    const undocumentedOperations = _operations.UndocumentedOperations.fromPairs(AT.from(requiredOperations), spec, updatingSpec.iterator);
    for await (let undocumentedOperation of undocumentedOperations) {
      observers.undocumentedOperation(undocumentedOperation);
      let patches = _patches2.LegacySpecPatches.undocumentedOperation(undocumentedOperation);
      for (let patch of patches) {
        patchedSpec = _patches.SpecPatch.applyPatch(patch, patchedSpec);
        yield patch;
      }
      if (undocumentedOperation.type === _operations.UndocumentedOperationType.MissingPath) {
        for (let method of undocumentedOperation.methods) {
          let addedOperation = {
            pathPattern: undocumentedOperation.pathPattern,
            method
          };
          addedOperations.push(addedOperation);
          observers.newOperation(addedOperation);
        }
      } else if (undocumentedOperation.type === _operations.UndocumentedOperationType.MissingMethod) {
        let addedOperation = {
          pathPattern: undocumentedOperation.pathPattern,
          method: undocumentedOperation.method
        };
        addedOperations.push(addedOperation);
        observers.newOperation(addedOperation);
      }
      updatingSpec.onNext(patchedSpec);
    }
    updatingSpec.onCompleted();

    // phase two: patches to document requests, responses and their bodies
    updatingSpec = new AT.Subject(); // new stream of updates for generating of documented interactions
    const documentedInteractions = _operations.DocumentedInteractions.fromCapturedInteractions(AT.tap(observers.capturedInteraction)(interactions), patchedSpec, updatingSpec.iterator);
    for await (let documentedInteractionOption of documentedInteractions) {
      var _patchedSpec$componen;
      if (documentedInteractionOption.none) continue;
      let documentedInteraction = documentedInteractionOption.unwrap();
      let operation = documentedInteraction.operation;
      if (!addedOperations.find(({
        pathPattern,
        method
      }) => pathPattern === operation.pathPattern && method === operation.method)) {
        updatingSpec.onNext(patchedSpec); // nothing changed, still report to keep documented interactions flowing
        continue;
      }
      observers.documentedInteraction(documentedInteraction);

      // phase one: operation patches, making sure all requests / responses are documented
      let opPatches = _patches.SpecPatches.operationAdditions(documentedInteraction);
      for await (let patch of opPatches) {
        patchedSpec = _patches.SpecPatch.applyPatch(patch, patchedSpec);
        yield patch;
        observers.interactionPatch(documentedInteraction, patch);
      }

      // phase two: shape patches, describing request / response bodies in detail
      documentedInteraction.operation = _operations.Operation.fromOperationObject(documentedInteraction.operation.pathPattern, documentedInteraction.operation.method, _jsonPointerHelpers.jsonPointerHelpers.get(patchedSpec, documentedInteraction.specJsonPath));
      let documentedBodies = _documentedBodies.DocumentedBodies.fromDocumentedInteraction(documentedInteraction);
      let shapePatches = _patches.SpecPatches.shapeAdditions(AT.tap(body => {
        observers.documentedInteractionBody(documentedInteraction, body);
      })(documentedBodies), openAPIVersion);
      const addedPaths = new Set();
      for await (let patch of shapePatches) {
        // For capture v1, we skip unpatchable diffs
        if ('unpatchable' in patch) continue;

        // register additions
        addedPaths.add(patch.path);
        patchedSpec = _patches.SpecPatch.applyPatch(patch, patchedSpec);
        yield patch;
        observers.interactionPatch(documentedInteraction, patch);
      }
      const schemaInventory = new _schemaInventory.SchemaInventory();
      schemaInventory.addSchemas(_jsonPointerHelpers.jsonPointerHelpers.compile(['components', 'schemas']), ((_patchedSpec$componen = patchedSpec.components) === null || _patchedSpec$componen === void 0 ? void 0 : _patchedSpec$componen.schemas) || {});
      const refRefactors = schemaInventory.refsForAdditions(addedPaths, patchedSpec);
      for await (let patch of refRefactors) {
        patchedSpec = _patches.SpecPatch.applyPatch(patch, patchedSpec);
        yield patch;
        observers.interactionPatch(documentedInteraction, patch);
      }
      updatingSpec.onNext(patchedSpec);
    }
    updatingSpec.onCompleted();
  }();

  // additions only, so we only safely extend the spec
  const specAdditions = _patches2.LegacySpecPatches.additions(specPatches);

  // making sure we end observations once we're done generating patches
  const observedResults = async function* () {
    yield* specAdditions;
    observing.onCompleted();
  }();
  return {
    results: observedResults,
    observations: observing.iterator
  };
}
function updateSpecFiles(updatePatches, sourcemap) {
  const stats = {
    filesWithOverwrittenYamlComments: new Set()
  };
  const observing = new AT.Subject();
  const observers = {
    fileOperation(op) {},
    updatedFile(file) {
      observing.onNext({
        kind: AddObservationKind.SpecFileUpdated,
        path: file.path,
        overwrittenComments: stats.filesWithOverwrittenYamlComments.has(file.path)
      });
    }
  };
  const specFiles = [..._specs.SpecFiles.fromSourceMap(sourcemap)];
  const fileOperations = AT.tap(observers.fileOperation)(_specs.SpecFileOperations.fromSpecPatches(updatePatches, sourcemap));
  const updatedSpecFiles = AT.tap(observers.updatedFile)(_specs.SpecFiles.patch(specFiles, fileOperations));

  // making sure we end observations once we're done generating patches
  const observedResults = async function* () {
    yield* updatedSpecFiles;
    observing.onCompleted();
  }();
  return {
    results: observedResults,
    observations: observing.iterator
  };
}
let AddObservationKind = exports.AddObservationKind = /*#__PURE__*/function (AddObservationKind) {
  AddObservationKind["UnmatchedPath"] = "unmatched-path";
  AddObservationKind["UnmatchedMethod"] = "unmatched-method";
  AddObservationKind["NewOperation"] = "new-operation";
  AddObservationKind["SpecFileUpdated"] = "spec-file-updated";
  AddObservationKind["RequiredOperations"] = "required-operations";
  AddObservationKind["InteractionBodyMatched"] = "interaction-body-matched";
  AddObservationKind["InteractionCaptured"] = "interaction-captured";
  AddObservationKind["InteractionMatchedOperation"] = "interaction-matched-operation";
  AddObservationKind["InteractionPatchGenerated"] = "interaction-patch-generated";
  return AddObservationKind;
}({});
async function collectStats(observations) {
  const newOperations = [];
  for await (let observation of observations) {
    if (observation.kind === AddObservationKind.NewOperation) {
      newOperations.push({
        method: observation.method,
        pathPattern: observation.pathPattern,
        jsonPointer: _jsonPointerHelpers.jsonPointerHelpers.compile(['paths', observation.pathPattern, observation.method])
      });
    }
  }
  return newOperations;
}