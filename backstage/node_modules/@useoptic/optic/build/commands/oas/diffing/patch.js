"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UpdateObservationKind = void 0;
exports.patchOperationsAsNeeded = patchOperationsAsNeeded;
exports.renderDiffs = renderDiffs;
exports.renderUpdateStats = renderUpdateStats;
exports.updateByInteractions = updateByInteractions;
exports.updateSpecFiles = updateSpecFiles;
var _specs = require("../specs");
var _openapiIo = require("@useoptic/openapi-io");
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _chalk = _interopRequireDefault(require("chalk"));
var _asyncTools = require("../lib/async-tools");
var _operations = require("../operations");
var _documentedBodies = require("../../capture/patches/patchers/shapes/documented-bodies");
var _update = require("../reporters/update");
var _nextCommand = require("../reporters/next-command");
var _patches = require("../../capture/patches/patchers/spec/patches");
var _patches2 = require("../specs/streams/patches");
async function patchOperationsAsNeeded(patchInteractions, spec, sourcemap, isAddAll = true, filterToOperations = []) {
  let {
    results: updatePatches,
    observations: updateObservations
  } = updateByInteractions(spec, patchInteractions, isAddAll, filterToOperations);
  let {
    results: updatedSpecFiles,
    observations: fileObservations
  } = updateSpecFiles(updatePatches, sourcemap);
  const stats = renderUpdateStats(updateObservations);
  const writingSpecFiles = async function () {
    for await (let writtenFilePath of _specs.SpecFiles.writeFiles(updatedSpecFiles)) {
      // console.log(`Updated ${writtenFilePath}`);
    }
  }();
  await Promise.all([writingSpecFiles, stats]);
  return await stats;
}
async function renderDiffs(specPath, sourcemap, spec, patches, coverage) {
  const logger = (0, _openapiIo.jsonPointerLogger)(sourcemap);
  let stats = {
    totalDiffCount: 0,
    undocumentedBody: 0,
    shapeDiff: 0
  };
  for await (const patch of patches) {
    const {
      diff,
      path,
      description,
      groupedOperations
    } = patch;
    const [_, pathPattern, method] = _jsonPointerHelpers.jsonPointerHelpers.decode(path);
    if (!diff || groupedOperations.length === 0) continue;
    coverage.shapeDiff(patch);
    stats.totalDiffCount++;
    if (diff.kind === 'UnmatchdResponseBody' || diff.kind === 'UnmatchedRequestBody' || diff.kind === 'UnmatchedResponseStatusCode') {
      stats.undocumentedBody++;
      const description = diff.kind === 'UnmatchedResponseStatusCode' ? `${diff.statusCode} Response ${diff.contentType}` : diff.kind === 'UnmatchedRequestBody' ? `${diff.contentType} Request body` : diff.kind === 'UnmatchdResponseBody' ? `${diff.statusCode} Response ${diff.contentType}` : '';
      renderBodyDiff(specPath, description, method, pathPattern);
    } else if (diff.kind === 'AdditionalProperty') {
      // filter out dependent diffs
      if (!_jsonPointerHelpers.jsonPointerHelpers.tryGet(spec, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.parentObjectPath)).match) continue;
      stats.shapeDiff++;
      renderShapeDiff(specPath, diff, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.parentObjectPath), `Undocumented '${diff.key}'`, logger, method, pathPattern);
    } else if (diff.kind === 'UnmatchedType') {
      // filter out dependent diffs
      if (!_jsonPointerHelpers.jsonPointerHelpers.tryGet(spec, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.propertyPath)).match) continue;
      stats.shapeDiff++;
      renderShapeDiff(specPath, diff, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.propertyPath), `[Actual] ${JSON.stringify(diff.example)}`, logger, method, pathPattern);
    } else if (diff.kind === 'MissingRequiredProperty') {
      // filter out dependent diffs
      if (!_jsonPointerHelpers.jsonPointerHelpers.tryGet(spec, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.propertyPath)).match) continue;
      stats.shapeDiff++;
      renderShapeDiff(specPath, diff, _jsonPointerHelpers.jsonPointerHelpers.join(path, diff.propertyPath), `missing`, logger, method, pathPattern);
    } else {
      console.log('Unrecognized diff type ' + diff.kind);
    }
  }
  return stats;
}
function renderShapeDiff(specPath, diff, pathToHighlight, error, logger, method, pathPattern) {
  const lines = `${_chalk.default.bgRed('  Diff  ')} ${diff.description}
operation: ${_chalk.default.bold(`${method} ${pathPattern}`)}  
${logger.log(pathToHighlight, {
    highlightColor: 'yellow',
    observation: error
  })}
${(0, _nextCommand.nextCommand)(`fix schema by running`, `optic update ${specPath} "${method} ${pathPattern}"`)}\n`;
  console.log(lines);
}
function renderBodyDiff(specPath, description, method, pathPattern) {
  const lines = `${_chalk.default.bgYellow('  Undocumented  ')} ${description}
  operation: ${_chalk.default.bold(`${method} ${pathPattern}`)}  
${(0, _nextCommand.nextCommand)(`document new body by running`, `optic update ${specPath} "${method} ${pathPattern}"`)}\n`;
  console.log(lines);
}
function updateByInteractions(spec, interactions, isAddAll = true, filterToOperations = []) {
  const openAPIVersion = (0, _openapiIo.checkOpenAPIVersion)(spec);
  const updatingSpec = new _asyncTools.Subject();
  const specUpdates = updatingSpec.iterator;
  const observing = new _asyncTools.Subject();
  const observers = {
    capturedInteraction(interaction) {
      observing.onNext({
        kind: UpdateObservationKind.InteractionCaptured,
        path: interaction.request.path,
        method: interaction.request.method
      });
    },
    documentedInteractionBody(interaction, body) {
      observing.onNext({
        kind: UpdateObservationKind.InteractionBodyMatched,
        capturedPath: interaction.interaction.request.path,
        pathPattern: interaction.operation.pathPattern,
        method: interaction.operation.method,
        decodable: body.body.some,
        capturedContentType: body.bodySource.contentType
      });
    },
    documentedInteraction(interaction) {
      observing.onNext({
        kind: UpdateObservationKind.InteractionMatchedOperation,
        capturedPath: interaction.interaction.request.path,
        pathPattern: interaction.operation.pathPattern,
        method: interaction.operation.method
      });
    },
    interactionPatch(interaction, patch) {
      observing.onNext({
        kind: UpdateObservationKind.InteractionPatchGenerated,
        capturedPath: interaction.interaction.request.path,
        pathPattern: interaction.operation.pathPattern,
        method: interaction.operation.method,
        description: patch.description
      });
    }
  };
  const documentedInteractions = _operations.DocumentedInteractions.fromCapturedInteractions((0, _asyncTools.tap)(observers.capturedInteraction)(interactions), spec, specUpdates, isAddAll, filterToOperations);
  const specPatches = async function* () {
    let patchedSpec = spec;
    for await (let documentedInteractionOption of documentedInteractions) {
      if (documentedInteractionOption.none) continue;
      let documentedInteraction = documentedInteractionOption.unwrap();
      observers.documentedInteraction(documentedInteraction);

      // phase one: operation patches, making sure all requests / responses are documented
      let opPatches = _patches.SpecPatches.operationAdditions(documentedInteraction);
      for await (let patch of opPatches) {
        patchedSpec = _patches.SpecPatch.applyPatch(patch, patchedSpec);
        yield patch;
        observers.interactionPatch(documentedInteraction, patch);
      }

      // phase two: shape patches, describing request / response bodies in detail
      documentedInteraction.operation = _operations.Operation.fromOperationObject(documentedInteraction.operation.pathPattern, documentedInteraction.operation.method, _jsonPointerHelpers.jsonPointerHelpers.get(patchedSpec, documentedInteraction.specJsonPath));
      let documentedBodies = _documentedBodies.DocumentedBodies.fromDocumentedInteraction(documentedInteraction);
      let shapePatches = _patches.SpecPatches.shapeAdditions((0, _asyncTools.tap)(body => {
        observers.documentedInteractionBody(documentedInteraction, body);
      })(documentedBodies), openAPIVersion);
      for await (let patch of shapePatches) {
        // For capture v1, we skip unpatchable diffs
        if ('unpatchable' in patch) continue;
        patchedSpec = _patches.SpecPatch.applyPatch(patch, patchedSpec);
        yield patch;
        observers.interactionPatch(documentedInteraction, patch);
      }
      updatingSpec.onNext(patchedSpec);
    }
    updatingSpec.onCompleted();
  }();

  // additions only, so we only safely extend the spec
  const specAdditions = _patches2.LegacySpecPatches.additions(specPatches);

  // making sure we end observations once we're done generating patches
  const observedResults = async function* () {
    yield* specAdditions;
    observing.onCompleted();
  }();
  return {
    results: observedResults,
    observations: observing.iterator
  };
}
function updateSpecFiles(updatePatches, sourcemap) {
  const stats = {
    filesWithOverwrittenYamlComments: new Set()
  };
  const observing = new _asyncTools.Subject();
  const observers = {
    fileOperation(op) {},
    updatedFile(file) {
      observing.onNext({
        kind: UpdateObservationKind.SpecFileUpdated,
        path: file.path,
        overwrittenComments: stats.filesWithOverwrittenYamlComments.has(file.path)
      });
    }
  };
  const specFiles = [..._specs.SpecFiles.fromSourceMap(sourcemap)];
  const fileOperations = (0, _asyncTools.tap)(observers.fileOperation)(_specs.SpecFileOperations.fromSpecPatches(updatePatches, sourcemap));
  const updatedSpecFiles = (0, _asyncTools.tap)(observers.updatedFile)(_specs.SpecFiles.patch(specFiles, fileOperations));

  // making sure we end observations once we're done generating patches
  const observedResults = async function* () {
    yield* updatedSpecFiles;
    observing.onCompleted();
  }();
  return {
    results: observedResults,
    observations: observing.iterator
  };
}
let UpdateObservationKind = exports.UpdateObservationKind = /*#__PURE__*/function (UpdateObservationKind) {
  UpdateObservationKind["InteractionBodyMatched"] = "interaction-body-matched";
  UpdateObservationKind["InteractionCaptured"] = "interaction-captured";
  UpdateObservationKind["InteractionMatchedOperation"] = "interaction-matched-operation";
  UpdateObservationKind["InteractionPatchGenerated"] = "interaction-patch-generated";
  UpdateObservationKind["SpecFileUpdated"] = "spec-file-updated";
  return UpdateObservationKind;
}({});
async function renderUpdateStats(updateObservations) {
  console.log(_chalk.default.blueBright('» ') + 'Updating operations...');
  const reporter = await (0, _update.updateReporter)(process.stderr, process.cwd());
  let interactions = 0,
    patched = 0,
    fileUpdates = 0;
  for await (let observation of updateObservations) {
    if (observation.kind === UpdateObservationKind.InteractionCaptured) {
      let {
        path,
        method
      } = observation;
      reporter.capturedInteraction({
        path,
        method
      });
    } else if (observation.kind === UpdateObservationKind.InteractionMatchedOperation) {
      interactions++;
      let {
        method,
        pathPattern
      } = observation;
      reporter.matchedInteraction({
        method,
        pathPattern
      });
    } else if (observation.kind === UpdateObservationKind.InteractionPatchGenerated) {
      patched++;
      let {
        method,
        pathPattern,
        capturedPath,
        description
      } = observation;
      reporter.patch({
        method,
        pathPattern
      }, capturedPath, description);
    } else if (observation.kind === UpdateObservationKind.SpecFileUpdated) {
      fileUpdates++;
      let {
        path
      } = observation;
      reporter.fileUpdated(path);
    }
  }
  reporter.finish();
  return {
    interactions,
    patched,
    fileUpdates
  };
}