"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  forkable: true,
  tap: true,
  concat: true,
  collect: true,
  unwrap: true,
  unwrapOr: true
};
exports.collect = collect;
exports.concat = concat;
exports.forkable = forkable;
exports.tap = tap;
exports.unwrap = unwrap;
exports.unwrapOr = unwrapOr;
var _esnext = require("axax/esnext");
Object.keys(_esnext).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _esnext[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _esnext[key];
    }
  });
});
// Fork an async iterable and share the backpressure (preventing memory bloat, but
// reading at rate of slowest consumer).
// Won't allow new forks once consumption has started through `forkable.start()`.
function forkable(iterable) {
  const source = iterable[Symbol.asyncIterator]();
  let branches = [];
  let started = false;
  let reading = false;
  let pendingRead = Promise.resolve();
  let pendingStart = new Deferred();
  let pendingResults = [];
  let pendingConsumers = Promise.resolve([]);
  let deferredConsumers = [];
  async function next() {
    started = true;
    if (reading) return;
    let resolveRead;
    reading = true;
    pendingRead = new Promise(resolve => resolveRead = resolve);
    await Promise.all(deferredConsumers.map(({
      promise
    }) => promise));
    deferredConsumers = [];
    pendingResults = [];
    let pendingResult = source.next();
    pendingResults = branches.map(() => pendingResult);
    deferredConsumers = branches.map(() => new Deferred());
    pendingConsumers = Promise.all(deferredConsumers.map(({
      promise
    }) => promise));
    await pendingResult;
    reading = false;
    resolveRead();
  }
  function branch(i) {
    if (started) throw new Error('Cannot fork async iterable after consumption has already started');
    return async function* () {
      await pendingStart.promise;
      while (true) {
        let pendingResult = pendingResults[i];
        pendingResults[i] = null;
        if (!pendingResult) {
          if (!reading) {
            await next();
          } else {
            await pendingRead;
          }
        } else {
          let result = await pendingResult;
          if (result.value) yield result.value;
          let deferred = deferredConsumers[i];
          if (deferred) {
            setTimeout(() => {
              deferred.resolve();
            });
          }
          if (result.done) return;
          await pendingConsumers;
        }
      }
    };
  }
  return {
    fork() {
      let newBranchIndex = branches.length;
      let newBranch = branch(newBranchIndex);
      branches.push(newBranch);
      return newBranch();
    },
    start() {
      started = true;
      pendingStart.resolve();
    }
  };
}
class Deferred {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
}

// execute a backpressure-less side effect
function tap(predicate) {
  return async function* (source) {
    for await (let chunk of source) {
      predicate(chunk);
      yield chunk;
    }
  };
}
async function* concat(...iters) {
  for (let iter of iters) {
    yield* iter;
  }
}
async function collect(source) {
  let results = [];
  for await (let item of source) {
    results.push(item);
  }
  return results;
}
async function* unwrap(source) {
  for await (let result of source) {
    yield result.unwrap();
  }
}
async function* unwrapOr(source, handler) {
  for await (let result of source) {
    if (result.ok) {
      yield result.val;
    } else {
      await handler(result.val);
    }
  }
}