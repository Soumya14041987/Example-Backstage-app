"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DocumentedInteractions", {
  enumerable: true,
  get: function () {
    return _documentedInteractions.DocumentedInteractions;
  }
});
exports.UndocumentedOperationType = exports.PathComponents = exports.PathComponentKind = exports.PathComponent = exports.Operation = exports.HttpMethods = void 0;
Object.defineProperty(exports, "UndocumentedOperations", {
  enumerable: true,
  get: function () {
    return _undocumented.UndocumentedOperations;
  }
});
exports.findBody = findBody;
exports.findResponse = findResponse;
exports.statusRangePattern = void 0;
var _specs = require("../specs");
var _tsInvariant = _interopRequireDefault(require("ts-invariant"));
var _whatwgMimetype = _interopRequireDefault(require("whatwg-mimetype"));
var _documentedInteractions = require("./streams/documented-interactions");
var _undocumented = require("./streams/undocumented");
class Operation {
  static fromOperationObject(pathPattern, method, operation) {
    const requestBody = operation.requestBody;
    (0, _tsInvariant.default)(!requestBody || isNotReferenceObject(requestBody), `operation expected to not have any references, found in request body, pathPattern=${pathPattern} method=${method}`);
    const responses = Object.fromEntries(Object.entries(operation.responses).map(([code, response]) => {
      (0, _tsInvariant.default)(isNotReferenceObject(response), `operation expected to not have any reference, found in response, statusCode=${code} pathPattern=${pathPattern} method=${method}`);
      return [code, response];
    }));
    return {
      pathPattern,
      method,
      ...operation,
      requestBody,
      responses
    };
  }
  static isHttpMethod(method) {
    return !!Object.values(HttpMethods).find(m => m === method);
  }
}
exports.Operation = Operation;
let UndocumentedOperationType = exports.UndocumentedOperationType = /*#__PURE__*/function (UndocumentedOperationType) {
  UndocumentedOperationType["MissingMethod"] = "missing-method";
  UndocumentedOperationType["MissingPath"] = "missing-path";
  UndocumentedOperationType["MissingPathParameter"] = "missing-path-parameter";
  return UndocumentedOperationType;
}({});
let PathComponentKind = exports.PathComponentKind = /*#__PURE__*/function (PathComponentKind) {
  PathComponentKind["Literal"] = "literal";
  PathComponentKind["Template"] = "template";
  return PathComponentKind;
}({});
class PathComponent {
  static isTemplate(component) {
    return component.kind === PathComponentKind.Template;
  }
}
exports.PathComponent = PathComponent;
const fragmentPattern = /{(.+)}/;
class PathComponents {
  static fromPath(path) {
    /*
    Copied from https://github.com/stoplightio/prism/blob/0ad49235879ad4f7fcafa7b5badcb763b0c37a6a/packages/http/src/router/matchPath.ts
    under https://github.com/stoplightio/prism/blob/master/LICENSE
    */
    if (!path.startsWith('/')) {
      path = `/${path}`;
    }
    return path.split('/').slice(1).map(decodePathFragment).map(fragment => {
      const templateName = fragment.match(fragmentPattern);
      return templateName ? {
        kind: PathComponentKind.Template,
        name: templateName[1]
      } : {
        kind: PathComponentKind.Literal,
        name: fragment
      };
    });
  }
}
exports.PathComponents = PathComponents;
function decodePathFragment(pathFragment) {
  try {
    return pathFragment && decodeURIComponent(pathFragment);
  } catch (_) {
    return pathFragment;
  }
}
const HttpMethods = exports.HttpMethods = _specs.OpenAPIV3.HttpMethods;
function findResponse({
  responses
}, statusCode) {
  let exactMatch = null;
  let rangeMatch = null;
  let defaultMatch = null;

  // oldskool for loop, because no object.find and work arounds are messy
  for (let [code, response] of Object.entries(responses)) {
    if (code === statusCode) {
      exactMatch = [response, code];
      break; // exact match found, so we can stop looking
    }
    if (!rangeMatch && statusRangePattern.test(statusCode) && statusCode.substring(0, 1) === code.substring(0, 1)) {
      rangeMatch = [response, code];
      continue;
    }
    if (!defaultMatch && code === 'default') {
      defaultMatch = [response, code];
    }
    if (exactMatch && rangeMatch && defaultMatch) break;
  }
  return exactMatch || rangeMatch || defaultMatch;
}
function findBody(bodyObject, contentType) {
  if (!contentType) return null;
  if (!bodyObject.content) return null;
  let parsedType = _whatwgMimetype.default.parse(contentType);
  if (!parsedType) return null;
  let normalizedType = parsedType.toString();
  let exactMatch = null;
  let essenceMatch = null;
  let typeRangeMatch = null;
  let rangeMatch = null;
  for (let [rawType, media] of Object.entries(bodyObject.content)) {
    let type = new _whatwgMimetype.default(rawType);
    let normalized = type.toString();
    if (type.toString() === normalizedType) {
      exactMatch = [media, rawType];
      break; // exact match found, lets stop looking
    }
    if (!essenceMatch && type.essence === parsedType.essence) {
      essenceMatch = [media, rawType];
      continue;
    }
    if (!typeRangeMatch && type.type === parsedType.type && type.subtype === '*') {
      typeRangeMatch = [media, rawType];
    }
    if (!rangeMatch && type.type === '*' && type.subtype === '*') {
      rangeMatch = [media, rawType];
    }
    if (exactMatch && essenceMatch && typeRangeMatch && rangeMatch) break;
  }
  return exactMatch || essenceMatch || typeRangeMatch || rangeMatch;
}
const statusRangePattern = exports.statusRangePattern = /[245]xx/;
const isNotReferenceObject = maybeReference => {
  return !('$ref' in maybeReference);
};