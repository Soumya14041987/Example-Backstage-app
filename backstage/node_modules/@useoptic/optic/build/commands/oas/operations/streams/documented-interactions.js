"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocumentedInteractions = void 0;
var _ = require("..");
var _queries = require("../../../capture/operations/queries");
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _tsResults = require("ts-results");
class DocumentedInteractions {
  static async *fromCapturedInteractions(interactions, spec, specUpdates, isAddAll = true, filterToOperations = []) {
    // assumption: no new operations will be added over the life-time of this stream
    const queries = new _queries.OperationQueries((0, _queries.specToOperations)(spec));
    const specUpdatesIterator = specUpdates && specUpdates[Symbol.asyncIterator]();
    for await (let interaction of interactions) {
      // find matching interaction operation by matching path and method
      const matchedOperationResult = queries.findOperation(interaction.request.path, interaction.request.method);
      if (matchedOperationResult.err) {
        console.warn('Could not conclusively match interaction to operation from spec:', matchedOperationResult.val);
        yield _tsResults.None;
        continue;
      } else if (matchedOperationResult.val.none) {
        yield _tsResults.None;
        continue; // no match
      }
      const matchedOperation = matchedOperationResult.unwrap().unwrap();
      const specPath = _jsonPointerHelpers.jsonPointerHelpers.compile(['paths', matchedOperation.pathPattern, matchedOperation.method]);
      let operationObject = _jsonPointerHelpers.jsonPointerHelpers.get(spec, specPath); // given the validation we've done above, this should be safe

      if (isAddAll || filterToOperations.length && filterToOperations.some(op => op.pathPattern === matchedOperation.pathPattern && op.methods.some(method => matchedOperation.method))) {
        yield (0, _tsResults.Some)({
          interaction,
          operation: _.Operation.fromOperationObject(matchedOperation.pathPattern, matchedOperation.method, operationObject),
          specJsonPath: specPath
        });
      } else {
        yield _tsResults.None;
        continue; // matched but skipped
      }
      if (specUpdatesIterator) {
        let newSpec = await specUpdatesIterator.next();
        spec = newSpec.value;
      }
    }
  }
}
exports.DocumentedInteractions = DocumentedInteractions;