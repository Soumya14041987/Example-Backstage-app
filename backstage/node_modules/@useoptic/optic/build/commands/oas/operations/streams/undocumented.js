"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UndocumentedOperations = void 0;
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _ = require("..");
var _diffs = require("../diffs");
var AT = _interopRequireWildcard(require("../../lib/async-tools"));
var _minimatch = require("minimatch");
var _specs = require("../../../../utils/specs");
var _types = require("../../../capture/patches/patchers/spec/types");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
class UndocumentedOperations {
  static async *fromPairs(operations, spec, specUpdates) {
    const specUpdatesIterator = specUpdates && specUpdates[Symbol.asyncIterator]();
    const ignorePatterns = (0, _specs.getIgnorePaths)(spec);
    const shouldBeIgnored = (path, method) => ignorePatterns.some(ignore => {
      if (method && ignore.method) {
        return method === ignore.method && (0, _minimatch.minimatch)(path, ignore.path);
      } else {
        return (0, _minimatch.minimatch)(path, ignore.path);
      }
    });
    const filterMethods = methods => {
      return methods.filter(i => i !== 'options' && i !== 'head');
    };
    for await (let operation of operations) {
      // TODO: figure out whether we can create queries once and update it incrementally,
      // recreating these facts constantly can get expens ive

      let diffs = (0, _diffs.diffOperationWithSpec)(operation, spec);
      let yieldedResult = false; // needed as we're basically filtering

      for (let diff of diffs) {
        if (diff.kind === _types.OperationDiffResultKind.UnmatchedPath) {
          const methodsFiltered = filterMethods(operation.methods);
          if (shouldBeIgnored(diff.subject)) continue;
          if (methodsFiltered.length === 0) continue;
          if (diff.subject) yieldedResult = true;
          yield {
            type: _.UndocumentedOperationType.MissingPath,
            pathPattern: diff.subject,
            pathParameters: _.PathComponents.fromPath(diff.subject).filter(_.PathComponent.isTemplate).map(({
              name
            }) => name),
            methods: methodsFiltered,
            specPath: _jsonPointerHelpers.jsonPointerHelpers.compile(['paths', diff.subject])
          };
        } else if (diff.kind === _types.OperationDiffResultKind.UnmatchedMethod) {
          if (shouldBeIgnored(diff.pathPattern, diff.subject)) continue;
          if (filterMethods([diff.subject]).length === 0) continue;
          yieldedResult = true;
          yield {
            type: _.UndocumentedOperationType.MissingMethod,
            pathPattern: diff.pathPattern,
            method: diff.subject,
            specPath: _jsonPointerHelpers.jsonPointerHelpers.compile(['paths', diff.pathPattern, diff.subject])
          };
        }
      }
      if (specUpdatesIterator && yieldedResult) {
        let newSpec = await specUpdatesIterator.next();
        spec = newSpec.value;
      }
    }
  }
  static async *fromCapturedInteractions(interactions, spec, specUpdates) {
    const operations = AT.map(interaction => {
      return {
        pathPattern: interaction.request.path,
        methods: [interaction.request.method]
      };
    })(interactions);
    yield* UndocumentedOperations.fromPairs(operations, spec, specUpdates);
  }
}
exports.UndocumentedOperations = UndocumentedOperations;