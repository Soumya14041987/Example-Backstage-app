"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCertStore = getCertStore;
exports.setupTlsCommand = setupTlsCommand;
var _commander = require("commander");
var _feedback = require("./reporters/feedback");
var _conf = _interopRequireDefault(require("conf"));
var _path = _interopRequireDefault(require("path"));
var _promises = require("stream/promises");
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _tsResults = require("ts-results");
var _chalk = _interopRequireDefault(require("chalk"));
var _shellUtils = require("./lib/shell-utils");
var _proxy = require("./captures/proxy");
async function setupTlsCommand() {
  const command = new _commander.Command('setup-tls');
  const feedback = (0, _feedback.createCommandFeedback)(command);
  command.description('trust a CA certificate (generated on your machine) to capture TLS traffic').option('--del', 'delete the current CA certificate for use').action(async () => {
    const options = command.optsWithGlobals();
    const certStore = getCertStore();
    if (options.del) {
      certStore.delete();
      return feedback.notable('CA certificate deleted for use by proxy');
    }
    let maybeCa = certStore.get();
    let ca;
    if (maybeCa.none || _proxy.ProxyCertAuthority.hasExpired(maybeCa.val, new Date())) {
      ca = await _proxy.ProxyCertAuthority.generate();
      certStore.set(ca);
      await feedback.instruction(`Generated a CA certificate for HTTPS requests`);
    } else {
      ca = maybeCa.val;
    }
    async function writeCertNamed(name) {
      const certPath = _path.default.join('.', name);
      let absoluteFilePath = _path.default.resolve(certPath);
      const destination = _fsExtra.default.createWriteStream(absoluteFilePath);
      await writeCert(ca, destination);
      return absoluteFilePath;
    }
    console.log('Hey Optic here. We take privacy seriously so we wanted to let you know how intercepting TLS traffic works: A self-signed certificate generated on your machine (we do not have it) is added to your trust chain. That allows the Optic proxy to read TLS traffic that is sent through it. The CLI will save TLS traffic to the target host (your API) in the tmp directory. It is never sent to us and all the processing happens locally. All the code is Open Source https://github.com/opticdev/optic');
    switch (_shellUtils.platform) {
      case 'mac':
        {
          await (0, _shellUtils.exitIfNotElevated)('Run this command with sudo to trust the certificate');
          const certFilePath = await writeCertNamed('optic.local.cert');
          console.log('Trusting Cert. This may take a few seconds. If you see a Keychain prompt appear, enter your password');
          try {
            await (0, _shellUtils.runCommand)(`security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain ${certFilePath}`);
            console.log(_chalk.default.green("Certificate trusted. 'oas capture' can now see traffic sent to https hosts when Optic is running"));
            await _fsExtra.default.unlink(certFilePath);
          } catch (e) {
            console.error(_chalk.default.red('Error trusting certificate ' + e));
            console.error(_chalk.default.red('Try trusting it manually. It has been written to  ' + certFilePath));
          }
          break;
        }
      case 'windows':
        {
          const certFilePath = await writeCertNamed('optic.local.crt');
          console.log(`Certificate written to ${certFilePath}. Right-click and choose "Install" 
             Trust it: https://techcommunity.microsoft.com/t5/windows-server-essentials-and/installing-a-self-signed-certificate-as-a-trusted-root-ca-in/ba-p/396105

Once added, you can run 'capture' with TLS targets ie https://api.github.com`);
          break;
        }
      case 'linux':
        {
          const certFilePath = await writeCertNamed('optic.local.cert');
          console.log(`Certificate written to ${certFilePath}. Depending on your distro, the commands to trust the certificate are different.

Once added, you can run 'capture' with TLS targets ie https://api.github.com`);
          break;
        }
    }
    process.exit(0);
  });
  return command;
}
async function writeCert(ca, destination) {
  let cert = _proxy.ProxyCertAuthority.readableCert(ca);
  await (0, _promises.finished)(cert.pipe(destination));
}
function getCertStore() {
  let configStore = new _conf.default({
    projectName: '@useoptic/openapi-cli',
    schema: {
      'capture-proxy-ca': {
        type: 'object',
        properties: {
          cert: {
            type: 'string'
          },
          key: {
            type: 'string'
          }
        }
      }
    }
  });
  return {
    get: () => {
      const maybeCa = configStore.get('capture-proxy-ca');
      if (maybeCa) {
        return (0, _tsResults.Some)(maybeCa);
      } else {
        return _tsResults.None;
      }
    },
    set: ca => {
      configStore.set('capture-proxy-ca', ca);
    },
    delete() {
      return configStore.delete('capture-proxy-ca');
    }
  };
}