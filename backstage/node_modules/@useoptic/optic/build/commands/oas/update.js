"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateCommand = updateCommand;
var _commander = require("commander");
var _feedback = require("./reporters/feedback");
var _chalk = _interopRequireDefault(require("chalk"));
var _specs = require("./specs");
var _document = require("./diffing/document");
var _path = _interopRequireDefault(require("path"));
var fs = _interopRequireWildcard(require("fs-extra"));
var _captures = require("./captures");
var _cloudUrls = require("../../utils/cloud-urls");
var _constants = require("../../constants");
var _patch = require("./diffing/patch");
var _logger = require("../../logger");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function updateCommand() {
  const command = new _commander.Command('update');
  const feedback = (0, _feedback.createCommandFeedback)(command);
  command.description('patch OpenAPI spec to match captured traffic').argument('<openapi-file>', 'an OpenAPI spec').option('--har <har-file>', 'path to HttpArchive file (v1.2, v1.3)').option('--postman <postman-collection-file>', 'path to postman collection').option('--all', 'update all operations').argument('[operations...]', 'update specific operations in format "get /path/{id}"', []).action(async (specPath, operations) => {
    _logger.logger.warn(_chalk.default.yellow.bold(`optic update is deprecated. Start using the new capture flow by running optic capture ${specPath} --update (get started by running optic capture init ${specPath})`));
    const analytics = [];
    const options = command.opts();
    const operationsToAdd = (0, _document.parseAddOperations)(operations);
    if (operationsToAdd.err) {
      return feedback.inputError('use the format "get /path/{id}"... to specify which operations should be added/updated', _feedback.InputErrors.DOCUMENT_OPERATION_FORMAT);
    }
    const isAddAll = Boolean(options.all);
    if (!isAddAll && operationsToAdd.val && operationsToAdd.val.length === 0) {
      return feedback.inputError(`Please pass in operations to document.\nDocument all paths using the "--all" flag\nDocument individual paths by passing them as arguments i.e "get /users/{userId}"`, _feedback.InputErrors.DOCUMENT_OPERATION_FORMAT);
    }
    const absoluteSpecPath = _path.default.resolve(specPath);
    if (!(await fs.pathExists(absoluteSpecPath))) {
      return await feedback.inputError('OpenAPI specification file could not be found', _feedback.InputErrors.SPEC_FILE_NOT_FOUND);
    }
    const specReadResult = await (0, _specs.readDeferencedSpec)(absoluteSpecPath);
    if (specReadResult.err) {
      return await feedback.inputError(`OpenAPI specification could not be fully resolved: ${specReadResult.val.message}`, _feedback.InputErrors.SPEC_FILE_NOT_READABLE);
    }
    const opticUrlDetails = (0, _cloudUrls.getApiFromOpticUrl)(specReadResult.val.jsonLike[_constants.OPTIC_URL_KEY]);
    const {
      jsonLike: spec,
      sourcemap
    } = specReadResult.unwrap();
    feedback.notable('Documenting new operations...');
    let {
      observations
    } = (0, _document.matchInteractions)(spec, await (0, _captures.getInteractions)(options, spec, specPath, feedback));
    const documentResult = await (0, _document.addIfUndocumented)(operationsToAdd.val, isAddAll, observations, await (0, _captures.getInteractions)(options, spec, specPath, feedback), spec, sourcemap);
    if (documentResult.ok) {
      analytics.push({
        event: 'openapi.verify.document',
        properties: {
          allFlag: isAddAll,
          numberDocumented: documentResult.val.length
        }
      });
      documentResult.val.map(operation => {
        console.log(`  ${_chalk.default.green('added')}  ${operation.method} ${operation.pathPattern}`);
      });
    }
    const {
      jsonLike: specAfterAdditions,
      sourcemap: sourcemapAfterAdditions
    } = specReadResult.unwrap();
    const patchInteractions = await (0, _captures.getInteractions)(options, spec, specPath, feedback);
    const patchStats = await (0, _patch.patchOperationsAsNeeded)(patchInteractions, specAfterAdditions, sourcemapAfterAdditions, isAddAll, operationsToAdd.ok ? operationsToAdd.val : []);
    if (!opticUrlDetails) {
      console.log('');
      console.log(`Share a link to documentation with your team (${_chalk.default.bold(`optic api add ${specPath})`)}`);
    }
  });
  return command;
}