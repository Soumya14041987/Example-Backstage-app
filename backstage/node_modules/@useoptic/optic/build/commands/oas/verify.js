"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runVerify = runVerify;
exports.verifyCommand = verifyCommand;
var _commander = require("commander");
var _path = _interopRequireDefault(require("path"));
var _feedback = require("./reporters/feedback");
var _segment = require("../../segment");
var _captureStorage = require("./captures/capture-storage");
var _chalk = _interopRequireDefault(require("chalk"));
var _document = require("./diffing/document");
var _patch = require("./diffing/patch");
var _queries = require("../capture/operations/queries");
var _config = require("../../config");
var _constants = require("../../constants");
var _cloudUrls = require("../../utils/cloud-urls");
var _specLoaders = require("../../utils/spec-loaders");
var _nextCommand = require("./reporters/next-command");
var _captures = require("./captures");
var _logger = require("../../logger");
function verifyCommand(config) {
  const command = new _commander.Command('verify');
  const feedback = (0, _feedback.createCommandFeedback)(command);
  command.description('match observed traffic up to an OpenAPI spec').argument('<openapi-file>', 'an OpenAPI spec to match up to observed traffic').option('--har <har-file>', 'path to HttpArchive file (v1.2, v1.3)').option('--postman <postman-collection-file>', 'path to postman collection').option('--exit0', 'always exit 0').option('--upload', 'Upload the verification data to optic cloud. Requires the spec to be in optic', false).option('--message', 'Used in conjunction with `--upload`, sets a message on an uploaded verification.').action(async specPath => {
    const options = command.opts();
    _logger.logger.warn(_chalk.default.yellow.bold(`optic update is deprecated. Start using the new capture flow by running optic capture ${specPath} (get started by running optic capture init ${specPath})`));
    return await runVerify(specPath, options, config, feedback);
  });
  return command;
}
async function runVerify(specPath, options, config, feedback, internalOptions = {
  printCoverage: true
}) {
  const analytics = [];
  console.log('');
  const {
    existingCaptures,
    openApiExists
  } = await (0, _captureStorage.captureStorage)(specPath);
  if (!openApiExists) {
    return await feedback.inputError('OpenAPI specification file could not be found', _feedback.InputErrors.SPEC_FILE_NOT_FOUND);
  }
  const absoluteSpecPath = _path.default.resolve(specPath);

  /// Run to verify with the latest specification
  const parseResult = await (0, _specLoaders.loadSpec)(absoluteSpecPath, config, {
    strict: false,
    denormalize: true
  });
  const {
    jsonLike: spec,
    sourcemap
  } = parseResult;
  const opticUrlDetails = (0, _cloudUrls.getApiFromOpticUrl)(spec[_constants.OPTIC_URL_KEY]);
  const interactions = await (0, _captures.getInteractions)(options, spec, specPath, feedback);
  feedback.notable(`Verifying API behavior with traffic ${options.har ? 'from har' : `from last ${_chalk.default.blue.underline(existingCaptures.toString())} capture${existingCaptures === 1 ? '' : 's'}. ${(0, _nextCommand.nextCommand)('Reset captures', `optic capture clear ${_path.default.relative(process.cwd(), specPath)}`)}\``} \n`);
  let {
    results: updatePatches
  } = (0, _patch.updateByInteractions)(spec, interactions);
  let {
    observations,
    coverage
  } = (0, _document.matchInteractions)(spec, await (0, _captures.getInteractions)(options, spec, specPath, feedback));
  const renderingStatus = await renderOperationStatus(observations, spec, specPath, feedback);
  const diffResults = await (0, _patch.renderDiffs)(specPath, sourcemap, spec, updatePatches, coverage);
  const coverageStats = coverage.calculateCoverage();
  if (internalOptions.printCoverage) {
    console.log('\n ' + _chalk.default.bold.underline(`API Behavior Report`));
    console.log(`
 Total Requests          : ${coverageStats.totalRequests}
 Diffs                   : ${diffResults.shapeDiff}
 Undocumented operations : ${renderingStatus.undocumentedPaths}
 Undocumented bodies     : ${diffResults.undocumentedBody}\n`);
    coverage.renderCoverage();
  }
  const hasDiff = diffResults.totalDiffCount + renderingStatus.undocumentedPaths > 0;
  analytics.push({
    event: 'openapi.verify',
    properties: {
      totalInteractions: coverageStats.totalRequests,
      coverage: coverageStats.percent,
      diffs: diffResults.totalDiffCount,
      shapeDiffs: diffResults.shapeDiff,
      undocumentedOperations: renderingStatus.undocumentedPaths,
      undocumentedBodies: renderingStatus.undocumentedPaths
    }
  });
  if (options.upload) {
    var _config$vcs;
    if (((_config$vcs = config.vcs) === null || _config$vcs === void 0 ? void 0 : _config$vcs.type) !== _config.VCS.Git) {
      console.error('optic verify --upload can only be run in a git repository.');
      process.exitCode = 1;
      return;
    }
    if (!opticUrlDetails) {
      console.error(`File ${specPath} does not have an optic url. Files must be added to Optic and have an x-optic-url key before verification data can be uploaded.`);
      console.error(`${_chalk.default.yellow('Hint: ')} Run optic api add ${specPath}`);
      process.exitCode = 1;
      return;
    }
    console.error('Coverage upload is not supported');
  }
  analytics.forEach(event => (0, _segment.trackEvent)(event.event, event.properties));
  await (0, _segment.flushEvents)();
  if (!options.exit0 && hasDiff) {
    console.log(_chalk.default.red('OpenAPI and implementation are out of sync. Exiting 1'));
    process.exit(1);
  }
  if (!hasDiff) {
    console.log(_chalk.default.green.bold('No diffs detected. OpenAPI and implementation appear to be in sync.'));
  }
}
async function renderOperationStatus(observations, spec, specPath, feedback) {
  const pathsToAdd = await (0, _document.observationToUndocumented)(observations, (0, _queries.specToPaths)(spec));
  let undocumentedPaths = 0;
  if (pathsToAdd.length) {
    for (let unmatchedPath of pathsToAdd) {
      undocumentedPaths++;
      unmatchedPath.methods.forEach(method => renderUndocumentedPath(method.toUpperCase(), unmatchedPath.pathPattern, unmatchedPath.examplePath));
    }
    console.log('');
    console.log((0, _nextCommand.nextCommand)('Document all new operations with', `optic update ${_path.default.relative(process.cwd(), specPath)} --all`));
    console.log((0, _nextCommand.nextCommand)('Document individual operations with', `optic update ${_path.default.relative(process.cwd(), specPath)} "[method] /[path]" ...`));
  }
  return {
    undocumentedPaths
  };
}
function renderUndocumentedPath(method, pathPattern, examplePath) {
  console.log(`${_chalk.default.bgYellow('  Undocumented  ')} ${method.toUpperCase().padStart(6, ' ')}   ${pathPattern}\n${''.padStart(26,
  // undocumented + method length
  ' ')}${_chalk.default.gray(examplePath)}`);
}