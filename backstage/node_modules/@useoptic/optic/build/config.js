"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ProjectYmlConfig = exports.OPTIC_YML_NAME = exports.OPTIC_DEV_YML_NAME = void 0;
exports.RenderTemplate = RenderTemplate;
exports.VCS = exports.USER_CONFIG_PATH = exports.USER_CONFIG_DIR = void 0;
exports.detectCliConfig = detectCliConfig;
exports.initializeConfig = initializeConfig;
exports.initializeRules = void 0;
exports.loadCliConfig = loadCliConfig;
exports.readUserConfig = readUserConfig;
exports.validateConfig = void 0;
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _jsYaml = _interopRequireDefault(require("js-yaml"));
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _ajv = _interopRequireDefault(require("ajv"));
var _os = _interopRequireDefault(require("os"));
var _nodePath = _interopRequireDefault(require("node:path"));
var _client = require("./client");
var Git = _interopRequireWildcard(require("./utils/git-utils"));
var _logger = require("./logger");
var _typebox = require("@sinclair/typebox");
var _handlebars = _interopRequireDefault(require("handlebars"));
var dotenv = _interopRequireWildcard(require("dotenv"));
var _opticBackend = require("./client/optic-backend");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
let VCS = exports.VCS = /*#__PURE__*/function (VCS) {
  VCS["Git"] = "git";
  VCS["Cloud"] = "cloud";
  return VCS;
}({}); // hosted in optic cloud
const OPTIC_YML_NAME = exports.OPTIC_YML_NAME = 'optic.yml';
const OPTIC_DEV_YML_NAME = exports.OPTIC_DEV_YML_NAME = 'optic.dev.yml';
const USER_CONFIG_DIR = exports.USER_CONFIG_DIR = _nodePath.default.join(_os.default.homedir(), '.config', 'optic');
const USER_CONFIG_PATH = exports.USER_CONFIG_PATH = process.env.OPTIC_ENV === 'staging' ? _nodePath.default.join(USER_CONFIG_DIR, 'config.staging.json') : process.env.OPTIC_ENV === 'local' ? _nodePath.default.join(USER_CONFIG_DIR, 'config.local.json') : _nodePath.default.join(USER_CONFIG_DIR, 'config.json');
const checkIsInCi = () => {
  return process.env.CI !== undefined && (0, _openapiUtilities.isTruthyStringValue)(process.env.CI);
};
const DefaultOpticCliConfig = {
  isDefaultConfig: true,
  root: process.cwd(),
  configPath: undefined,
  ruleset: undefined,
  isAuthenticated: false,
  client: (0, _client.createOpticClient)('no_token'),
  isInCi: checkIsInCi()
};
const RequestSend = _typebox.Type.Object({
  path: _typebox.Type.String(),
  method: _typebox.Type.Optional(_typebox.Type.String({
    enum: ['GET', 'POST', 'PATCH', 'DELETE']
  })),
  data: _typebox.Type.Optional(_typebox.Type.Object({})),
  headers: _typebox.Type.Optional(_typebox.Type.Record(_typebox.Type.String(), _typebox.Type.String()))
});
const RequestRun = _typebox.Type.Optional(_typebox.Type.Object({
  command: _typebox.Type.String(),
  proxy_variable: _typebox.Type.Optional(_typebox.Type.String())
}));
const CaptureConfigData = _typebox.Type.Object({
  config: _typebox.Type.Optional(_typebox.Type.Object({
    request_concurrency: _typebox.Type.Optional(_typebox.Type.Number())
  })),
  server: _typebox.Type.Object({
    dir: _typebox.Type.Optional(_typebox.Type.String()),
    command: _typebox.Type.Optional(_typebox.Type.String()),
    url: _typebox.Type.String(),
    ready_endpoint: _typebox.Type.Optional(_typebox.Type.String()),
    ready_interval: _typebox.Type.Optional(_typebox.Type.Number()),
    ready_timeout: _typebox.Type.Optional(_typebox.Type.Number())
  }),
  requests: _typebox.Type.Object({
    // one of these is technically required, but that's enforced at runtime
    run: _typebox.Type.Optional(RequestRun),
    send: _typebox.Type.Optional(_typebox.Type.Array(RequestSend))
  })
});
const ProjectYmlConfig = exports.ProjectYmlConfig = _typebox.Type.Object({
  extends: _typebox.Type.Optional(_typebox.Type.String()),
  ruleset: _typebox.Type.Optional(_typebox.Type.Array(_typebox.Type.Union([_typebox.Type.String(), _typebox.Type.Object({}, {
    minProperties: 1,
    maxProperties: 1
  })]))),
  capture: _typebox.Type.Optional(_typebox.Type.Record(_typebox.Type.String(), CaptureConfigData)),
  external_refs: _typebox.Type.Optional(_typebox.Type.Object({
    resolve_headers: _typebox.Type.Optional(_typebox.Type.Array(_typebox.Type.Object({
      headers: _typebox.Type.Record(_typebox.Type.String(), _typebox.Type.String()),
      url_prefix: _typebox.Type.Optional(_typebox.Type.String())
    })))
  }))
});
const ajv = new _ajv.default();
const validateConfigSchema = ajv.compile(ProjectYmlConfig);

// attempt to find an optic.yml file, or return undefined if none can be found
// Starts from cwd, and looks up until the top level dir (usually the git root or cwd)
async function detectCliConfig(topLevelDir) {
  let currentDir = process.cwd();
  // search up from pwd to specified dir
  while (topLevelDir.length <= currentDir.length) {
    const expectedDevYmlPath = _nodePath.default.join(currentDir, OPTIC_DEV_YML_NAME);
    const expectedYmlPath = _nodePath.default.join(currentDir, OPTIC_YML_NAME);
    try {
      await _promises.default.access(expectedYmlPath);
      return expectedYmlPath;
    } catch (e) {}
    try {
      await _promises.default.access(expectedDevYmlPath);
      return expectedDevYmlPath;
    } catch (e) {}
    const next = _nodePath.default.dirname(currentDir);
    if (currentDir === next) break;
    currentDir = next;
  }
  return undefined;
}
async function RenderTemplate(configPath) {
  const template = _handlebars.default.compile(await _promises.default.readFile(configPath, 'utf-8'));
  const result = template(process.env);
  return _jsYaml.default.load(result);
}
async function loadCliConfig(configPath, client) {
  const config = await RenderTemplate(configPath);
  validateConfig(config, configPath);
  await initializeRules(config, client);
  const cliConfig = config;
  cliConfig.root = _nodePath.default.dirname(configPath);
  cliConfig.configPath = configPath;
  return cliConfig;
}
const validateConfig = (config, path) => {
  const result = validateConfigSchema(config);
  if (!result) {
    throw new _openapiUtilities.UserError({
      message: `Configuration file \`${path}\` is invalid:\n${ajv.errorsText(validateConfigSchema.errors)}`
    });
  }
};
exports.validateConfig = validateConfig;
const initializeRules = async (config, client) => {
  let rulesetMap = new Map();
  let rawRulesets = config.ruleset ? config.ruleset : [];
  if (config.extends) {
    _logger.logger.debug(`Extending ruleset from ${config.extends}`);
    try {
      if (config.extends.startsWith('@')) {
        _logger.logger.error('Cloud rulesets are not supported');
      } else {
        // Assumption is that we're fetching a yaml file
        const response = await (0, _nodeFetch.default)(config.extends).then(response => {
          if (response.status !== 200) {
            throw new Error(`received status code ${response.status}`);
          } else {
            return response.text();
          }
        });
        const parsed = _jsYaml.default.load(response);
        rawRulesets.push(...parsed.ruleset);
      }
    } catch (e) {
      console.error(e);
      console.log(`Failed to download the ruleset from ${config.extends}. Not using extended ruleset`);
    }
  }
  if (rawRulesets.length) {
    for (const ruleset of rawRulesets) {
      if (typeof ruleset === 'string') {
        rulesetMap.set(ruleset, {
          name: ruleset,
          config: {}
        });
      } else if (typeof ruleset === 'object' && ruleset !== null) {
        const keys = Object.keys(ruleset);
        if (keys.length !== 1) {
          throw new _openapiUtilities.UserError({
            message: `Configuration error: empty ruleset configuration`
          });
        } else {
          const name = keys[0];
          const config = ruleset[name] || {};
          rulesetMap.set(name, {
            name,
            config
          });
        }
      } else {
        throw new _openapiUtilities.UserError({
          message: 'Configuration error: unexpected ruleset format'
        });
      }
    }
    config.ruleset = [...rulesetMap.values()];
  }
};
exports.initializeRules = initializeRules;
async function readUserConfig() {
  try {
    const validator = ajv.compile({
      type: 'object',
      properties: {
        token: {
          type: 'string'
        }
      },
      required: ['token']
    });
    const unvalidatedConfig = JSON.parse(await _promises.default.readFile(USER_CONFIG_PATH, 'utf-8'));
    const result = validator(unvalidatedConfig);
    if (!result) {
      return null;
    }
    return unvalidatedConfig;
  } catch (e) {
    return null;
  }
}
async function getYmlOrJsonChanges(gitRoot) {
  const status = await Git.gitStatus();
  const ymlOrJsonWithChanges = status.split('\n').filter(line => /\.(json|ya?ml)$/i.test(line)).map(line => {
    const file = line.split(' ').slice(-1)[0].trim();
    return _nodePath.default.join(gitRoot, file);
  });
  return new Set(ymlOrJsonWithChanges);
}
async function initializeConfig() {
  let cliConfig = DefaultOpticCliConfig;
  const userConfig = await readUserConfig();
  const maybeEnvToken = process.env.OPTIC_TOKEN;
  const maybeUserToken = userConfig !== null && userConfig !== void 0 && userConfig.token ? Buffer.from(userConfig.token, 'base64').toString() : null;
  const token = maybeEnvToken || maybeUserToken;
  if (token) {
    cliConfig.authenticationType = maybeEnvToken ? 'env' : maybeUserToken ? 'user' : undefined;
    cliConfig.isAuthenticated = true;
    cliConfig.userId = token.startsWith('opat') ? (0, _opticBackend.anonymizeUserToken)(token) : (0, _opticBackend.anonymizeOrgToken)(token);
    cliConfig.client = (0, _client.createOpticClient)(token);
  }
  if ((await Git.hasGit()) && (await Git.isInGitRepo())) {
    const gitRoot = await Git.getRootPath();
    const opticYmlPath = await detectCliConfig(gitRoot);
    if (opticYmlPath) {
      _logger.logger.debug(`Using config found at ${opticYmlPath}`);
      // if present, expect the .optic.env is in the same dir as the config file
      dotenv.config({
        path: _nodePath.default.join(_nodePath.default.dirname(opticYmlPath), '.optic.env')
      });
      cliConfig = {
        ...cliConfig,
        ...(await loadCliConfig(opticYmlPath, cliConfig.client)),
        isDefaultConfig: false
      };
    } else {
      // if present, expect the .optic.env in the current working dir
      dotenv.config({
        path: _nodePath.default.join(process.cwd(), '.optic.env')
      });
      cliConfig.root = gitRoot;
    }
    try {
      cliConfig.vcs = {
        type: VCS.Git,
        sha: await Git.resolveGitRef('HEAD'),
        diffSet: await getYmlOrJsonChanges(gitRoot)
      };
    } catch (e) {
      // Git command can fail in a repo with no commits, we should treat this as having no commits
    }
  } else {
    // if present, expect the .optic.env in the current working dir
    const currentDir = process.cwd();
    dotenv.config({
      path: _nodePath.default.join(currentDir, '.optic.env')
    });
    const opticYmlPath = await detectCliConfig(currentDir);
    if (opticYmlPath) {
      _logger.logger.debug(`Using config found at ${opticYmlPath}`);
      cliConfig = {
        ...cliConfig,
        ...(await loadCliConfig(opticYmlPath, cliConfig.client)),
        isDefaultConfig: false
      };
    }
  }
  _logger.logger.debug(cliConfig);
  return cliConfig;
}