"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.errorHandler = void 0;
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _sentry = require("./sentry");
var _chalk = _interopRequireDefault(require("chalk"));
var _errors = require("./client/errors");
var _logger = require("./logger");
var _openapiIo = require("@useoptic/openapi-io");
var _segment = require("./segment");
const errorHandler = (fn, meta) => {
  return async (...args) => {
    try {
      return await fn(...args);
    } catch (e) {
      const maybeOriginalError = _openapiUtilities.UserError.isInstance(e) && e.initialError ? e.initialError : null;
      if (e instanceof _errors.BadRequestError && e.source === 'optic' && /Invalid token/i.test(e.message) || e instanceof _errors.ForbiddenError && e.source === 'optic') {
        _logger.logger.error('');
        _logger.logger.error(_chalk.default.red.bold('Error making request to Optic'));
        _logger.logger.error(_chalk.default.red('It looks like your token is invalid (this could mean your token has expired, or it has been revoked).'));
        _logger.logger.error('');
        _logger.logger.error(_chalk.default.green('Run optic login to generate a new token'));
      } else if (_openapiIo.OpenAPIVersionError.isInstance(e) || maybeOriginalError && _openapiIo.OpenAPIVersionError.isInstance(maybeOriginalError)) {
        const versionError = _openapiIo.OpenAPIVersionError.isInstance(e) ? e : maybeOriginalError;
        _logger.logger.error(_chalk.default.red(versionError.message));
        if (versionError.version) {
          (0, _segment.trackEvent)('optic.openapi.version_not_supported', {
            version: versionError.version,
            command: meta.command
          });
          await (0, _segment.flushEvents)();
        }
      } else if (_openapiIo.ValidationError.isInstance(e) || _openapiUtilities.UserError.isInstance(e) || e instanceof _openapiIo.ResolverError) {
        const message = _openapiUtilities.UserError.isInstance(e) && e.initialError instanceof Error ? e.initialError.message : e.message;
        _logger.logger.error(_chalk.default.red(message));
      } else {
        console.error(e);
        if (e instanceof Error) _logger.logger.error(_chalk.default.red(e.message));
        _sentry.SentryClient.captureException(e);
        await _sentry.SentryClient.flush();
      }
      process.exit(1);
    }
  };
};
exports.errorHandler = errorHandler;