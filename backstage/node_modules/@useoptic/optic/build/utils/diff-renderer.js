"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateComparisonLogsV2 = generateComparisonLogsV2;
var _openapiUtilities = require("@useoptic/openapi-utilities");
var _lodash = _interopRequireDefault(require("lodash.groupby"));
var _isUrl = _interopRequireDefault(require("is-url"));
var _chalk = require("chalk");
var _jsonPointerHelpers = require("@useoptic/json-pointer-helpers");
var _traverser = require("@useoptic/openapi-utilities/build/openapi3/traverser");
const SEPARATOR = `~_-_~`;
// raw string value
const formatRawValue = (value, indent) => {
  try {
    const parsedValue = JSON.parse(value);
    return indent + JSON.stringify(parsedValue, null, 2).replace(/\n/g, '\n' + indent);
  } catch (e) {
    return value;
  }
};
const md = {
  bold: s => `**${s}**`
};
function* generateComparisonLogsV2(groupedDiffs, sourcemap, comparison, options) {
  const operationsChangedLabel = (0, _openapiUtilities.getOperationsChangedLabel)(groupedDiffs);
  const {
    findFileAndLines: findFileAndLinesFromBefore
  } = (0, _openapiUtilities.sourcemapReader)(sourcemap.from);
  const {
    findFileAndLines: findFileAndLinesFromAfter
  } = (0, _openapiUtilities.sourcemapReader)(sourcemap.to);
  const mdOutput = options.output === 'md';
  const chalk = new _chalk.Instance({
    level: options.output === 'pretty' ? 1 : 0
  });
  const getIndent = depth => mdOutput ? '' : ' '.repeat(depth * 2);
  const getItem = () => mdOutput ? '- ' : '';
  const identity = s => s;
  const bold = mdOutput ? md.bold : chalk.bold;
  const green = mdOutput ? identity : chalk.green;
  const blue = mdOutput ? identity : chalk.blue;
  const yellow = mdOutput ? identity : chalk.yellow;
  const white = mdOutput ? identity : chalk.white;
  const red = mdOutput ? identity : chalk.red;
  const bgRed = mdOutput ? identity : chalk.bgRed;
  const bgGreen = mdOutput ? identity : chalk.bgGreen;
  const underline = mdOutput ? identity : chalk.underline;
  const totalNumberOfChecks = comparison.results.length;
  const failedChecks = comparison.results.filter(result => !result.passed && !result.exempted);
  const numberOfChecks = {
    info: failedChecks.filter(r => r.severity === _openapiUtilities.Severity.Info).length,
    warn: failedChecks.filter(r => r.severity === _openapiUtilities.Severity.Warn).length,
    error: failedChecks.filter(r => r.severity === _openapiUtilities.Severity.Error).length
  };
  const exemptedFailedNumberOfChecks = comparison.results.filter(result => !result.passed && result.exempted).length;
  const passedNumberOfChecks = totalNumberOfChecks - failedChecks.length;
  const groupedResults = (0, _lodash.default)(comparison.results, result => {
    // OpenAPIV3 assumption
    const parts = _jsonPointerHelpers.jsonPointerHelpers.decode(result.location.jsonPath);
    if (parts.length >= 3 && parts[0] === 'paths') {
      const location = (0, _traverser.getLocation)({
        location: {
          jsonPath: result.location.jsonPath
        },
        type: 'operation'
      });
      if (Object.values(_openapiUtilities.OpenAPIV3.HttpMethods).includes(location.method)) {
        return `${location.pathPattern}${SEPARATOR}${location.method}`;
      } else {
        return `${location.pathPattern}${SEPARATOR}`;
      }
    } else {
      return 'Specification';
    }
  });
  for (const [location, operationResults] of Object.entries(groupedResults)) {
    const allPassed = operationResults.every(result => result.passed || result.exempted || result.severity < options.severity);
    const renderedResults = operationResults.filter(result => options.verbose || !result.passed && !result.exempted);
    const resultNode = allPassed ? bold(bgGreen(white(mdOutput ? 'PASS' : ' PASS '))) : bold(bgRed(white(mdOutput ? 'FAIL' : ' FAIL ')));
    if (location === 'specification') {
      yield `${getIndent(1)}${resultNode} ${bold('Specification')}`;
    } else {
      const [path, method] = location.split(SEPARATOR);
      if (!method) {
        yield `${getIndent(1)}${resultNode} ${path}`;
      } else {
        yield `${getIndent(1)}${resultNode} ${bold(method.toUpperCase())} ${path}`;
      }
    }
    for (const result of renderedResults) {
      // depending on the severity, use different colors
      const failedAccent = result.severity === _openapiUtilities.Severity.Info ? blue : result.severity === _openapiUtilities.Severity.Warn ? yellow : red;
      const icon = result.passed ? mdOutput ? ':heavy_check_mark:' : green('✔') : result.exempted ? mdOutput ? ':heavy_minus_sign:' : white('✔') : result.severity === _openapiUtilities.Severity.Info ? mdOutput ? ':information_source:' : failedAccent('ⓘ') : result.severity === _openapiUtilities.Severity.Warn ? mdOutput ? ':warning:' : failedAccent('⚠') : mdOutput ? ':x:' : failedAccent('x');
      const severity = failedAccent(` [${(0, _openapiUtilities.sevToText)(result.severity)}]`);
      const rulePrefix = (result.type ? `${result.type} rule` : 'rule') + severity;
      yield `${getItem()}${getIndent(2)}${rulePrefix}: ${result.name ?? ''}${result.exempted ? ' (exempted)' : ''}`;
      if (!result.passed && !result.exempted) {
        yield getIndent(3) + failedAccent(`${icon} ${result.error}`);
        if (result.expected && result.received) {
          yield getIndent(3) + failedAccent('Expected Value:');
          yield formatRawValue(result.expected, getIndent(3));
          yield getIndent(3) + failedAccent('Received Value:');
          yield formatRawValue(result.received, getIndent(3));
        }
      }
      if (!result.passed && result.exempted) {
        yield getIndent(3) + `${icon} ${result.error}`;
        if (result.expected && result.received) {
          yield getIndent(3) + 'Expected Value:';
          yield formatRawValue(result.expected, getIndent(3));
          yield getIndent(3) + 'Received Value:';
          yield formatRawValue(result.received, getIndent(3));
        }
      }
      if (result.docsLink) {
        yield `${getIndent(3)}Read more in our API Guide (${result.docsLink})`;
      }
      const sourcemap = result.location.spec === 'before' ? findFileAndLinesFromBefore(result.location.jsonPath) : findFileAndLinesFromAfter(result.location.jsonPath);
      const sourcemapText = sourcemap ? (0, _isUrl.default)(sourcemap.filePath) ? ` (${underline(sourcemap.filePath)} line ${sourcemap.startLine})` : ' ' + underline(`(${sourcemap.filePath}:${sourcemap.startLine}:${sourcemap.startPosition})`) : '';
      const jsonPath = _jsonPointerHelpers.jsonPointerHelpers.decode(result.location.jsonPath).join(' > ');
      yield `${getIndent(3)}at ${jsonPath}${sourcemapText}`;
      yield '';
    }
    yield '\n';
  }
  yield operationsChangedLabel;
  yield green(bold(`${passedNumberOfChecks} passed`));
  if (numberOfChecks.info > 0) yield blue(bold(`${numberOfChecks.info} info`));
  if (numberOfChecks.warn > 0) yield blue(bold(`${numberOfChecks.warn} warnings`));
  yield red(bold(`${numberOfChecks.error} errors`));
  if (exemptedFailedNumberOfChecks > 0) {
    yield bold(`${exemptedFailedNumberOfChecks} checks exempted`);
  }
}