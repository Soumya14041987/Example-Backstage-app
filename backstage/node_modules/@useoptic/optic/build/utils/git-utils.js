"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveGitRef = exports.remotes = exports.isTracked = exports.isInGitRepo = exports.hasGit = exports.guessRemoteOrigin = exports.gitStatus = exports.gitShow = exports.getRootPath = exports.getRemoteUrl = exports.getMergeBase = exports.getDefaultBranchName = exports.getCurrentBranchName = exports.findOpenApiSpecsCandidates = exports.commitMeta = exports.checkIgnore = exports.assertRefExists = void 0;
var _child_process = require("child_process");
var _gitUrlParse = _interopRequireDefault(require("git-url-parse"));
var _urlJoin = _interopRequireDefault(require("url-join"));
const hasGit = async () => new Promise(resolve => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr || !stdout) resolve(false);
    resolve(true);
  };
  const command = `git --version`;
  (0, _child_process.exec)(command, cb);
});
exports.hasGit = hasGit;
const isInGitRepo = async () => new Promise(resolve => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr || !stdout) resolve(false);
    resolve(true);
  };
  const command = `git rev-parse --is-inside-work-tree`;
  (0, _child_process.exec)(command, cb);
});
exports.isInGitRepo = isInGitRepo;
const getDefaultBranchName = async () => {
  let remote;
  try {
    const gitRemotes = await remotes();
    if (gitRemotes.length === 0) {
      return null;
    }
    remote = gitRemotes[0];
  } catch (e) {
    return null;
  }
  return new Promise((resolve, reject) => {
    const cb = (err, stdout, stderr) => {
      if (err || stderr || !stdout) resolve(null);
      const match = stdout.match(/HEAD branch\: (.*)\n/);
      const defaultBranch = (match === null || match === void 0 ? void 0 : match[1]) ?? null;
      resolve(defaultBranch);
    };
    const command = `git remote show ${remote}`;
    (0, _child_process.exec)(command, cb);
  });
};
exports.getDefaultBranchName = getDefaultBranchName;
const gitShow = async (ref, path) => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr || !stdout) reject(err || new Error(stderr));
    resolve(stdout.trim());
  };
  const command = `git show ${ref}:${path}`;
  (0, _child_process.exec)(command, cb);
});
exports.gitShow = gitShow;
const getCurrentBranchName = async () => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr || !stdout) reject(err || new Error(stderr));
    resolve(stdout.trim());
  };
  const command = 'git rev-parse --abbrev-ref HEAD';
  (0, _child_process.exec)(command, cb);
});
exports.getCurrentBranchName = getCurrentBranchName;
const getMergeBase = async (branch1, branch2) => {
  return new Promise((resolve, reject) => {
    const cb = (err, stdout, stderr) => {
      if (err || stderr || !stdout) reject(err || new Error(stderr));
      resolve(stdout.trim());
    };
    const command = `git merge-base ${branch1} ${branch2}`;
    (0, _child_process.exec)(command, cb);
  });
};
exports.getMergeBase = getMergeBase;
const getRootPath = async () => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr || !stdout) reject(err || new Error(stderr));
    resolve(stdout.trim());
  };
  const command = `git rev-parse --show-toplevel`;
  (0, _child_process.exec)(command, cb);
});
exports.getRootPath = getRootPath;
const assertRefExists = async ref => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr) reject(new Error(`ref ${ref} does not exist in current git repository`));
    resolve();
  };
  const command = `git cat-file -t ${ref}`;
  (0, _child_process.exec)(command, cb);
});
exports.assertRefExists = assertRefExists;
const gitStatus = async () => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr) reject(err || new Error(stderr));
    resolve(stdout.trim());
  };
  const command = `git status --porcelain`;
  (0, _child_process.exec)(command, cb);
});
exports.gitStatus = gitStatus;
const resolveGitRef = async ref => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr || !stdout) reject(err || new Error(stderr));
    resolve(stdout.trim());
  };
  const command = `git rev-parse ${ref}`;
  (0, _child_process.exec)(command, cb);
});
exports.resolveGitRef = resolveGitRef;
const checkIgnore = async pathnames => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err && err.code === 1) return resolve([]); // check-ignore exits 1 when no file is ignored
    if (err || stderr || !stdout) reject(err || new Error(stderr));
    resolve(stdout.trim().split('\n'));
  };
  const command = `git check-ignore ${pathnames.join(' ')}`;
  (0, _child_process.exec)(command, cb);
});
exports.checkIgnore = checkIgnore;
const commitMeta = async ref => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr || !stdout) {
      reject(err || new Error(stderr));
    }
    stdout = stdout.trim();
    const lines = stdout.split('\n', 2);
    const [name, email, date] = lines[0] ? lines[0].split('\t') : ['', '', '0'];
    resolve({
      name,
      email,
      date: new Date(parseInt(date) * 1000),
      message: lines[1] ? lines[1] : ''
    });
  };
  const command = `git show -s --date=iso-strict --format="%an\t%ae\t%at\n%s" ${ref}`;
  (0, _child_process.exec)(command, cb);
});
exports.commitMeta = commitMeta;
const findOpenApiSpecsCandidates = async ref => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr) reject(err || new Error(stderr));
    resolve(stdout.trim().split('\n').filter(path => !!path));
  };
  const args = ref ? `--name-only -E 'openapi' ${ref}` : `--untracked --name-only -E 'openapi'`;
  const command = `toplevel=$(git rev-parse --show-toplevel) && \
    git grep ${args} -- \
    $toplevel/'*.yml' \
    $toplevel/'*.yaml' \
    $toplevel/'*.json' \
    || true`;
  (0, _child_process.exec)(command, cb);
});
exports.findOpenApiSpecsCandidates = findOpenApiSpecsCandidates;
const remotes = async () => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr || !stdout) reject(err || new Error(stderr));
    resolve(stdout.trim().split('\n').filter(remote => remote.trim()));
  };
  const command = `git remote`;
  (0, _child_process.exec)(command, cb);
});
exports.remotes = remotes;
const getRemoteUrl = async remote => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr || !stdout) reject(err || new Error(stderr));
    resolve(stdout.trim());
  };
  const command = `git remote get-url ${remote}`;
  (0, _child_process.exec)(command, cb);
});
exports.getRemoteUrl = getRemoteUrl;
const guessRemoteOrigin = async () => {
  let remoteUrl;
  try {
    const gitRemotes = await remotes();
    if (gitRemotes.length === 0) {
      return null;
    }
    remoteUrl = await getRemoteUrl(gitRemotes[0]);
  } catch (e) {
    return null;
  }
  try {
    const parsed = (0, _gitUrlParse.default)(remoteUrl);
    if (/github/i.test(parsed.resource)) {
      return {
        provider: 'github',
        web_url: `https://${(0, _urlJoin.default)(parsed.resource, parsed.full_name)}`
      };
    } else if (/gitlab/i.test(parsed.resource)) {
      return {
        provider: 'gitlab',
        web_url: `https://${(0, _urlJoin.default)(parsed.resource, parsed.full_name)}`
      };
    }
  } catch (e) {
    return null;
  }
  return null;
};
exports.guessRemoteOrigin = guessRemoteOrigin;
const isTracked = async filePath => new Promise((resolve, reject) => {
  const cb = (err, stdout, stderr) => {
    if (err || stderr) reject(err || new Error(stderr));
    resolve(!!stdout);
  };
  const command = `git ls-files ${filePath}`;
  (0, _child_process.exec)(command, cb);
});
exports.isTracked = isTracked;