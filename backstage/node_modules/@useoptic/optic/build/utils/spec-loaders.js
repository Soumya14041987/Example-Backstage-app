"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadRaw = loadRaw;
exports.parseFilesFromRef = exports.loadSpec = void 0;
exports.parseOpticRef = parseOpticRef;
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _path = _interopRequireDefault(require("path"));
var _util = require("util");
var _child_process = require("child_process");
var _openapiIo = require("@useoptic/openapi-io");
var _config = require("../config");
var Git = _interopRequireWildcard(require("./git-utils"));
var _specs = require("./specs");
var _logger = require("../logger");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const exec = (0, _util.promisify)(_child_process.exec);
function isWindowsDrivePath(raw) {
  // matches windows drive paths (C:\... or d:\...)
  return /^[a-zA-Z]:\\/.test(raw);
}
function parseOpticRef(raw) {
  var _maybeCloudMatch$grou, _maybeCloudMatch$grou2;
  raw = raw ?? 'null:';
  let isUrl = false;
  const maybeCloudMatch = raw.match(/^cloud:(?<apiId>.+)@(?<tag>.+)$/);
  try {
    const url = new URL(raw);
    // should also check that the protocol is http or https, we won't support anything else
    isUrl = url.protocol === 'http:' || url.protocol === 'https:';
  } catch (e) {}
  if (raw === 'null:') {
    return {
      from: 'empty'
    };
  } else if (isUrl) {
    return {
      from: 'url',
      url: raw
    };
  } else if (maybeCloudMatch !== null && maybeCloudMatch !== void 0 && (_maybeCloudMatch$grou = maybeCloudMatch.groups) !== null && _maybeCloudMatch$grou !== void 0 && _maybeCloudMatch$grou.apiId && maybeCloudMatch !== null && maybeCloudMatch !== void 0 && (_maybeCloudMatch$grou2 = maybeCloudMatch.groups) !== null && _maybeCloudMatch$grou2 !== void 0 && _maybeCloudMatch$grou2.tag) {
    return {
      from: 'cloud',
      apiId: maybeCloudMatch.groups.apiId,
      tag: maybeCloudMatch.groups.tag
    };
  } else if (raw.includes(':') && !isWindowsDrivePath(raw)) {
    const index = raw.indexOf(':');
    const rev = raw.substring(0, index);
    const name = raw.substring(index + 1);
    return {
      from: 'git',
      name: name.startsWith('/') ? name.substring(1) : name,
      branch: rev
    };
  } else {
    return {
      from: 'file',
      filePath: raw
    };
  }
}

// Loads spec without dereferencing
async function loadRaw(opticRef, config) {
  const input = parseOpticRef(opticRef);
  let format;
  let rawString;
  if (input.from === 'file') {
    rawString = await _promises.default.readFile(opticRef, 'utf-8');
    format = /\.json$/i.test(opticRef) ? 'json' : 'yml';
  } else if (input.from === 'git') {
    rawString = await Git.gitShow(input.branch, input.name);
    format = /\.json$/i.test(opticRef) ? 'json' : 'yml';
  } else if (input.from === 'url') {
    rawString = await (0, _nodeFetch.default)(input.url).then(res => res.text());
    format = 'unknown';
  } else if (input.from === 'cloud') {
    throw new Error('cloud refs are not supported');
  } else {
    return (0, _specs.createNullSpec)();
  }
  if (rawString === '') {
    throw new Error('file is empty');
  }
  if (format === 'unknown') {
    // try json, then yml
    try {
      return JSON.parse(rawString);
    } catch (e) {
      return (0, _openapiIo.loadYaml)(rawString);
    }
  } else {
    try {
      return /\.json$/i.test(opticRef) ? JSON.parse(rawString) : (0, _openapiIo.loadYaml)(rawString);
    } catch (e) {
      if (e instanceof Error) {
        if (rawString.match(/x-optic-url/)) {
          e['probablySpec'] = true;
        }
      }
      throw e;
    }
  }
}
async function parseSpecAndDereference(filePathOrRef, config) {
  var _config$external_refs3, _config$vcs2;
  const workingDir = process.cwd();
  const input = parseOpticRef(filePathOrRef);
  switch (input.from) {
    case 'empty':
      {
        const spec = (0, _specs.createNullSpec)();
        const sourcemap = (0, _specs.createNullSpecSourcemap)(spec);
        return {
          jsonLike: spec,
          fileContext: input,
          sourcemap,
          from: 'empty',
          version: '3.0.x',
          isEmptySpec: true,
          context: null
        };
      }
    case 'cloud':
      {
        throw new Error('cloud refs are not supported');
      }
    case 'git':
      {
        var _config$vcs, _config$external_refs;
        if (((_config$vcs = config.vcs) === null || _config$vcs === void 0 ? void 0 : _config$vcs.type) !== _config.VCS.Git) {
          throw new Error(`${workingDir} is not a git repo`);
        }
        const sha = await Git.resolveGitRef(input.branch);
        const commitMeta = await Git.commitMeta(sha);
        const parseResult = await (0, _openapiIo.parseOpenAPIFromRepoWithSourcemap)(input.name, config.root, input.branch, {
          externalRefHeaders: ((_config$external_refs = config.external_refs) === null || _config$external_refs === void 0 ? void 0 : _config$external_refs.resolve_headers) ?? []
        });
        return {
          ...parseResult,
          version: (0, _openapiIo.checkOpenAPIVersion)(parseResult.jsonLike),
          from: 'git',
          fileContext: input,
          isEmptySpec: false,
          context: {
            vcs: 'git',
            sha,
            effective_at: commitMeta.date,
            name: commitMeta.name,
            email: commitMeta.email,
            message: commitMeta.message
          }
        };
      }
    case 'url':
      {
        var _config$external_refs2;
        const parseResult = await (0, _openapiIo.parseOpenAPIWithSourcemap)(input.url, {
          externalRefHeaders: ((_config$external_refs2 = config.external_refs) === null || _config$external_refs2 === void 0 ? void 0 : _config$external_refs2.resolve_headers) ?? []
        });
        return {
          ...parseResult,
          version: (0, _openapiIo.checkOpenAPIVersion)(parseResult.jsonLike),
          fileContext: input,
          from: 'url',
          isEmptySpec: false,
          context: null
        };
      }
    case 'file':
      let context = null;
      const parseResult = await (0, _openapiIo.parseOpenAPIWithSourcemap)(_path.default.resolve(workingDir, input.filePath), {
        externalRefHeaders: ((_config$external_refs3 = config.external_refs) === null || _config$external_refs3 === void 0 ? void 0 : _config$external_refs3.resolve_headers) ?? []
      });
      if (((_config$vcs2 = config.vcs) === null || _config$vcs2 === void 0 ? void 0 : _config$vcs2.type) === _config.VCS.Git) {
        const commitMeta = await Git.commitMeta(config.vcs.sha);
        context = {
          vcs: 'git',
          sha: config.vcs.sha,
          effective_at: commitMeta.date,
          name: commitMeta.name,
          email: commitMeta.email,
          message: commitMeta.message
        };
      }
      return {
        ...parseResult,
        fileContext: input,
        version: (0, _openapiIo.checkOpenAPIVersion)(parseResult.jsonLike),
        from: 'file',
        isEmptySpec: false,
        context
      };
  }
}
function validateAndDenormalize(parseResult, options) {
  if (parseResult.version === '2.x.x') {
    (0, _openapiIo.validateSwaggerV2Document)(parseResult.jsonLike, parseResult.sourcemap, {
      strictOpenAPI: options.strict
    });
  } else if (parseResult.version === '3.0.x' || parseResult.version === '3.1.x') {
    (0, _openapiIo.validateOpenApiV3Document)(parseResult.jsonLike, parseResult.sourcemap, {
      strictOpenAPI: options.strict
    });
  } else {
    throw new Error('unrecognized version');
  }
  const warnings = [];
  const result = options.denormalize ? (0, _openapiIo.denormalize)(parseResult, parseResult.version, warnings) : parseResult;
  if (warnings.length !== 0) _logger.logger.warn(...warnings);
  return result;
}

// Optic ref supports
// - file paths (`./specs/openapi.yml`)
// - git paths (`git:main`)
// - public urls (`https://example.com/my-openapi-spec.yml`)
// - empty files (`null:`)
// - cloud tags (`cloud:apiId@tag`)
const loadSpec = async (opticRef, config, options) => {
  const file = await parseSpecAndDereference(opticRef, config);
  return validateAndDenormalize(file, options);
};
exports.loadSpec = loadSpec;
const parseFilesFromRef = async (filePath, base, rootGitPath, config, options) => {
  await Git.assertRefExists(base);
  const gitFileName = (0, _openapiIo.filePathToGitPath)(rootGitPath, filePath);
  const existsOnBase = await exec(`git show ${base}:${gitFileName}`).then(() => true).catch(() => false);
  return {
    baseFile: await parseSpecAndDereference(existsOnBase ? `${base}:${gitFileName}` : undefined, config).then(file => {
      return validateAndDenormalize(file, {
        denormalize: options.denormalize,
        strict: false
      });
    }),
    headFile: await parseSpecAndDereference(filePath, config).then(file => {
      return validateAndDenormalize(file, {
        denormalize: options.denormalize,
        strict: options.headStrict
      });
    }),
    pathFromGitRoot: gitFileName
  };
};
exports.parseFilesFromRef = parseFilesFromRef;