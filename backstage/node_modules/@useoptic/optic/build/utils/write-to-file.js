"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addExtensionsToYaml = addExtensionsToYaml;
exports.writeJson = writeJson;
exports.writeYml = writeYml;
var _promises = _interopRequireDefault(require("node:fs/promises"));
var _openapiIo = require("@useoptic/openapi-io");
var _constants = require("../constants");
async function writeJson(path, data) {
  await _promises.default.readFile(path, 'utf-8').then(file => {
    const {
      openapi,
      ...other
    } = JSON.parse(file);

    // clear
    delete other[_constants.OPTIC_STANDARD_KEY];
    delete other[_constants.OPTIC_URL_KEY];
    const updated = {};
    updated[_constants.OPTIC_URL_KEY] = data[_constants.OPTIC_URL_KEY];
    if (data[_constants.OPTIC_STANDARD_KEY]) {
      updated[_constants.OPTIC_STANDARD_KEY] = data[_constants.OPTIC_STANDARD_KEY];
    }
    return JSON.stringify({
      openapi: openapi,
      ...updated,
      ...other
    }, null, 2);
  }).then(file => _promises.default.writeFile(path, file));
}
async function writeYml(path, data) {
  await _promises.default.readFile(path, 'utf-8').then(file => {
    return addExtensionsToYaml(file, data['OPTIC_STANDARD_KEY'] ? {
      [_constants.OPTIC_URL_KEY]: data[_constants.OPTIC_URL_KEY],
      [_constants.OPTIC_STANDARD_KEY]: data[_constants.OPTIC_STANDARD_KEY]
    } : {
      [_constants.OPTIC_URL_KEY]: data[_constants.OPTIC_URL_KEY]
    });
  }).then(file => _promises.default.writeFile(path, file));
}
function addExtensionsToYaml(yamlContents, extensions) {
  const parsed = (0, _openapiIo.loadYaml)(yamlContents);
  try {
    // delete anything already in spec with a different value
    const toDelete = Object.keys(extensions).filter(extension => parsed[extension] && parsed[extension] !== extensions[extension]);
    let cleanedYaml = yamlContents;
    if (toDelete.length) {
      const lines = cleanedYaml.split('\n');
      const linesToDelete = toDelete.map(i => {
        const lineToDelete = matchExtensionLine(i, lines);
        return lineToDelete;
      }).sort().reverse();
      linesToDelete.forEach(deleteIndex => lines.splice(deleteIndex, 1));
      cleanedYaml = lines.join('\n');
    }
    const matches = /["']{0,1}openapi["']{0,1}.*$/gm.exec(cleanedYaml);
    if (matches) {
      const indexOfOpenApiLineNewLine = cleanedYaml.indexOf('\n', matches.index);
      const extensionLines = Object.entries(extensions).map(extension => {
        return `${extension[0]}: "${extension[1]}"`;
      });
      return cleanedYaml.substring(0, indexOfOpenApiLineNewLine) + (extensionLines.length ? '\n' + extensionLines.join(`\n`) : '') + cleanedYaml.substring(indexOfOpenApiLineNewLine);
    } else {
      throw new Error('openapi: 3.x.x line not found');
    }
  } catch (e) {
    const {
      openapi,
      ...other
    } = parsed;
    const updated = {};
    Object.entries(extensions).forEach(([key, value]) => updated[key] = value);

    // will respect ordering
    return (0, _openapiIo.writeYaml)({
      openapi,
      ...updated,
      ...other
    });
  }
}
function matchExtensionLine(extension, lines) {
  const regex = new RegExp(`^["']{0,1}${extension}["']{0,1}:.*$`);
  return lines.findIndex(line => regex.test(line));
}