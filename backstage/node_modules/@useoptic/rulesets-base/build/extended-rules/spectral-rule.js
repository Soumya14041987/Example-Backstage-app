"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpectralRule = void 0;
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
const openapi_utilities_1 = require("@useoptic/openapi-utilities");
const external_rule_base_1 = require("../rules/external-rule-base");
const utils_1 = require("../rule-runner/utils");
const child_process_1 = require("child_process");
const node_path_1 = __importDefault(require("node:path"));
const node_os_1 = __importDefault(require("node:os"));
const promises_1 = __importDefault(require("node:fs/promises"));
const data_constructors_1 = require("../rule-runner/data-constructors");
const group_facts_1 = require("../rule-runner/group-facts");
// Definition from spectral internals
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    DiagnosticSeverity[DiagnosticSeverity["Error"] = 0] = "Error";
    DiagnosticSeverity[DiagnosticSeverity["Warning"] = 1] = "Warning";
    DiagnosticSeverity[DiagnosticSeverity["Information"] = 2] = "Information";
    DiagnosticSeverity[DiagnosticSeverity["Hint"] = 3] = "Hint";
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
function toOpticResult(spectralResult, lifecycle, relevantChangeOrFact, opts) {
    return {
        condition: spectralResult.code.toString(),
        exempted: opts.exempted,
        docsLink: opts.docsLink,
        passed: false,
        error: spectralResult.message,
        isMust: true,
        isShould: false,
        where: `${lifecycle} `,
        change: relevantChangeOrFact,
    };
}
// This will treat info + hint as a info in Optic
function severityToOpticSeverity(spectralSev) {
    return spectralSev === DiagnosticSeverity.Error
        ? openapi_utilities_1.Severity.Error
        : spectralSev === DiagnosticSeverity.Warning
            ? openapi_utilities_1.Severity.Warn
            : openapi_utilities_1.Severity.Info;
}
function toOpticRuleResult(spectralResult, lifecycle, jsonPath, opts) {
    return {
        exempted: opts.exempted,
        severity: severityToOpticSeverity(spectralResult.severity),
        docsLink: opts.docsLink,
        passed: false,
        error: `Error code: ${spectralResult.code.toString()}: ${spectralResult.message}`,
        where: `${lifecycle} `,
        location: {
            jsonPath,
            spec: 'after',
        },
        name: `Spectral ${lifecycle} rule`,
        type: lifecycle === 'always' ? 'requirement' : lifecycle,
    };
}
function createSpecNode(spec) {
    const { paths, components, ...specificationFact } = spec;
    const fact = {
        location: {
            jsonPath: '',
            conceptualPath: [],
            conceptualLocation: {},
            kind: openapi_utilities_1.OpenApiKind.Specification,
        },
        value: specificationFact,
    };
    const node = {
        before: fact,
        after: fact,
        change: null,
    };
    return {
        before: (0, data_constructors_1.createSpecification)(node, 'before', spec),
        after: (0, data_constructors_1.createSpecification)(node, 'after', spec),
        node,
    };
}
function createOperationNode(facts, jsonPath, before, after) {
    const [, path, method] = json_pointer_helpers_1.jsonPointerHelpers.decode(jsonPath);
    const endpointNode = facts.endpoints.get((0, group_facts_1.getEndpointKey)({ path, method }));
    return {
        before: (0, data_constructors_1.createOperation)(endpointNode, 'before', before),
        after: (0, data_constructors_1.createOperation)(endpointNode, 'after', after),
        node: endpointNode,
    };
}
class SpectralRule extends external_rule_base_1.ExternalRuleBase {
    constructor(options) {
        super();
        this.name = options.name;
        this.flatSpecFile = options.flatSpecFile;
        this.rulesetPointer = options.rulesetPointer;
        this.lifecycle = options.applies ?? 'always';
        this.docsLink = options.docsLink;
        this.spectral = options.spectral;
        this.matches = options.matches;
    }
    async runRulesV2(inputs) {
        if (inputs.toSpec['x-optic-ci-empty-spec'] === true) {
            return [];
        }
        const traverser = new openapi_utilities_1.OpenApiV3Traverser();
        traverser.traverse(inputs.toSpec);
        const factTree = (0, openapi_utilities_1.constructFactTree)([...traverser.facts()]);
        const changesByJsonPath = inputs.diffs.reduce((acc, next) => {
            const location = next.after ?? next.before;
            acc[location] = next;
            return acc;
        }, {});
        let spectralResults;
        if (this.spectral) {
            try {
                spectralResults = await this.spectral.run(inputs.toSpec);
            }
            catch (e) {
                throw new openapi_utilities_1.UserError({ message: e.message ? e.message : e });
            }
        }
        else if (this.rulesetPointer && this.flatSpecFile) {
            try {
                const output = await runSpectral(this.rulesetPointer, this.flatSpecFile);
                // sometimes first line has a message
                const withoutLeading = output.substring(output.indexOf('[')).trim();
                spectralResults = JSON.parse(withoutLeading);
            }
            catch (e) {
                throw new openapi_utilities_1.UserError({ message: e.message ? e.message : e });
            }
        }
        else {
            throw new openapi_utilities_1.UserError({
                message: 'Invalid configuration for spectral rules - must provide rulesetPointer and flatSpecFile or a spectral instance',
            });
        }
        const results = [];
        for (const spectralResult of spectralResults) {
            const path = json_pointer_helpers_1.jsonPointerHelpers.compile(spectralResult.path.map((p) => String(p)));
            const fact = (0, openapi_utilities_1.getFactForJsonPath)(path, factTree);
            if (!fact) {
                continue;
            }
            if (this.matches) {
                const spec = {
                    before: (0, data_constructors_1.createSpecification)(inputs.groupedFacts.specification, 'before', inputs.fromSpec),
                    after: (0, data_constructors_1.createSpecification)(inputs.groupedFacts.specification, 'after', inputs.toSpec),
                    node: inputs.groupedFacts.specification,
                };
                const ruleContext = json_pointer_helpers_1.jsonPointerHelpers.startsWith(path, [
                    'paths',
                    '**',
                    '**',
                ])
                    ? (0, utils_1.createRuleContextWithOperation)(spec, createOperationNode(inputs.groupedFacts, path, inputs.fromSpec, inputs.toSpec), inputs.context)
                    : (0, utils_1.createRuleContextWithoutOperation)(spec, inputs.context);
                if (!this.matches(ruleContext)) {
                    continue;
                }
            }
            // This exemption is actually on the Fact level, rather than the spectral path
            // This is for consistency with our current rule engine. In the future we should attach exemptions on the nodes which trigger them, which would require us to rework the rules engine
            const rawForPath = json_pointer_helpers_1.jsonPointerHelpers.get(inputs.toSpec, fact.location.jsonPath);
            const exempted = (0, utils_1.isExempted)(rawForPath, this.name);
            // TODO in the future update to pass in the JSON path from spectral, rather than the fact json path
            if (this.lifecycle === 'always') {
                results.push(toOpticRuleResult(spectralResult, 'always', fact.location.jsonPath, {
                    exempted,
                    docsLink: this.docsLink,
                }));
            }
            else {
                // find if there is an appropriate change
                let maybeChange = changesByJsonPath[fact.location.jsonPath] ||
                    changesByJsonPath[json_pointer_helpers_1.jsonPointerHelpers.compile(spectralResult.path.map((i) => i.toString()))];
                if (!maybeChange &&
                    json_pointer_helpers_1.jsonPointerHelpers.matches(fact.location.jsonPath, [
                        'paths',
                        '**',
                        `{${Object.values(openapi_utilities_1.OpenAPIV3.HttpMethods).join(',')}}`,
                    ])) {
                    const pathPointer = json_pointer_helpers_1.jsonPointerHelpers.pop(fact.location.jsonPath);
                    maybeChange = changesByJsonPath[pathPointer];
                }
                if (maybeChange) {
                    const changeType = (0, openapi_utilities_1.typeofDiff)(maybeChange);
                    if (this.lifecycle === 'added' && changeType === 'added') {
                        results.push(toOpticRuleResult(spectralResult, 'added', fact.location.jsonPath, {
                            exempted,
                            docsLink: this.docsLink,
                        }));
                    }
                    else if (this.lifecycle === 'changed' && changeType === 'changed') {
                        results.push(toOpticRuleResult(spectralResult, 'changed', fact.location.jsonPath, {
                            exempted,
                            docsLink: this.docsLink,
                        }));
                    }
                    else if (this.lifecycle === 'addedOrChanged' &&
                        (changeType === 'added' || changeType === 'changed')) {
                        results.push(toOpticRuleResult(spectralResult, 'addedOrChanged', fact.location.jsonPath, {
                            exempted,
                            docsLink: this.docsLink,
                        }));
                    }
                }
            }
        }
        return results;
    }
    async runRules(inputs) {
        if (inputs.nextJsonLike['x-optic-ci-empty-spec'] === true) {
            return [];
        }
        const factTree = (0, openapi_utilities_1.constructFactTree)(inputs.nextFacts);
        const changesByJsonPath = inputs.changelog.reduce((acc, next) => {
            acc[next.location.jsonPath] = next;
            return acc;
        }, {});
        let spectralResults;
        if (this.spectral) {
            try {
                spectralResults = await this.spectral.run(inputs.nextJsonLike);
            }
            catch (e) {
                throw new openapi_utilities_1.UserError({ message: e.message ? e.message : e });
            }
        }
        else if (this.rulesetPointer && this.flatSpecFile) {
            try {
                const output = await runSpectral(this.rulesetPointer, this.flatSpecFile);
                // sometimes first line has a message
                const withoutLeading = output.substring(output.indexOf('[')).trim();
                spectralResults = JSON.parse(withoutLeading);
            }
            catch (e) {
                throw new openapi_utilities_1.UserError({ message: e.message ? e.message : e });
            }
        }
        else {
            throw new openapi_utilities_1.UserError({
                message: 'Invalid configuration for spectral rules - must provide rulesetPointer and flatSpecFile or a spectral instance',
            });
        }
        const results = [];
        for (const spectralResult of spectralResults) {
            const path = json_pointer_helpers_1.jsonPointerHelpers.compile(spectralResult.path.map((p) => String(p)));
            const fact = (0, openapi_utilities_1.getFactForJsonPath)(path, factTree);
            if (!fact) {
                continue;
            }
            if (this.matches) {
                const spec = createSpecNode(inputs.nextJsonLike);
                const ruleContext = json_pointer_helpers_1.jsonPointerHelpers.startsWith(path, [
                    'paths',
                    '**',
                    '**',
                ])
                    ? (0, utils_1.createRuleContextWithOperation)(spec, createOperationNode(inputs.groupedFacts, path, inputs.currentJsonLike, inputs.nextJsonLike), inputs.context)
                    : (0, utils_1.createRuleContextWithoutOperation)(spec, inputs.context);
                if (!this.matches(ruleContext)) {
                    continue;
                }
            }
            // This exemption is actually on the Fact level, rather than the spectral path
            // This is for consistency with our current rule engine. In the future we should attach exemptions on the nodes which trigger them, which would require us to rework the rules engine
            const rawForPath = json_pointer_helpers_1.jsonPointerHelpers.get(inputs.nextJsonLike, fact.location.jsonPath);
            const exempted = (0, utils_1.isExempted)(rawForPath, this.name);
            // TODO in the future update to pass in the JSON path from spectral, rather than the fact json path
            if (this.lifecycle === 'always') {
                results.push(toOpticResult(spectralResult, 'always', fact, {
                    exempted,
                    docsLink: this.docsLink,
                }));
            }
            else {
                // find if there is an appropriate change
                const maybeChange = changesByJsonPath[fact.location.jsonPath] ||
                    changesByJsonPath[json_pointer_helpers_1.jsonPointerHelpers.compile(spectralResult.path.map((i) => i.toString()))];
                if (maybeChange) {
                    if (this.lifecycle === 'added' && maybeChange.added) {
                        results.push(toOpticResult(spectralResult, 'added', maybeChange, {
                            exempted,
                            docsLink: this.docsLink,
                        }));
                    }
                    else if (this.lifecycle === 'changed' && maybeChange.changed) {
                        results.push(toOpticResult(spectralResult, 'changed', maybeChange, {
                            exempted,
                            docsLink: this.docsLink,
                        }));
                    }
                    else if (this.lifecycle === 'addedOrChanged' &&
                        (maybeChange.added || maybeChange.changed)) {
                        results.push(toOpticResult(spectralResult, 'addedOrChanged', maybeChange, {
                            exempted,
                            docsLink: this.docsLink,
                        }));
                    }
                }
            }
        }
        return results;
    }
}
exports.SpectralRule = SpectralRule;
async function runSpectral(spectralRuleset, afterSpecAbsolutePath) {
    const resultsOutput = node_path_1.default.join(node_os_1.default.tmpdir(), `spectral-output-${Math.floor(Math.random() * 100000)}.json`);
    return new Promise((resolve, reject) => {
        const spectralRunning = (0, child_process_1.spawn)('spectral', [
            'lint',
            afterSpecAbsolutePath,
            '--format=json',
            `--ruleset="${spectralRuleset}"`,
            `--o="${resultsOutput}"`,
            `--quiet`,
        ], { shell: false, cwd: process.cwd(), env: process.env });
        spectralRunning.stdout.on('data', function (data) {
            console.log('stdout: ' + data.toString());
        });
        let error = '';
        spectralRunning.stderr.on('data', function (data) {
            error = error + data.toString();
        });
        spectralRunning.on('exit', async function (code) {
            if (code !== 2) {
                resolve((await promises_1.default.readFile(resultsOutput)).toString());
                promises_1.default.unlink(resultsOutput);
            }
            else {
                reject(`Error running spectral ruleset ${spectralRuleset}: ${error}`);
            }
        });
        spectralRunning.on('error', () => {
            reject(`Error running Spectral CLI. Please install "npm install -g @stoplight/spectral-cli"`);
        });
    });
}
//# sourceMappingURL=spectral-rule.js.map