"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPropertyAssertions = exports.createResponseBodyAssertions = exports.createResponseAssertions = exports.createRequestAssertions = exports.createOperationAssertions = exports.createSpecificationAssertions = void 0;
const openapi_utilities_1 = require("@useoptic/openapi-utilities");
const lodash_pick_1 = __importDefault(require("lodash.pick"));
const errors_1 = require("../errors");
const specification_matchers_1 = require("./matchers/specification-matchers");
const operation_matchers_1 = require("./matchers/operation-matchers");
const response_matchers_1 = require("./matchers/response-matchers");
const request_body_matchers_1 = require("./matchers/request-body-matchers");
const response_body_matchers_1 = require("./matchers/response-body-matchers");
const sanitizeFact = (fact) => (0, lodash_pick_1.default)(fact, 'value', 'location');
const sanitizeChange = (change) => (0, lodash_pick_1.default)(change, 'changeType', 'added', 'removed', 'changed', 'location');
class AssertionRunner {
    constructor(type, severity) {
        this.type = type;
        this.createAssertionHelpers = (assertionKey) => {
            const registerAssertion = (...args) => {
                const assertion = args[1] || args[0];
                if (assertionKey === 'changedAssertions') {
                    this.changedAssertions.push((before, after) => {
                        assertion(after);
                    });
                }
                else if (assertionKey === 'addedAndChangedAssertions') {
                    this.addedAssertions.push(assertion);
                    this.changedAssertions.push((before, after) => {
                        assertion(after);
                    });
                }
                else {
                    this[assertionKey].push(assertion);
                }
            };
            // ts cannot infer through the blocks here that the registerAssertion function and
            // the value match up - which means we have to cast `as any`
            return {
                specification: (0, specification_matchers_1.createSpecificationHelpers)(registerAssertion),
                operation: (0, operation_matchers_1.createOperationHelpers)(registerAssertion),
                'query-parameter': {},
                'path-parameter': {},
                'header-parameter': {},
                'cookie-parameter': {},
                response: (0, response_matchers_1.createResponseHelpers)(registerAssertion),
                'response-header': {},
                'request-body': (0, request_body_matchers_1.createRequestBodyHelpers)(registerAssertion),
                'response-body': (0, response_body_matchers_1.createResponseBodyHelpers)(registerAssertion),
                property: {},
                schema: {},
            }[this.type];
        };
        this.createAssertion = (key) => {
            const baseAssertion = (...args) => {
                if (args.length === 2) {
                    const [_, assertion] = args;
                    this[key].push(assertion);
                }
                else {
                    this[key].push(args[0]);
                }
            };
            for (const [k, v] of Object.entries(this.createAssertionHelpers(key))) {
                baseAssertion[k] = v;
            }
            return baseAssertion;
        };
        this.createChangedAssertion = () => {
            const baseAssertion = (...args) => {
                if (args.length === 2) {
                    const [_, assertion] = args;
                    this.changedAssertions.push(assertion);
                }
                else {
                    this.changedAssertions.push(args[0]);
                }
            };
            for (const [k, v] of Object.entries(this.createAssertionHelpers('changedAssertions'))) {
                baseAssertion[k] = v;
            }
            return baseAssertion;
        };
        this.requirementAssertions = [];
        this.addedAssertions = [];
        this.changedAssertions = [];
        this.removedAssertions = [];
        this.severity = severity ?? openapi_utilities_1.Severity.Error;
    }
    get requirement() {
        return this.createAssertion('requirementAssertions');
    }
    get added() {
        return this.createAssertion('addedAssertions');
    }
    get changed() {
        return this.createChangedAssertion();
    }
    get removed() {
        return this.createAssertion('removedAssertions');
    }
    get addedOrChanged() {
        const baseAssertion = (...args) => {
            // normalize the assertion
            const normalizedAssertion = args.length === 2 ? args[1] : args[0];
            // push to both added and changed
            this.addedAssertions.push(normalizedAssertion);
            this.changedAssertions.push((_, ...args) => normalizedAssertion(...args));
        };
        // apply assertion helpers
        for (const [k, v] of Object.entries(this.createAssertionHelpers('addedAndChangedAssertions'))) {
            baseAssertion[k] = v;
        }
        return baseAssertion;
    }
    runBefore(before, change, exempted) {
        const results = [];
        if (change &&
            change.changeType === openapi_utilities_1.ChangeType.Removed &&
            this.removedAssertions.length > 0) {
            for (const assertion of this.removedAssertions) {
                try {
                    assertion(before);
                    results.push({
                        passed: true,
                        severity: this.severity,
                        exempted,
                        changeOrFact: sanitizeChange(change),
                        type: 'removed',
                    });
                }
                catch (e) {
                    if (errors_1.RuleError.isInstance(e)) {
                        results.push({
                            passed: false,
                            severity: e.severity ?? this.severity,
                            exempted,
                            changeOrFact: sanitizeChange(change),
                            error: e.toString(),
                            received: JSON.stringify(e.details.received),
                            expected: JSON.stringify(e.details.expected),
                            type: 'removed',
                        });
                    }
                    else {
                        const err = e;
                        err.type = 'user-error';
                        throw err;
                    }
                }
            }
        }
        return results;
    }
    runAfter(before, after, change, exempted) {
        const results = [];
        if (this.requirementAssertions.length > 0) {
            for (const assertion of this.requirementAssertions) {
                try {
                    assertion(after);
                    results.push({
                        passed: true,
                        severity: this.severity,
                        exempted,
                        changeOrFact: sanitizeFact(after),
                        type: 'requirement',
                    });
                }
                catch (e) {
                    if (errors_1.RuleError.isInstance(e)) {
                        results.push({
                            passed: false,
                            severity: e.severity ?? this.severity,
                            exempted,
                            changeOrFact: sanitizeFact(after),
                            received: JSON.stringify(e.details.received),
                            expected: JSON.stringify(e.details.expected),
                            error: e.toString(),
                            type: 'requirement',
                        });
                    }
                    else {
                        const err = e;
                        err.type = 'user-error';
                        throw err;
                    }
                }
            }
        }
        if (change &&
            change.changeType === openapi_utilities_1.ChangeType.Added &&
            this.addedAssertions.length > 0) {
            for (const assertion of this.addedAssertions) {
                try {
                    assertion(after);
                    results.push({
                        passed: true,
                        severity: this.severity,
                        exempted,
                        changeOrFact: sanitizeChange(change),
                        type: 'added',
                    });
                }
                catch (e) {
                    if (errors_1.RuleError.isInstance(e)) {
                        results.push({
                            passed: false,
                            severity: e.severity ?? this.severity,
                            exempted,
                            changeOrFact: sanitizeChange(change),
                            received: JSON.stringify(e.details.received),
                            expected: JSON.stringify(e.details.expected),
                            error: e.toString(),
                            type: 'added',
                        });
                    }
                    else {
                        const err = e;
                        err.type = 'user-error';
                        throw err;
                    }
                }
            }
        }
        if (before &&
            change &&
            change.changeType === openapi_utilities_1.ChangeType.Changed &&
            this.changedAssertions.length > 0) {
            for (const assertion of this.changedAssertions) {
                try {
                    assertion(before, after);
                    results.push({
                        passed: true,
                        severity: this.severity,
                        exempted,
                        changeOrFact: sanitizeChange(change),
                        type: 'changed',
                    });
                }
                catch (e) {
                    if (errors_1.RuleError.isInstance(e)) {
                        results.push({
                            passed: false,
                            severity: e.severity ?? this.severity,
                            exempted,
                            changeOrFact: sanitizeChange(change),
                            received: JSON.stringify(e.details.received),
                            expected: JSON.stringify(e.details.expected),
                            error: e.toString(),
                            type: 'changed',
                        });
                    }
                    else {
                        const err = e;
                        err.type = 'user-error';
                        throw err;
                    }
                }
            }
        }
        return results;
    }
}
const createSpecificationAssertions = (severity) => {
    return new AssertionRunner('specification', severity);
};
exports.createSpecificationAssertions = createSpecificationAssertions;
const createOperationAssertions = (severity) => {
    const operationAssertions = new AssertionRunner('operation', severity);
    const queryParameterAssertions = new AssertionRunner('query-parameter', severity);
    const headerParameterAssertions = new AssertionRunner('header-parameter', severity);
    const pathParameterAssertions = new AssertionRunner('path-parameter', severity);
    const cookieParameterAssertions = new AssertionRunner('cookie-parameter', severity);
    operationAssertions.queryParameter = queryParameterAssertions;
    operationAssertions.headerParameter = headerParameterAssertions;
    operationAssertions.pathParameter = pathParameterAssertions;
    operationAssertions.cookieParameter = cookieParameterAssertions;
    return operationAssertions;
};
exports.createOperationAssertions = createOperationAssertions;
const createRequestAssertions = (severity) => {
    const requestAssertions = {};
    const bodyAssertions = new AssertionRunner('request-body', severity);
    const propertyAssertions = new AssertionRunner('property', severity);
    const schemaAssertions = new AssertionRunner('schema', severity);
    requestAssertions.body = bodyAssertions;
    requestAssertions.property = propertyAssertions;
    requestAssertions.schema = schemaAssertions;
    return requestAssertions;
};
exports.createRequestAssertions = createRequestAssertions;
const createResponseAssertions = (severity) => {
    const responseAssertions = new AssertionRunner('response', severity);
    const headerAssertions = new AssertionRunner('response-header', severity);
    responseAssertions.header = headerAssertions;
    return responseAssertions;
};
exports.createResponseAssertions = createResponseAssertions;
const createResponseBodyAssertions = (severity) => {
    const responseBodyAssertions = {};
    const headerAssertions = new AssertionRunner('response-header', severity);
    const bodyAssertions = new AssertionRunner('response-body', severity);
    const propertyAssertions = new AssertionRunner('property', severity);
    const schemaAssertions = new AssertionRunner('schema', severity);
    responseBodyAssertions.header = headerAssertions;
    responseBodyAssertions.body = bodyAssertions;
    responseBodyAssertions.property = propertyAssertions;
    responseBodyAssertions.schema = schemaAssertions;
    return responseBodyAssertions;
};
exports.createResponseBodyAssertions = createResponseBodyAssertions;
const createPropertyAssertions = (severity) => {
    return new AssertionRunner('property', severity);
};
exports.createPropertyAssertions = createPropertyAssertions;
//# sourceMappingURL=assertions.js.map