"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOperationHelpers = void 0;
const errors_1 = require("../../errors");
const utils_1 = require("./utils");
const createOperationHelpers = (addAssertion) => {
    const createAssertions = (isNot) => {
        const conditionPrefix = isNot ? 'not ' : '';
        return {
            get not() {
                return createAssertions(true);
            },
            matches: (reference, options = {}) => {
                addAssertion(conditionPrefix + 'match expected shape', (value) => {
                    const { strict = false, errorMessage } = options;
                    if (isNot) {
                        if ((0, utils_1.valuesMatcher)(reference, value.raw, strict)) {
                            throw new errors_1.RuleError({
                                message: errorMessage
                                    ? errorMessage
                                    : strict
                                        ? 'Expected to not find an exact match'
                                        : 'Expected to not find a partial match',
                                received: value.raw,
                                expected: reference,
                            });
                        }
                    }
                    else {
                        if (!(0, utils_1.valuesMatcher)(reference, value.raw, strict)) {
                            throw new errors_1.RuleError({
                                message: errorMessage
                                    ? errorMessage
                                    : strict
                                        ? 'Expected an exact match'
                                        : 'Expected a partial match',
                                received: value.raw,
                                expected: reference,
                            });
                        }
                    }
                });
            },
            matchesOneOf: (references, options = {}) => {
                addAssertion(conditionPrefix + 'match expected shape', (value) => {
                    const { strict = false, errorMessage } = options;
                    if (isNot) {
                        const matchesNone = references.every((reference) => !(0, utils_1.valuesMatcher)(reference, value.raw, strict));
                        if (!matchesNone) {
                            throw new errors_1.RuleError({
                                message: errorMessage
                                    ? errorMessage
                                    : strict
                                        ? 'Expected to not find any exact matches'
                                        : 'Expected to not find any partial matches',
                                received: value.raw,
                                expected: references,
                            });
                        }
                    }
                    else {
                        const matchesAtleastOne = references.some((reference) => (0, utils_1.valuesMatcher)(reference, value.raw, strict));
                        if (!matchesAtleastOne) {
                            throw new errors_1.RuleError({
                                message: errorMessage
                                    ? errorMessage
                                    : strict
                                        ? 'Expected at least one exact match'
                                        : 'Expected at least one partial match',
                                received: value.raw,
                                expected: references,
                            });
                        }
                    }
                });
            },
            hasQueryParameterMatching: (parameterShape, options = {}) => {
                const { strict = false } = options;
                addAssertion(conditionPrefix + 'have query parameter matching shape', (operation) => {
                    const parameterMatchingShape = [
                        ...operation.queryParameters.values(),
                    ].find((queryParameter) => (0, utils_1.valuesMatcher)(parameterShape, queryParameter.raw, strict));
                    if (isNot) {
                        if (parameterMatchingShape) {
                            throw new errors_1.RuleError({
                                message: `Found a ${strict ? 'exact' : 'partial'} match in query parameters`,
                            });
                        }
                    }
                    else {
                        if (!parameterMatchingShape) {
                            throw new errors_1.RuleError({
                                message: `Could not find a ${strict ? 'exact' : 'partial'} match in query parameters`,
                            });
                        }
                    }
                });
            },
            hasPathParameterMatching: (parameterShape, options = {}) => {
                const { strict = false } = options;
                addAssertion(conditionPrefix + 'have path parameter matching shape', (operation) => {
                    const parameterMatchingShape = [
                        ...operation.pathParameters.values(),
                    ].find((pathParameter) => (0, utils_1.valuesMatcher)(parameterShape, pathParameter.raw, strict));
                    if (isNot) {
                        if (parameterMatchingShape) {
                            throw new errors_1.RuleError({
                                message: `Found a ${strict ? 'exact' : 'partial'} match in path parameters. Value to match: ${JSON.stringify(parameterShape)}`,
                            });
                        }
                    }
                    else {
                        if (!parameterMatchingShape) {
                            throw new errors_1.RuleError({
                                message: `Could not find a ${strict ? 'exact' : 'partial'} match in path parameters. Value to match: ${JSON.stringify(parameterShape)}`,
                            });
                        }
                    }
                });
            },
            hasHeaderParameterMatching: (parameterShape, options = {}) => {
                const { strict = false } = options;
                addAssertion(conditionPrefix + 'have header parameter matching shape', (operation) => {
                    const parameterMatchingShape = [
                        ...operation.headerParameters.values(),
                    ].find((headerParameter) => (0, utils_1.valuesMatcher)(parameterShape, headerParameter.raw, strict));
                    if (isNot) {
                        if (parameterMatchingShape) {
                            throw new errors_1.RuleError({
                                message: `Found a ${strict ? 'exact' : 'partial'} match in header parameters. Value to match: ${JSON.stringify(parameterShape)}`,
                            });
                        }
                    }
                    else {
                        if (!parameterMatchingShape) {
                            throw new errors_1.RuleError({
                                message: `Could not find a ${strict ? 'exact' : 'partial'} match in header parameters. Value to match: ${JSON.stringify(parameterShape)}`,
                            });
                        }
                    }
                });
            },
            hasCookieParameterMatching: (parameterShape, options = {}) => {
                const { strict = false } = options;
                addAssertion(conditionPrefix + 'have cookie parameter matching shape', (operation) => {
                    const parameterMatchingShape = [
                        ...operation.cookieParameters.values(),
                    ].find((cookieParameter) => (0, utils_1.valuesMatcher)(parameterShape, cookieParameter.raw, strict));
                    if (isNot) {
                        if (parameterMatchingShape) {
                            throw new errors_1.RuleError({
                                message: `Found a ${strict ? 'exact' : 'partial'} match in cookie parameters. Value to match: ${JSON.stringify(parameterShape)}`,
                            });
                        }
                    }
                    else {
                        if (!parameterMatchingShape) {
                            throw new errors_1.RuleError({
                                message: `Could not find a ${strict ? 'exact' : 'partial'} match in cookie parameters. Value to match: ${JSON.stringify(parameterShape)}`,
                            });
                        }
                    }
                });
            },
            hasRequests: (requests) => {
                addAssertion(conditionPrefix + 'have requests with content-type', (operation) => {
                    const operationRequestContentTypes = new Set(operation.requests.map((request) => request.contentType));
                    if (isNot) {
                        for (const { contentType } of requests) {
                            if (operationRequestContentTypes.has(contentType)) {
                                throw new errors_1.RuleError({
                                    message: `Operation has request with content-type ${contentType}`,
                                });
                            }
                        }
                    }
                    else {
                        for (const { contentType } of requests) {
                            if (!operationRequestContentTypes.has(contentType)) {
                                throw new errors_1.RuleError({
                                    message: `Operation does not have request with content-type ${contentType}`,
                                });
                            }
                        }
                    }
                });
            },
            hasResponses: (responses) => {
                addAssertion(conditionPrefix + 'have responses', (operation) => {
                    if (isNot) {
                        for (const { contentType, statusCode } of responses) {
                            const maybeResponse = operation.responses.get(statusCode);
                            if (contentType) {
                                if (maybeResponse &&
                                    maybeResponse.bodies.find((body) => body.contentType === contentType)) {
                                    throw new errors_1.RuleError({
                                        message: `Operation has response with content-type ${contentType} for status code ${statusCode} `,
                                    });
                                }
                            }
                            else {
                                if (maybeResponse) {
                                    throw new errors_1.RuleError({
                                        message: `Operation has response of status code ${statusCode}`,
                                    });
                                }
                            }
                        }
                    }
                    else {
                        for (const { contentType, statusCode } of responses) {
                            const maybeResponse = operation.responses.get(statusCode);
                            if (!maybeResponse) {
                                throw new errors_1.RuleError({
                                    message: `Operation does not have response of status code ${statusCode}`,
                                });
                            }
                            if (contentType &&
                                !maybeResponse.bodies.find((body) => body.contentType === contentType)) {
                                throw new errors_1.RuleError({
                                    message: `Operation does not have response with content-type ${contentType} for status code ${statusCode} `,
                                });
                            }
                        }
                    }
                });
            },
        };
    };
    return createAssertions(false);
};
exports.createOperationHelpers = createOperationHelpers;
//# sourceMappingURL=operation-matchers.js.map