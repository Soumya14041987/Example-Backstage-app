"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createResponseBodyHelpers = void 0;
const errors_1 = require("../../errors");
const utils_1 = require("./utils");
const createResponseBodyHelpers = (addAssertion) => {
    const createAssertions = (isNot) => {
        const conditionPrefix = isNot ? 'not ' : '';
        return {
            get not() {
                return createAssertions(true);
            },
            matches: (reference, options = {}) => {
                addAssertion(conditionPrefix + 'match expected shape', (value) => {
                    const { strict = false, errorMessage } = options;
                    if (isNot) {
                        if ((0, utils_1.valuesMatcher)(reference, value.raw, strict)) {
                            throw new errors_1.RuleError({
                                message: errorMessage
                                    ? errorMessage
                                    : strict
                                        ? 'Expected to not find an exact match'
                                        : 'Expected to not find a partial match',
                                received: value.raw,
                                expected: reference,
                            });
                        }
                    }
                    else {
                        if (!(0, utils_1.valuesMatcher)(reference, value.raw, strict)) {
                            throw new errors_1.RuleError({
                                message: errorMessage
                                    ? errorMessage
                                    : strict
                                        ? 'Expected an exact match'
                                        : 'Expected a partial match',
                                received: value.raw,
                                expected: reference,
                            });
                        }
                    }
                });
            },
            matchesOneOf: (references, options = {}) => {
                addAssertion(conditionPrefix + 'match expected shape', (value) => {
                    const { strict = false, errorMessage } = options;
                    if (isNot) {
                        const matchesNone = references.every((reference) => !(0, utils_1.valuesMatcher)(reference, value.raw, strict));
                        if (!matchesNone) {
                            throw new errors_1.RuleError({
                                message: errorMessage
                                    ? errorMessage
                                    : strict
                                        ? 'Expected to not find any exact matches'
                                        : 'Expected to not find any partial matches',
                                received: value.raw,
                                expected: references,
                            });
                        }
                    }
                    else {
                        const matchesAtleastOne = references.some((reference) => (0, utils_1.valuesMatcher)(reference, value.raw, strict));
                        if (!matchesAtleastOne) {
                            throw new errors_1.RuleError({
                                message: errorMessage
                                    ? errorMessage
                                    : strict
                                        ? 'Expected at least one exact match'
                                        : 'Expected at least one partial match',
                                received: value.raw,
                                expected: references,
                            });
                        }
                    }
                });
            },
        };
    };
    return createAssertions(false);
};
exports.createResponseBodyHelpers = createResponseBodyHelpers;
//# sourceMappingURL=response-body-matchers.js.map