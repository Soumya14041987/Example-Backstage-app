"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.valuesMatcher = exports.Matchers = exports.Matcher = void 0;
class Matcher {
    constructor(matcher, name) {
        this.matcher = matcher;
        this.name = name;
        this.type = 'matcher';
    }
    match(value) {
        return this.matcher(value);
    }
    toString() {
        return this.name ? `Matcher.${this.name}` : 'CustomMatcher';
    }
    toJSON() {
        return this.toString();
    }
    static isInstance(v) {
        return v?.type === 'matcher';
    }
}
exports.Matcher = Matcher;
exports.Matchers = {
    string: new Matcher((value) => typeof value === 'string', 'string'),
    boolean: new Matcher((value) => typeof value === 'boolean', 'boolean'),
    number: new Matcher((value) => typeof value === 'number', 'number'),
};
function setEquals(as, bs) {
    if (as.size !== bs.size)
        return false;
    for (var a of as)
        if (!bs.has(a))
            return false;
    return true;
}
const arraysMatcher = (reference, arrayToMatch, strict) => {
    if (strict && reference.length !== arrayToMatch.length) {
        return false;
    }
    // pointer from reference array index to an array of matching arrayToMatch indices
    const referenceMatchResults = new Map(reference.map((_, i) => [i, []]));
    // find all the matched indices for each reference index
    for (let i = 0; i < reference.length; i++) {
        // reference array
        const referenceValue = reference[i];
        const matchedIndicesArray = referenceMatchResults.get(i);
        for (let j = 0; j < arrayToMatch.length; j++) {
            if ((0, exports.valuesMatcher)(referenceValue, arrayToMatch[j], strict)) {
                matchedIndicesArray.push(j);
            }
        }
    }
    return [...referenceMatchResults.values()].every((matchedIndices) => matchedIndices.length > 0);
};
// matches an object against a reference
// strict === true means we do an exact match, otherwise a partial match is done
const valuesMatcher = (reference, objectToMatch, strict = false) => {
    // handle null / array
    if (Matcher.isInstance(reference)) {
        return reference.match(objectToMatch);
    }
    else if (reference === null || typeof reference !== 'object') {
        return reference === objectToMatch;
    }
    else if (Array.isArray(reference)) {
        return (Array.isArray(objectToMatch) &&
            arraysMatcher(reference, objectToMatch, strict));
    }
    else {
        if (objectToMatch === null ||
            typeof objectToMatch !== 'object' ||
            Array.isArray(objectToMatch)) {
            return false;
        }
        for (const [key, referenceValue] of Object.entries(reference)) {
            if (!(0, exports.valuesMatcher)(referenceValue, objectToMatch[key], strict)) {
                return false;
            }
        }
        if (strict) {
            const referenceKeys = new Set(Object.keys(reference));
            const matchKeys = new Set(Object.keys(objectToMatch));
            return setEquals(referenceKeys, matchKeys);
        }
    }
    return true;
};
exports.valuesMatcher = valuesMatcher;
//# sourceMappingURL=utils.js.map