"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runResponseBodyRules = void 0;
const data_constructors_1 = require("./data-constructors");
const utils_1 = require("./utils");
const assertions_1 = require("./assertions");
const rule_filters_1 = require("./rule-filters");
const createResponseBodyResult = (assertionResult, response, operation, rule) => ({
    type: assertionResult.type,
    severity: assertionResult.severity,
    where: `${operation.method.toUpperCase()} ${operation.path} response ${response.statusCode} response body: ${response.contentType}`,
    isMust: true,
    change: assertionResult.changeOrFact,
    name: rule.name,
    condition: assertionResult.condition,
    passed: assertionResult.passed,
    exempted: assertionResult.exempted,
    error: assertionResult.error,
    received: assertionResult.received,
    expected: assertionResult.expected,
    docsLink: rule.docsLink,
    isShould: false,
});
const createResponsePropertyResult = (assertionResult, propertyOrSchema, response, operation, rule) => ({
    type: assertionResult.type,
    severity: assertionResult.severity,
    where: `${operation.method.toUpperCase()} ${operation.path} response ${response.statusCode} response body: ${response.contentType} property ${propertyOrSchema.location.conceptualLocation.jsonSchemaTrail.join('/')}`,
    isMust: true,
    change: assertionResult.changeOrFact,
    name: rule.name,
    condition: assertionResult.condition,
    passed: assertionResult.passed,
    exempted: assertionResult.exempted,
    error: assertionResult.error,
    received: assertionResult.received,
    expected: assertionResult.expected,
    docsLink: rule.docsLink,
    isShould: false,
});
const runResponseBodyRules = ({ specificationNode, operationNode, responseNode, rules, customRuleContext, beforeApiSpec, afterApiSpec, }) => {
    const results = [];
    const responseRules = (0, rule_filters_1.getResponseBodyRules)(rules);
    const propertyRules = (0, rule_filters_1.getPropertyRules)(rules);
    const beforeSpecification = (0, data_constructors_1.createSpecification)(specificationNode, 'before', beforeApiSpec);
    const beforeOperation = (0, data_constructors_1.createOperation)(operationNode, 'before', beforeApiSpec);
    const afterSpecification = (0, data_constructors_1.createSpecification)(specificationNode, 'after', afterApiSpec);
    const afterOperation = (0, data_constructors_1.createOperation)(operationNode, 'after', afterApiSpec);
    // Runs rules on all responses bodies - this will:
    // - run rules with values from the before spec (this will trigger `removed` rules)
    // - run rules with values from the after spec (this will trigger `added`, `changed` and `requirement` rules)
    // for each rule:
    // - if there is a matches block, check if the current operation matches the rule `matches` condition
    // - if yes, run the user's defined `rule`. for responses, this runs against the response body and response properties
    for (const responseRule of responseRules) {
        if (beforeOperation && beforeSpecification) {
            // Default to after rule context if available
            const ruleContext = (0, utils_1.createRuleContextWithOperation)({
                node: specificationNode,
                before: beforeSpecification,
                after: afterSpecification,
            }, {
                node: operationNode,
                before: beforeOperation,
                after: afterOperation,
            }, customRuleContext);
            const responseAssertions = (0, assertions_1.createResponseBodyAssertions)(responseRule.severity);
            // Register the user's rule definition, this is collected in the responseAssertions object
            responseRule.rule(responseAssertions, ruleContext);
            const beforeResponse = (0, data_constructors_1.createResponse)(responseNode, 'before', beforeApiSpec);
            if (beforeResponse) {
                for (const beforeBody of beforeResponse.bodies) {
                    const matches = !responseRule.matches ||
                        responseRule.matches(beforeBody, ruleContext);
                    const exempted = (0, utils_1.isExempted)(beforeBody.raw, responseRule.name);
                    if (matches) {
                        // Run the user's rules that have been stored in responseAssertions for body
                        results.push(...responseAssertions.body
                            .runBefore(beforeBody, responseNode.bodies.get(beforeBody.contentType)?.change ||
                            null, exempted)
                            .map((assertionResult) => createResponseBodyResult(assertionResult, beforeBody, beforeOperation, responseRule)));
                        for (const [key, property] of beforeBody.properties.entries()) {
                            const propertyChange = responseNode.bodies.get(beforeBody.contentType)?.fields.get(key)
                                ?.change || null;
                            // Run the user's rules that have been stored in responseAssertions for property
                            results.push(...responseAssertions.property
                                .runBefore(property, propertyChange, exempted)
                                .map((assertionResult) => createResponsePropertyResult(assertionResult, property, beforeBody, beforeOperation, responseRule)));
                        }
                        for (const [key, schema] of beforeBody.schemas.entries()) {
                            const propertyChange = responseNode.bodies
                                .get(beforeBody.contentType)
                                ?.schemas.get(key)?.change || null;
                            // Run the user's rules that have been stored in responseAssertions for property
                            results.push(...responseAssertions.schema
                                .runBefore(schema, propertyChange, exempted)
                                .map((assertionResult) => createResponsePropertyResult(assertionResult, schema, beforeBody, beforeOperation, responseRule)));
                        }
                    }
                }
            }
        }
        if (afterOperation && afterSpecification) {
            const ruleContext = (0, utils_1.createRuleContextWithOperation)({
                node: specificationNode,
                before: beforeSpecification,
                after: afterSpecification,
            }, {
                node: operationNode,
                before: beforeOperation,
                after: afterOperation,
            }, customRuleContext);
            // Register the user's rule definition, this is collected in the responseAssertions object
            const responseAssertions = (0, assertions_1.createResponseBodyAssertions)(responseRule.severity);
            // Run the user's rules that have been stored in responseAssertions
            responseRule.rule(responseAssertions, ruleContext);
            const maybeBeforeResponse = (0, data_constructors_1.createResponse)(responseNode, 'before', beforeApiSpec);
            const afterResponse = (0, data_constructors_1.createResponse)(responseNode, 'after', afterApiSpec);
            if (afterResponse) {
                for (const afterBody of afterResponse.bodies) {
                    const maybeBeforeBody = maybeBeforeResponse?.bodies.find((body) => body.contentType === afterBody.contentType) || null;
                    const matches = !responseRule.matches ||
                        responseRule.matches(afterBody, ruleContext);
                    const exempted = (0, utils_1.isExempted)(afterBody.raw, responseRule.name);
                    if (matches) {
                        // Run the user's rules that have been stored in responseAssertions for body
                        results.push(...responseAssertions.body
                            .runAfter(maybeBeforeBody, afterBody, responseNode.bodies.get(afterBody.contentType)?.change ||
                            null, exempted)
                            .map((assertionResult) => createResponseBodyResult(assertionResult, afterBody, afterOperation, responseRule)));
                        for (const [key, property] of afterBody.properties.entries()) {
                            const maybeBeforeProperty = maybeBeforeBody?.properties.get(key) || null;
                            const propertyChange = responseNode.bodies.get(afterBody.contentType)?.fields.get(key)
                                ?.change || null;
                            // Run the user's rules that have been stored in responseAssertions for property
                            results.push(...responseAssertions.property
                                .runAfter(maybeBeforeProperty, property, propertyChange, exempted)
                                .map((assertionResult) => createResponsePropertyResult(assertionResult, property, afterBody, afterOperation, responseRule)));
                        }
                        for (const [key, schema] of afterBody.schemas.entries()) {
                            const maybeBeforeSchema = maybeBeforeBody?.schemas.get(key) || null;
                            const propertyChange = responseNode.bodies.get(afterBody.contentType)?.schemas.get(key)
                                ?.change || null;
                            // Run the user's rules that have been stored in responseAssertions for property
                            results.push(...responseAssertions.schema
                                .runAfter(maybeBeforeSchema, schema, propertyChange, exempted)
                                .map((assertionResult) => createResponsePropertyResult(assertionResult, schema, afterBody, afterOperation, responseRule)));
                        }
                    }
                }
            }
        }
    }
    for (const propertyRule of propertyRules) {
        if (beforeOperation && beforeSpecification) {
            const ruleContext = (0, utils_1.createRuleContextWithOperation)({
                node: specificationNode,
                before: beforeSpecification,
                after: afterSpecification,
            }, {
                node: operationNode,
                before: beforeOperation,
                after: afterOperation,
            }, customRuleContext);
            const propertyAssertions = (0, assertions_1.createPropertyAssertions)(propertyRule.severity);
            // // Register the user's rule definition, this is collected in the propertyAssertions object
            propertyRule.rule(propertyAssertions, ruleContext);
            const beforeResponse = (0, data_constructors_1.createResponse)(responseNode, 'before', beforeApiSpec);
            if (beforeResponse) {
                for (const beforeBody of beforeResponse.bodies) {
                    for (const [key, property] of beforeBody.properties.entries()) {
                        const matches = !propertyRule.matches ||
                            propertyRule.matches(property, ruleContext);
                        const exempted = (0, utils_1.isExempted)(property.raw, propertyRule.name);
                        const propertyChange = responseNode.bodies.get(beforeBody.contentType)?.fields.get(key)
                            ?.change || null;
                        if (matches) {
                            results.push(...propertyAssertions
                                .runBefore(property, propertyChange, exempted)
                                .map((assertionResult) => createResponsePropertyResult(assertionResult, property, beforeBody, beforeOperation, propertyRule)));
                        }
                    }
                }
            }
        }
        if (afterOperation && afterSpecification) {
            const ruleContext = (0, utils_1.createRuleContextWithOperation)({
                node: specificationNode,
                before: beforeSpecification,
                after: afterSpecification,
            }, {
                node: operationNode,
                before: beforeOperation,
                after: afterOperation,
            }, customRuleContext);
            // Register the user's rule definition, this is collected in the propertyAssertions object
            const propertyAssertions = (0, assertions_1.createPropertyAssertions)(propertyRule.severity);
            // Run the user's rules that have been stored in propertyAssertions
            propertyRule.rule(propertyAssertions, ruleContext);
            const maybeBeforeResponse = (0, data_constructors_1.createResponse)(responseNode, 'before', beforeApiSpec);
            const afterResponse = (0, data_constructors_1.createResponse)(responseNode, 'after', afterApiSpec);
            if (afterResponse) {
                for (const afterBody of afterResponse.bodies) {
                    const maybeBeforeBody = maybeBeforeResponse?.bodies.find((body) => body.contentType === afterBody.contentType) || null;
                    for (const [key, property] of afterBody.properties.entries()) {
                        const maybeBeforeProperty = maybeBeforeBody?.properties.get(key) || null;
                        const propertyChange = responseNode.bodies.get(afterBody.contentType)?.fields.get(key)
                            ?.change || null;
                        const matches = !propertyRule.matches ||
                            propertyRule.matches(property, ruleContext);
                        const exempted = (0, utils_1.isExempted)(property.raw, propertyRule.name);
                        if (matches) {
                            // Run the user's rules that have been stored in propertyAssertions for property
                            results.push(...propertyAssertions
                                .runAfter(maybeBeforeProperty, property, propertyChange, exempted)
                                .map((assertionResult) => createResponsePropertyResult(assertionResult, property, afterBody, afterOperation, propertyRule)));
                        }
                    }
                }
            }
        }
    }
    return results;
};
exports.runResponseBodyRules = runResponseBodyRules;
//# sourceMappingURL=response-body.js.map