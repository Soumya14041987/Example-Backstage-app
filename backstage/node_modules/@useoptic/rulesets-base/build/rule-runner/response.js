"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runResponseRules = void 0;
const data_constructors_1 = require("./data-constructors");
const utils_1 = require("./utils");
const assertions_1 = require("./assertions");
const rule_filters_1 = require("./rule-filters");
const createResponseResult = (assertionResult, response, operation, rule) => ({
    type: assertionResult.type,
    severity: assertionResult.severity,
    where: `${operation.method.toUpperCase()} ${operation.path} response ${response.statusCode}`,
    isMust: true,
    change: assertionResult.changeOrFact,
    name: rule.name,
    condition: assertionResult.condition,
    passed: assertionResult.passed,
    exempted: assertionResult.exempted,
    received: assertionResult.received,
    expected: assertionResult.expected,
    error: assertionResult.error,
    docsLink: rule.docsLink,
    isShould: false,
});
const createResponseHeaderResult = (assertionResult, header, response, operation, rule) => ({
    type: assertionResult.type,
    severity: assertionResult.severity,
    where: `${operation.method.toUpperCase()} ${operation.path} response ${response.statusCode} response header: ${header}`,
    isMust: true,
    change: assertionResult.changeOrFact,
    name: rule.name,
    condition: assertionResult.condition,
    passed: assertionResult.passed,
    exempted: assertionResult.exempted,
    received: assertionResult.received,
    expected: assertionResult.expected,
    error: assertionResult.error,
    docsLink: rule.docsLink,
    isShould: false,
});
const runResponseRules = ({ specificationNode, operationNode, responseNode, rules, customRuleContext, beforeApiSpec, afterApiSpec, }) => {
    const results = [];
    const responseRules = (0, rule_filters_1.getResponseRules)(rules);
    const beforeSpecification = (0, data_constructors_1.createSpecification)(specificationNode, 'before', beforeApiSpec);
    const beforeOperation = (0, data_constructors_1.createOperation)(operationNode, 'before', beforeApiSpec);
    const afterSpecification = (0, data_constructors_1.createSpecification)(specificationNode, 'after', afterApiSpec);
    const afterOperation = (0, data_constructors_1.createOperation)(operationNode, 'after', afterApiSpec);
    // Runs rules on all responses  - this will:
    // - run rules with values from the before spec (this will trigger `removed` rules)
    // - run rules with values from the after spec (this will trigger `added`, `changed` and `requirement` rules)
    // for each rule:
    // - if there is a matches block, check if the current operation matches the rule `matches` condition
    // - if yes, run the user's defined `rule`. for responses, this runs against the response and response headers
    for (const responseRule of responseRules) {
        if (beforeOperation && beforeSpecification) {
            const ruleContext = (0, utils_1.createRuleContextWithOperation)({
                node: specificationNode,
                before: beforeSpecification,
                after: afterSpecification,
            }, {
                node: operationNode,
                before: beforeOperation,
                after: afterOperation,
            }, customRuleContext);
            const beforeResponse = (0, data_constructors_1.createResponse)(responseNode, 'before', beforeApiSpec);
            const responseAssertions = (0, assertions_1.createResponseAssertions)(responseRule.severity);
            // Register the user's rule definition, this is collected in the responseAssertions object
            responseRule.rule(responseAssertions, ruleContext);
            if (beforeResponse) {
                const matches = !responseRule.matches ||
                    responseRule.matches(beforeResponse, ruleContext);
                const exempted = (0, utils_1.isExempted)(beforeResponse.raw, responseRule.name);
                if (matches) {
                    // Run the user's rules that have been stored in responseAssertions
                    results.push(...responseAssertions
                        .runBefore(beforeResponse, responseNode.change, exempted)
                        .map((assertionResult) => createResponseResult(assertionResult, beforeResponse, beforeOperation, responseRule)));
                    for (const [key, header] of beforeResponse.headers.entries()) {
                        const headerChange = responseNode.headers.get(key)?.change || null;
                        // Run the user's rules that have been stored in responseAssertions for header
                        results.push(...responseAssertions.header
                            .runBefore(header, headerChange, exempted)
                            .map((assertionResult) => createResponseHeaderResult(assertionResult, key, beforeResponse, beforeOperation, responseRule)));
                    }
                }
            }
        }
        if (afterOperation && afterSpecification) {
            const ruleContext = (0, utils_1.createRuleContextWithOperation)({
                node: specificationNode,
                before: beforeSpecification,
                after: afterSpecification,
            }, {
                node: operationNode,
                before: beforeOperation,
                after: afterOperation,
            }, customRuleContext);
            const maybeBeforeResponse = (0, data_constructors_1.createResponse)(responseNode, 'before', beforeApiSpec);
            const afterResponse = (0, data_constructors_1.createResponse)(responseNode, 'after', afterApiSpec);
            const responseAssertions = (0, assertions_1.createResponseAssertions)(responseRule.severity);
            // Register the user's rule definition, this is collected in the responseAssertions object
            responseRule.rule(responseAssertions, ruleContext);
            if (afterResponse) {
                const matches = !responseRule.matches ||
                    responseRule.matches(afterResponse, ruleContext);
                const exempted = (0, utils_1.isExempted)(afterResponse.raw, responseRule.name);
                if (matches) {
                    // Run the user's rules that have been stored in responseAssertions
                    results.push(...responseAssertions
                        .runAfter(maybeBeforeResponse, afterResponse, responseNode.change, exempted)
                        .map((assertionResult) => createResponseResult(assertionResult, afterResponse, afterOperation, responseRule)));
                    for (const [key, header] of afterResponse.headers.entries()) {
                        const maybeBeforeHeader = maybeBeforeResponse?.headers.get(key) || null;
                        const headerChange = responseNode.headers.get(key)?.change || null;
                        // Run the user's rules that have been stored in responseAssertions for header
                        results.push(...responseAssertions.header
                            .runAfter(maybeBeforeHeader, header, headerChange, exempted)
                            .map((assertionResult) => createResponseHeaderResult(assertionResult, key, afterResponse, afterOperation, responseRule)));
                    }
                }
            }
        }
    }
    return results;
};
exports.runResponseRules = runResponseRules;
//# sourceMappingURL=response.js.map