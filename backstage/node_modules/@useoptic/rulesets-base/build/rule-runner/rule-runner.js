"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleRunner = void 0;
const openapi_utilities_1 = require("@useoptic/openapi-utilities");
const spectral_core_1 = require("@stoplight/spectral-core");
const spectral_rulesets_1 = require("@stoplight/spectral-rulesets");
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
const lodash_isequal_1 = __importDefault(require("lodash.isequal"));
const group_facts_1 = require("./group-facts");
const specification_1 = require("./specification");
const operation_1 = require("./operation");
const request_1 = require("./request");
const response_body_1 = require("./response-body");
const response_1 = require("./response");
const external_rule_base_1 = require("../rules/external-rule-base");
function resultToRuleResult(r) {
    return {
        where: r.where,
        error: r.error,
        passed: r.passed,
        exempted: r.exempted,
        location: {
            jsonPath: r.change.location.jsonPath,
            spec: 'removed' in r.change && !!r.change.removed?.before
                ? 'before'
                : 'after',
        },
        name: r.name ?? 'Rule',
        type: r.type,
        docsLink: r.docsLink,
        expected: r.expected,
        received: r.received,
        severity: r.severity ?? openapi_utilities_1.Severity.Error,
    };
}
class RuleRunner {
    constructor(rules) {
        this.rules = rules;
    }
    // TODO deprecate this once spectral rules are natively supported
    async runSpectralRules({ ruleset, nextFacts, nextJsonLike, }) {
        if (nextJsonLike['x-optic-ci-empty-spec'] === true) {
            return [];
        }
        const spectral = new spectral_core_1.Spectral();
        spectral.setRuleset({
            extends: [[spectral_rulesets_1.oas, 'all']],
            rules: ruleset,
        });
        const operations = nextFacts.filter((i) => i.location.kind === openapi_utilities_1.OpenApiKind.Operation);
        const results = await spectral.run(nextJsonLike);
        const opticResult = results.map((spectralResult) => {
            const operationPath = spectralResult.path.slice(0, 3);
            const matchingOperation = operations.find((i) => (0, lodash_isequal_1.default)(i.location.conceptualPath, operationPath));
            const location = {
                conceptualLocation: (matchingOperation
                    ? matchingOperation.location.conceptualLocation
                    : { path: 'This Specification', method: '' }),
                jsonPath: json_pointer_helpers_1.jsonPointerHelpers.compile(spectralResult.path.map((i) => i.toString())),
                conceptualPath: [],
                kind: 'API',
            };
            return {
                condition: spectralResult.code.toString(),
                passed: false,
                error: spectralResult.message,
                isMust: true,
                isShould: false,
                where: 'requirement ',
                change: {
                    location,
                },
            };
        });
        return opticResult;
    }
    // TODO deprecate
    async runRulesWithFacts(inputs) {
        const { context, currentFacts, nextFacts, changelog, currentJsonLike: beforeApiSpec, nextJsonLike: afterApiSpec, } = inputs;
        const externalRules = this.rules.filter((rule) => external_rule_base_1.ExternalRuleBase.isInstance(rule));
        const rulesOrRulesets = this.rules.filter((rule) => !external_rule_base_1.ExternalRuleBase.isInstance(rule));
        // Groups the flat list of beforefacts, afterfacts and changes by location (e.g. operation, query parameter, response, response property, etc).
        // A node can contain a before fact, after fact and or change.
        const openApiFactNodes = (0, group_facts_1.groupFacts)({
            beforeFacts: currentFacts,
            afterFacts: nextFacts,
            changes: changelog,
        });
        const externalResults = [];
        for (const externalRule of externalRules) {
            const results = await externalRule.runRules({
                ...inputs,
                groupedFacts: openApiFactNodes,
            });
            externalResults.push(...results);
        }
        // Run rules on specifications and collect the results
        const specificationResults = (0, specification_1.runSpecificationRules)({
            specificationNode: openApiFactNodes.specification,
            rules: rulesOrRulesets,
            customRuleContext: context,
            beforeApiSpec,
            afterApiSpec,
        });
        const endpointResults = [];
        // For each endpoint from the endpoint fact nodes (this will include endpoints in both before and after specs) run rules and collect the results
        for (const endpointNode of openApiFactNodes.endpoints.values()) {
            const operationResults = (0, operation_1.runOperationRules)({
                specificationNode: openApiFactNodes.specification,
                operationNode: endpointNode,
                rules: rulesOrRulesets,
                customRuleContext: context,
                beforeApiSpec,
                afterApiSpec,
            });
            endpointResults.push(...operationResults);
            const requestRules = (0, request_1.runRequestRules)({
                specificationNode: openApiFactNodes.specification,
                operationNode: endpointNode,
                requestNode: endpointNode.request,
                rules: rulesOrRulesets,
                customRuleContext: context,
                beforeApiSpec,
                afterApiSpec,
            });
            endpointResults.push(...requestRules);
            for (const responseNode of endpointNode.responses.values()) {
                const responseRules = (0, response_1.runResponseRules)({
                    specificationNode: openApiFactNodes.specification,
                    operationNode: endpointNode,
                    responseNode: responseNode,
                    rules: rulesOrRulesets,
                    customRuleContext: context,
                    beforeApiSpec,
                    afterApiSpec,
                });
                const responseBodyRules = (0, response_body_1.runResponseBodyRules)({
                    specificationNode: openApiFactNodes.specification,
                    operationNode: endpointNode,
                    responseNode: responseNode,
                    rules: rulesOrRulesets,
                    customRuleContext: context,
                    beforeApiSpec,
                    afterApiSpec,
                });
                endpointResults.push(...responseBodyRules, ...responseRules);
            }
        }
        return [...externalResults, ...specificationResults, ...endpointResults];
    }
    async runRules(inputs) {
        const { context, fromSpec: beforeApiSpec, toSpec: afterApiSpec } = inputs;
        const externalRules = this.rules.filter((rule) => external_rule_base_1.ExternalRuleBase.isInstance(rule));
        const rulesOrRulesets = this.rules.filter((rule) => !external_rule_base_1.ExternalRuleBase.isInstance(rule));
        // TODO reimplement the rule runner so we don't need to generate legacy fact types here
        const beforeFacts = inputs.fromSpec['x-optic-ci-empty-spec'] === true
            ? []
            : (0, openapi_utilities_1.traverseSpec)(inputs.fromSpec);
        const afterFacts = inputs.toSpec['x-optic-ci-empty-spec'] === true
            ? []
            : (0, openapi_utilities_1.traverseSpec)(inputs.toSpec);
        const changelog = (0, openapi_utilities_1.factsToChangelog)(beforeFacts, afterFacts);
        const openApiFactNodes = (0, group_facts_1.groupFacts)({
            beforeFacts,
            afterFacts,
            changes: changelog,
        });
        const externalResults = [];
        for (const externalRule of externalRules) {
            const results = await externalRule.runRulesV2({
                ...inputs,
                groupedFacts: openApiFactNodes,
            });
            externalResults.push(...results);
        }
        // Run rules on specifications and collect the results
        const specificationResults = (0, specification_1.runSpecificationRules)({
            specificationNode: openApiFactNodes.specification,
            rules: rulesOrRulesets,
            customRuleContext: context,
            beforeApiSpec,
            afterApiSpec,
        }).map(resultToRuleResult);
        const endpointResults = [];
        // For each endpoint from the endpoint fact nodes (this will include endpoints in both before and after specs) run rules and collect the results
        for (const endpointNode of openApiFactNodes.endpoints.values()) {
            const operationResults = (0, operation_1.runOperationRules)({
                specificationNode: openApiFactNodes.specification,
                operationNode: endpointNode,
                rules: rulesOrRulesets,
                customRuleContext: context,
                beforeApiSpec,
                afterApiSpec,
            });
            endpointResults.push(...operationResults.map(resultToRuleResult));
            const requestRules = (0, request_1.runRequestRules)({
                specificationNode: openApiFactNodes.specification,
                operationNode: endpointNode,
                requestNode: endpointNode.request,
                rules: rulesOrRulesets,
                customRuleContext: context,
                beforeApiSpec,
                afterApiSpec,
            });
            endpointResults.push(...requestRules.map(resultToRuleResult));
            for (const responseNode of endpointNode.responses.values()) {
                const responseRules = (0, response_1.runResponseRules)({
                    specificationNode: openApiFactNodes.specification,
                    operationNode: endpointNode,
                    responseNode: responseNode,
                    rules: rulesOrRulesets,
                    customRuleContext: context,
                    beforeApiSpec,
                    afterApiSpec,
                });
                const responseBodyRules = (0, response_body_1.runResponseBodyRules)({
                    specificationNode: openApiFactNodes.specification,
                    operationNode: endpointNode,
                    responseNode: responseNode,
                    rules: rulesOrRulesets,
                    customRuleContext: context,
                    beforeApiSpec,
                    afterApiSpec,
                });
                endpointResults.push(...responseBodyRules.map(resultToRuleResult), ...responseRules.map(resultToRuleResult));
            }
        }
        return [...externalResults, ...specificationResults, ...endpointResults];
    }
}
exports.RuleRunner = RuleRunner;
//# sourceMappingURL=rule-runner.js.map