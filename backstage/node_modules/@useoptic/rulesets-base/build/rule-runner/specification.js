"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runSpecificationRules = void 0;
const data_constructors_1 = require("./data-constructors");
const utils_1 = require("./utils");
const assertions_1 = require("./assertions");
const rule_filters_1 = require("./rule-filters");
const createSpecificationResult = (assertionResult, rule) => ({
    type: assertionResult.type,
    severity: assertionResult.severity,
    where: `specification`,
    isMust: true,
    change: assertionResult.changeOrFact,
    name: rule.name,
    condition: assertionResult.condition,
    passed: assertionResult.passed,
    exempted: assertionResult.exempted,
    received: assertionResult.received,
    expected: assertionResult.expected,
    error: assertionResult.error,
    docsLink: rule.docsLink,
    isShould: false,
});
const runSpecificationRules = ({ specificationNode, rules, customRuleContext, beforeApiSpec, afterApiSpec, }) => {
    const results = [];
    const specificationRules = (0, rule_filters_1.getSpecificationRules)(rules);
    const beforeSpecification = (0, data_constructors_1.createSpecification)(specificationNode, 'before', beforeApiSpec);
    const afterSpecification = (0, data_constructors_1.createSpecification)(specificationNode, 'after', afterApiSpec);
    for (const specificationRule of specificationRules) {
        // rules that are triggered and use the data from the `before` specification are: `removed`
        if (beforeSpecification) {
            const rulesContext = (0, utils_1.createRuleContextWithoutOperation)({
                before: beforeSpecification,
                after: afterSpecification,
                node: specificationNode,
            }, customRuleContext);
            const matches = !specificationRule.matches ||
                specificationRule.matches(beforeSpecification, rulesContext);
            const exempted = (0, utils_1.isExempted)(beforeSpecification.raw, specificationRule.name);
            if (matches) {
                const specificationAssertions = (0, assertions_1.createSpecificationAssertions)(specificationRule.severity);
                // Register the user's rule definition, this is collected in the specificationAssertions object
                specificationRule.rule(specificationAssertions, rulesContext);
                // Run the user's rules that have been stored in specificationAssertions
                results.push(...specificationAssertions
                    .runBefore(beforeSpecification, specificationNode.change, exempted)
                    .map((assertionResult) => createSpecificationResult(assertionResult, specificationRule)));
            }
        }
        if (afterSpecification) {
            const rulesContext = (0, utils_1.createRuleContextWithoutOperation)({
                before: beforeSpecification,
                after: afterSpecification,
                node: specificationNode,
            }, customRuleContext);
            const matches = !specificationRule.matches ||
                specificationRule.matches(afterSpecification, rulesContext);
            const exempted = (0, utils_1.isExempted)(afterSpecification.raw, specificationRule.name);
            if (matches) {
                const specificationAssertions = (0, assertions_1.createSpecificationAssertions)(specificationRule.severity);
                // Register the user's rule definition, this is collected in the specificationAssertions object
                specificationRule.rule(specificationAssertions, rulesContext);
                // Run the user's rules that have been stored in specificationAssertions
                results.push(...specificationAssertions
                    .runAfter(beforeSpecification, afterSpecification, specificationNode.change, exempted)
                    .map((assertionResult) => createSpecificationResult(assertionResult, specificationRule)));
            }
        }
    }
    return results;
};
exports.runSpecificationRules = runSpecificationRules;
//# sourceMappingURL=specification.js.map