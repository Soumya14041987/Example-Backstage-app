import { OperationRule } from './operation-rule';
import { RequestRule } from './request-rule';
import { ResponseRule } from './response-rule';
import { ResponseBodyRule } from './response-body-rule';
import { SpecificationRule } from './specification-rule';
import { PropertyRule } from './property-rule';
import { RuleContext } from '../types';
import { ExternalRuleBase } from './external-rule-base';
import { SeverityText } from '@useoptic/openapi-utilities';
export type Rule = SpecificationRule | OperationRule | RequestRule | ResponseRule | ResponseBodyRule | PropertyRule;
export type ExternalRule = ExternalRuleBase;
export type RuleNames<R extends Rule[]> = R[number]['name'];
export type RulesetConfig<Rules extends Rule[]> = {
    /**
     * A name for this ruleset
     */
    name: string;
    /**
     * A link to your API standards (will direct users here when rule fails)
     */
    docsLink?: string;
    /**
     * A function do determine whether to run the rule or not, based on context
     */
    matches?: (context: RuleContext) => boolean;
    /**
     * A list of Rules that will be checked against your OpenAPI changes
     */
    rules: Rules;
    /**
     * A list of rules from the ruleset to ignore, by name.
     */
    skipRules?: RuleNames<Rules>[];
    /**
     * A subset of rules from the ruleset to use exclusively, by name.
     */
    rulesOnly?: RuleNames<Rules>[];
    severity?: SeverityText;
};
export declare class Ruleset<Rules extends Rule[] = Rule[]> {
    type: 'ruleset';
    name: string;
    docsLink?: string;
    matches?: (context: RuleContext) => boolean;
    rules: Rule[];
    constructor(config: RulesetConfig<Rules>);
    static isInstance(v: any): v is Ruleset;
}
//# sourceMappingURL=ruleset.d.ts.map