"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeUnionTransition = exports.schemaIsUnion = exports.isInUnionProperty = void 0;
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
const openapi_utilities_1 = require("@useoptic/openapi-utilities");
const type_change_1 = require("./type-change");
const SEPARATOR = '/';
function isInUnionProperty(jsonPath) {
    const parts = json_pointer_helpers_1.jsonPointerHelpers.decode(jsonPath);
    return parts.some((p) => p === 'oneOf' || p === 'anyOf');
}
exports.isInUnionProperty = isInUnionProperty;
function schemaIsUnion(schema) {
    return !!(schema && !('$ref' in schema) && (schema.oneOf || schema.anyOf));
}
exports.schemaIsUnion = schemaIsUnion;
function getDeepestDiffLevel(reasons) {
    let max = 0;
    for (const { key } of reasons) {
        const keyLength = key === SEPARATOR ? 0 : key.split(SEPARATOR).length;
        max = Math.max(max, keyLength);
    }
    return max;
}
function compareReasons(a, b) {
    const aDiffLevel = getDeepestDiffLevel(a);
    const bDiffLevel = getDeepestDiffLevel(b);
    if (aDiffLevel === bDiffLevel) {
        return a.length - b.length;
    }
    else {
        return bDiffLevel - aDiffLevel;
    }
}
function traverseTypeArraySchemas(schema) {
    return Array.isArray(schema.type)
        ? schema.type.map((type) => {
            if (type === 'object') {
                const { items, ...newSchema } = { ...schema };
                newSchema.type = 'object';
                return createKeyMapFromSchema(newSchema);
            }
            else if (type === 'array') {
                const { properties, ...newSchema } = { ...schema };
                newSchema.type = 'array';
                return createKeyMapFromSchema(newSchema);
            }
            else {
                const { items, properties, ...newSchema } = { ...schema };
                newSchema.type = type;
                return createKeyMapFromSchema(newSchema);
            }
        })
        : [];
}
function areKeymapsResponseBreaking(aKeymaps, bKeymaps, keyName, keyword) {
    const responseResults = aKeymaps
        .map((aKeymap, i) => {
        const key = keyword
            ? keyName === '/'
                ? `${keyword}/${i}`
                : `${keyword}/${keyName}/${i}`
            : keyName;
        const diffResults = bKeymaps.map((bKeymap) => diffKeyMaps(aKeymap, bKeymap, key));
        const hasAnyValidTransition = diffResults.some((d) => !d.response);
        // There could be multiple reasons a type does not overlap - we select the one that we think is the most relevant,
        // in this case, this is a diff at the deepest level
        return hasAnyValidTransition
            ? null
            : diffResults.sort((a, b) => compareReasons(a.responseReasons, b.responseReasons))[0];
    })
        .filter((r) => r !== null);
    const isResponse = responseResults.length !== 0;
    return {
        isResponse,
        reasons: isResponse
            ? responseResults.sort((a, b) => compareReasons(a.responseReasons, b.responseReasons))[0].responseReasons
            : [],
    };
}
function areKeymapsRequestBreaking(aKeymaps, bKeymaps, keyName, keyword) {
    const requestResults = bKeymaps
        .map((bKeymap, i) => {
        const key = keyword
            ? keyName === '/'
                ? `${keyword}/${i}`
                : `${keyword}/${keyName}/${i}`
            : keyName;
        const diffResults = aKeymaps.map((aKeymap) => diffKeyMaps(aKeymap, bKeymap, key));
        const hasAnyValidTransition = diffResults.some((d) => !d.request);
        // There could be multiple reasons a type does not overlap - we select the one that we think is the most relevant,
        // in this case, this is a diff at the deepest level
        return hasAnyValidTransition
            ? null
            : diffResults.sort((a, b) => compareReasons(a.requestReasons, b.requestReasons))[0];
    })
        .filter((r) => r !== null);
    const isRequestBreaking = requestResults.length !== 0;
    return {
        isRequestBreaking,
        reasons: isRequestBreaking
            ? requestResults.sort((a, b) => compareReasons(a.requestReasons, b.requestReasons))[0].requestReasons
            : [],
    };
}
// Return an array of Maps that have different keys that they require; if there is a oneOf or anyOf
// create a key with multiple sets
function createKeyMapFromSchema(schema) {
    const keyMap = new Map();
    function traverseSchema(schema, path) {
        if (openapi_utilities_1.OAS3.isObjectType(schema.type)) {
            if (schema.properties) {
                for (const [key, value] of Object.entries(schema.properties)) {
                    const fullKey = path ? `${path}${SEPARATOR}${key}` : key;
                    const required = schema.required
                        ? schema.required.includes(key)
                        : false;
                    if (!value.type) {
                        if (value.oneOf)
                            keyMap.set(fullKey, {
                                required,
                                type: value.oneOf.map((s) => createKeyMapFromSchema(s)),
                                keyword: 'oneOf',
                            });
                        else if (value.anyOf)
                            keyMap.set(fullKey, {
                                required,
                                type: value.anyOf.map((s) => createKeyMapFromSchema(s)),
                                keyword: 'anyOf',
                            });
                    }
                    else {
                        const required = schema.required
                            ? schema.required.includes(key)
                            : false;
                        const node = Array.isArray(value.type)
                            ? {
                                required,
                                type: traverseTypeArraySchemas(value),
                                keyword: 'typeArray',
                            }
                            : {
                                required,
                                schema: value,
                                keyword: 'type',
                            };
                        keyMap.set(fullKey, node);
                        if (value.type === 'object' || value.type === 'array')
                            traverseSchema(value, fullKey);
                    }
                }
            }
        }
        if (openapi_utilities_1.OAS3.isArrayType(schema.type)) {
            schema = schema;
            if (schema.items) {
                const fullKey = `${path}.items`;
                if (!schema.items.type) {
                    if (schema.items.oneOf)
                        keyMap.set(fullKey, {
                            required: false,
                            type: schema.items.oneOf.map((s) => createKeyMapFromSchema(s)),
                            keyword: 'oneOf',
                        });
                    else if (schema.items.anyOf)
                        keyMap.set(fullKey, {
                            required: false,
                            type: schema.items.anyOf.map((s) => createKeyMapFromSchema(s)),
                            keyword: 'anyOf',
                        });
                }
                else {
                    const node = Array.isArray(schema.items.type)
                        ? {
                            required: false,
                            type: traverseTypeArraySchemas(schema.items),
                            keyword: 'typeArray',
                        }
                        : {
                            required: false,
                            schema: schema.items,
                            keyword: 'type',
                        };
                    keyMap.set(fullKey, node);
                    if (schema.items.type === 'object' || schema.items.type === 'array')
                        traverseSchema(schema.items, fullKey);
                }
            }
        }
    }
    if (schema.type) {
        const node = Array.isArray(schema.type)
            ? {
                required: false,
                type: traverseTypeArraySchemas(schema),
                keyword: 'typeArray',
            }
            : {
                required: false,
                schema,
                keyword: 'type',
            };
        keyMap.set('', node);
        traverseSchema(schema, '');
    }
    return keyMap;
}
function diffKeyMaps(aMap, bMap, parentKey) {
    const results = {
        request: false,
        requestReasons: [],
        response: false,
        responseReasons: [],
    };
    for (const [key, aValue] of aMap) {
        const bValue = bMap.get(key);
        const keyName = key === ''
            ? parentKey
            : parentKey === '/'
                ? `${parentKey}${key}`
                : `${parentKey}${SEPARATOR}${key}`;
        const prefix = keyName ? `${keyName}: ` : '';
        if (bValue) {
            if (aValue.keyword === 'type' && bValue.keyword === 'type') {
                const typeTransition = (0, type_change_1.computeTypeTransition)(aValue, bValue);
                if (typeTransition.request.enum) {
                    results.request = true;
                    results.requestReasons.push({
                        key: keyName,
                        reason: `${prefix}${typeTransition.request.enum}`,
                    });
                }
                if (typeTransition.request.requiredChange) {
                    results.request = true;
                    results.requestReasons.push({
                        key: keyName,
                        reason: `${prefix}${typeTransition.request.requiredChange}`,
                    });
                }
                if (typeTransition.request.typeChange) {
                    results.request = true;
                    results.requestReasons.push({
                        key: keyName,
                        reason: `${prefix}${typeTransition.request.typeChange}`,
                    });
                }
                if (typeTransition.response.enum) {
                    results.response = true;
                    results.responseReasons.push({
                        key: keyName,
                        reason: `${prefix}${typeTransition.response.enum}`,
                    });
                }
                if (typeTransition.response.requiredChange) {
                    results.response = true;
                    results.responseReasons.push({
                        key: keyName,
                        reason: `${prefix}${typeTransition.response.requiredChange}`,
                    });
                }
                if (typeTransition.response.typeChange) {
                    results.response = true;
                    results.responseReasons.push({
                        key: keyName,
                        reason: `${prefix}${typeTransition.response.typeChange}`,
                    });
                }
            }
            else {
                const aKeymaps = aValue.keyword === 'type'
                    ? [
                        createKeyMapFromSchema(aValue.schema),
                    ]
                    : aValue.type;
                const bKeymaps = bValue.keyword === 'type'
                    ? [
                        createKeyMapFromSchema(bValue.schema),
                    ]
                    : bValue.type;
                const responseKeyword = aValue.keyword === 'anyOf' || aValue.keyword === 'oneOf'
                    ? aValue.keyword
                    : null;
                const { isResponse, reasons: responseReasons } = areKeymapsResponseBreaking(aKeymaps, bKeymaps, keyName, responseKeyword);
                if (isResponse) {
                    results.response = true;
                    results.responseReasons.push({
                        key: keyName,
                        reason: `${prefix}${aValue.keyword}: ${responseReasons
                            .map((r) => r.reason)
                            .join(', ')}`,
                    });
                }
                const requestKeyword = bValue.keyword === 'anyOf' || bValue.keyword === 'oneOf'
                    ? bValue.keyword
                    : null;
                const { isRequestBreaking, reasons: requestReasons } = areKeymapsRequestBreaking(aKeymaps, bKeymaps, keyName, requestKeyword);
                if (isRequestBreaking) {
                    results.request = true;
                    results.requestReasons.push({
                        key: keyName,
                        reason: `${prefix}${aValue.keyword}: ${requestReasons
                            .map((r) => r.reason)
                            .join(', ')}`,
                    });
                }
            }
        }
        else if (aValue.required) {
            results.response = true;
            results.responseReasons.push({
                key: keyName,
                reason: `${prefix}required property was removed`,
            });
        }
    }
    for (const [key, bValue] of bMap) {
        const keyName = key === ''
            ? parentKey
            : parentKey === '/'
                ? `${parentKey}${key}`
                : `${parentKey}${SEPARATOR}${key}`;
        const prefix = keyName ? `${keyName}: ` : '';
        if (!aMap.has(key) && bValue.required) {
            results.requestReasons.push({
                key: keyName,
                reason: `${prefix}required property was added`,
            });
            results.request = true;
        }
    }
    return results;
}
function computeUnionTransition(before, after) {
    const results = {
        response: false,
        responseReasons: [],
        request: false,
        requestReasons: [],
    };
    const b = before;
    const a = after;
    const beforeMaps = b.oneOf
        ? b.oneOf.map((s) => createKeyMapFromSchema(s))
        : b.anyOf
            ? b.anyOf.map((s) => createKeyMapFromSchema(s))
            : Array.isArray(b.type)
                ? traverseTypeArraySchemas(b)
                : [createKeyMapFromSchema(b)];
    const beforeKeyword = b.oneOf ? 'oneOf' : b.anyOf ? 'anyOf' : null;
    const afterMaps = a.oneOf
        ? a.oneOf.map((s) => createKeyMapFromSchema(s))
        : a.anyOf
            ? a.anyOf.map((s) => createKeyMapFromSchema(s))
            : Array.isArray(a.type)
                ? traverseTypeArraySchemas(a)
                : [createKeyMapFromSchema(a)];
    const afterKeyword = a.oneOf ? 'oneOf' : a.anyOf ? 'anyOf' : null;
    const { isResponse, reasons: responseReasons } = areKeymapsResponseBreaking(beforeMaps, afterMaps, '/', beforeKeyword);
    if (isResponse) {
        results.response = true;
        results.responseReasons.push({
            key: 'root',
            reason: `${responseReasons.map((r) => r.reason).join(', ')}`,
        });
    }
    const { isRequestBreaking, reasons: expandedReasons } = areKeymapsRequestBreaking(beforeMaps, afterMaps, '/', afterKeyword);
    if (isRequestBreaking) {
        results.request = true;
        results.requestReasons.push({
            key: 'root',
            reason: `${expandedReasons.map((r) => r.reason).join(', ')}`,
        });
    }
    return results;
}
exports.computeUnionTransition = computeUnionTransition;
//# sourceMappingURL=unions.js.map