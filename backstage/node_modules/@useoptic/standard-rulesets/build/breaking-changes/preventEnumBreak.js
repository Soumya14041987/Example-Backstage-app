"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.preventPropertyEnumBreak = exports.preventHeaderParameterEnumBreak = exports.preventPathParameterEnumBreak = exports.preventCookieParameterEnumBreak = exports.preventQueryParameterEnumBreak = void 0;
const rulesets_base_1 = require("@useoptic/rulesets-base");
const getOperationAssertionsParameter_1 = require("./helpers/getOperationAssertionsParameter");
const unions_1 = require("./helpers/unions");
const type_change_1 = require("./helpers/type-change");
const InfiniteSet = Symbol('infinite enum set');
const isSchemaWithEnum = (obj) => {
    if (!obj)
        return false;
    return ('enum' in obj && Array.isArray(obj.enum)) || 'const' in obj;
};
const getEnumFromSchema = (schemaWithEnum) => {
    if ('enum' in schemaWithEnum && Array.isArray(schemaWithEnum.enum)) {
        return schemaWithEnum.enum;
    }
    if ('const' in schemaWithEnum) {
        return [schemaWithEnum.const];
    }
    return InfiniteSet;
};
const getRuleName = (parameterIn) => `prevent ${parameterIn} parameters enum breaking changes`;
const getPreventParameterEnumBreak = (parameterIn) => new rulesets_base_1.OperationRule({
    name: getRuleName(parameterIn),
    rule: (operationAssertions, _ruleContext) => {
        const parameter = (0, getOperationAssertionsParameter_1.getOperationAssertionsParameter)(operationAssertions, parameterIn);
        parameter.changed((before, after) => {
            if (!(isSchemaWithEnum(before.value?.schema) ||
                isSchemaWithEnum(after.value?.schema))) {
                return;
            }
            const beforeEnum = getEnumFromSchema(before.value?.schema);
            const afterEnum = getEnumFromSchema(after.value?.schema);
            if (beforeEnum === InfiniteSet || afterEnum === InfiniteSet) {
                if (beforeEnum === InfiniteSet && afterEnum !== InfiniteSet) {
                    throw new rulesets_base_1.RuleError({
                        message: `cannot add an enum to restrict possible values for ${parameterIn} parameter ${after.value.name}. This is a breaking change.`,
                    });
                }
                else {
                    return;
                }
            }
            const enumDiff = (isSchemaWithEnum(before.value?.schema) ||
                isSchemaWithEnum(after.value?.schema)) &&
                (0, type_change_1.diffSets)(new Set(beforeEnum), new Set(afterEnum));
            if (enumDiff && enumDiff.beforeSetDiff.length) {
                throw new rulesets_base_1.RuleError({
                    message: `cannot remove enum option${enumDiff.beforeSetDiff.length > 1 ? 's' : ''} '${enumDiff.beforeSetDiff.join(', ')}' from ${parameterIn} parameter '${after.value.name}'. This is a breaking change.`,
                });
            }
        });
    },
});
const preventQueryParameterEnumBreak = () => getPreventParameterEnumBreak('query');
exports.preventQueryParameterEnumBreak = preventQueryParameterEnumBreak;
const preventCookieParameterEnumBreak = () => getPreventParameterEnumBreak('cookie');
exports.preventCookieParameterEnumBreak = preventCookieParameterEnumBreak;
const preventPathParameterEnumBreak = () => getPreventParameterEnumBreak('path');
exports.preventPathParameterEnumBreak = preventPathParameterEnumBreak;
const preventHeaderParameterEnumBreak = () => getPreventParameterEnumBreak('header');
exports.preventHeaderParameterEnumBreak = preventHeaderParameterEnumBreak;
const preventPropertyEnumBreak = () => {
    return new rulesets_base_1.PropertyRule({
        name: 'request and response property enums',
        matches: (property, context) => isSchemaWithEnum(property.raw),
        rule: (property, context) => {
            property.changed((before, after) => {
                if ((0, unions_1.isInUnionProperty)(before.location.jsonPath) ||
                    (0, unions_1.schemaIsUnion)(before.value.flatSchema) ||
                    (0, unions_1.isInUnionProperty)(after.location.jsonPath) ||
                    (0, unions_1.schemaIsUnion)(after.value.flatSchema)) {
                    return;
                }
                if (!(isSchemaWithEnum(before.raw) || isSchemaWithEnum(after.raw))) {
                    return;
                }
                const inRequest = 'inRequest' in after.location.conceptualLocation;
                const beforeEnum = getEnumFromSchema(before.raw);
                const afterEnum = getEnumFromSchema(after.raw);
                if (beforeEnum === InfiniteSet || afterEnum === InfiniteSet) {
                    if (inRequest &&
                        beforeEnum === InfiniteSet &&
                        afterEnum !== InfiniteSet) {
                        throw new rulesets_base_1.RuleError({
                            message: `cannot add enum or const to request property ${after.value.key}. This is a breaking change.`,
                        });
                    }
                    else if (!inRequest &&
                        beforeEnum !== InfiniteSet &&
                        afterEnum === InfiniteSet) {
                        throw new rulesets_base_1.RuleError({
                            message: `cannot remove enum or const from response property ${after.value.key}. This is a breaking change.`,
                        });
                    }
                    return;
                }
                let beforeSet = new Set(beforeEnum);
                let afterSet = new Set(afterEnum);
                const results = (0, type_change_1.diffSets)(beforeSet, afterSet);
                if (inRequest && results.beforeSetDiff.length) {
                    throw new rulesets_base_1.RuleError({
                        message: `cannot remove enum option${results.beforeSetDiff.length > 1 ? 's' : ''} '${results.beforeSetDiff.join(', ')}' from '${after.value.key}' property. This is a breaking change.`,
                    });
                }
                else if (!inRequest && results.afterSetDiff.length) {
                    throw new rulesets_base_1.RuleError({
                        message: `cannot add enum option${results.afterSetDiff.length > 1 ? 's' : ''} '${results.afterSetDiff.join(', ')}' from '${after.value.key}' property. This is a breaking change.`,
                    });
                }
            });
        },
    });
};
exports.preventPropertyEnumBreak = preventPropertyEnumBreak;
//# sourceMappingURL=preventEnumBreak.js.map