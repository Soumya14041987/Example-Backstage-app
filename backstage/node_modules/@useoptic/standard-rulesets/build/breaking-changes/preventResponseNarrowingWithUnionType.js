"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.preventResponseNarrowingInUnionTypes = void 0;
const rulesets_base_1 = require("@useoptic/rulesets-base");
const unions_1 = require("./helpers/unions");
const preventResponseNarrowingInUnionTypes = () => new rulesets_base_1.ResponseBodyRule({
    name: 'prevent narrowing in response union types',
    rule: (responseBodyAssertions) => {
        responseBodyAssertions.body.changed((before, after) => {
            const beforeSchema = before.raw.schema;
            const afterSchema = after.raw.schema;
            if (!beforeSchema || !afterSchema)
                return;
            if ((0, unions_1.schemaIsUnion)(beforeSchema) || (0, unions_1.schemaIsUnion)(afterSchema)) {
                const results = (0, unions_1.computeUnionTransition)(beforeSchema, afterSchema);
                if (results.response) {
                    const keyword = 'oneOf' in beforeSchema || 'oneOf' in afterSchema
                        ? 'oneOf'
                        : 'anyOf';
                    const prefix = (0, unions_1.schemaIsUnion)(beforeSchema) && (0, unions_1.schemaIsUnion)(afterSchema)
                        ? `response body ${keyword} schema`
                        : (0, unions_1.schemaIsUnion)(afterSchema)
                            ? `response body changed to ${keyword}`
                            : `response body changed from ${keyword}`;
                    throw new rulesets_base_1.RuleError({
                        message: `${prefix} did not overlap with the previous schema. ${results.responseReasons
                            .map((r) => r.reason)
                            .join(', ')}`,
                    });
                }
            }
        });
        responseBodyAssertions.property.changed((before, after) => {
            const beforeSchema = before.raw;
            const afterSchema = after.raw;
            if (!beforeSchema || !afterSchema)
                return;
            if ((0, unions_1.schemaIsUnion)(beforeSchema) || (0, unions_1.schemaIsUnion)(afterSchema)) {
                const results = (0, unions_1.computeUnionTransition)(beforeSchema, afterSchema);
                if (results.response) {
                    const keyword = 'oneOf' in beforeSchema || 'oneOf' in afterSchema
                        ? 'oneOf'
                        : 'anyOf';
                    const prefix = (0, unions_1.schemaIsUnion)(beforeSchema) && (0, unions_1.schemaIsUnion)(afterSchema)
                        ? `response property ${keyword} schema`
                        : (0, unions_1.schemaIsUnion)(afterSchema)
                            ? `response property changed to ${keyword}`
                            : `response property changed from ${keyword}`;
                    throw new rulesets_base_1.RuleError({
                        message: `${prefix} did not overlap with the previous schema. ${results.responseReasons
                            .map((r) => r.reason)
                            .join(', ')}`,
                    });
                }
            }
        });
    },
});
exports.preventResponseNarrowingInUnionTypes = preventResponseNarrowingInUnionTypes;
//# sourceMappingURL=preventResponseNarrowingWithUnionType.js.map