"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requirePropertyExamplesMatchSchema = exports.requireValidParameterExamples = exports.requireValidResponseExamples = exports.requireValidRequestExamples = exports.validateSchema = exports.defaultAjv = void 0;
const rulesets_base_1 = require("@useoptic/rulesets-base");
const ajv_draft_04_1 = __importDefault(require("ajv-draft-04"));
const _2019_1 = __importDefault(require("ajv/dist/2019"));
const ajv_formats_1 = __importDefault(require("ajv-formats"));
const openapi_utilities_1 = require("@useoptic/openapi-utilities");
function defaultAjv(specVersion) {
    const validator = specVersion === '3.1.x'
        ? new _2019_1.default({ strict: false, unevaluated: true })
        : new ajv_draft_04_1.default({ strict: false, unevaluated: true });
    (0, ajv_formats_1.default)(validator);
    // override pattern keyword when invalid regex
    validator.removeKeyword('pattern');
    validator.addKeyword({
        keyword: 'pattern',
        type: 'string',
        schemaType: 'string',
        error: {
            message: (cxt) => {
                return `pattern not matched ${cxt.schema}`;
            },
        },
        compile: (pattern) => {
            let regex;
            try {
                regex = new RegExp(pattern);
            }
            catch (e) {
                return (data) => true;
            }
            return (data) => regex.test(data);
        },
    });
    return validator;
}
exports.defaultAjv = defaultAjv;
function validateSchema(schema, example, ajv) {
    const schemaCopy = JSON.parse(JSON.stringify(schema));
    prepareSchemaForValidation(schemaCopy);
    const schemaCompiled = ajv.compile(schemaCopy);
    const result = schemaCompiled(example);
    if (!result) {
        schemaCompiled.errors?.forEach((error) => {
            if (error.keyword === 'additionalProperties') {
                error.message = `must NOT have additional property '${error.params.additionalProperty}'`;
            }
            if (error.keyword === 'unevaluatedProperties') {
                error.message = `must NOT have additional property '${error.params.unevaluatedProperty}'`;
            }
        });
        const error = `  - ${ajv.errorsText(schemaCompiled.errors, {
            separator: '\n- ',
            dataVar: 'example ',
        })}`;
        return { pass: false, error };
    }
    return { pass: true };
}
exports.validateSchema = validateSchema;
function isRef(obj) {
    return typeof obj === 'object' && obj !== null && '$ref' in obj;
}
// Sets all strict validation (no additional properties) and removes $refs which could be left behind in circular references
function prepareSchemaForValidation(schema, opts) {
    const inAllOf = opts?.inAllOf ?? false;
    if (!schema) {
        return;
    }
    if (isRef(schema)) {
        // @ts-ignore
        delete schema.$ref;
        return;
    }
    // Delete example and examples from schema, not necessary for using the schema and can cause false positives with AJV
    // See https://github.com/opticdev/optic/issues/2631 for details
    if ('example' in schema)
        delete schema.example;
    if ('examples' in schema)
        delete schema.examples;
    if (!inAllOf) {
        if (openapi_utilities_1.OAS3.isObjectType(schema.type) && !schema.additionalProperties) {
            schema.additionalProperties = false;
        }
        if (schema.allOf && !schema.unevaluatedProperties) {
            schema.unevaluatedProperties = false;
        }
    }
    // Iterate through allOfs, oneOfs, anyOf
    const keys = ['allOf', 'oneOf', 'anyOf'];
    for (const key of keys) {
        const polymorphicSchema = schema[key];
        if (Array.isArray(polymorphicSchema)) {
            polymorphicSchema.forEach((s) => prepareSchemaForValidation(s, { inAllOf: key === 'allOf' }));
        }
        else if (isRef(polymorphicSchema)) {
            // @ts-ignore
            delete polymorphicSchema.$ref;
        }
    }
    if (isRef(schema.not)) {
        schema.not = {};
    }
    else if (isRef(schema.additionalProperties)) {
        schema.additionalProperties = {};
    }
    // Continue iteration
    if ('items' in schema) {
        prepareSchemaForValidation(schema.items);
    }
    else if (schema.properties) {
        Object.values(schema.properties).forEach((s) => prepareSchemaForValidation(s));
    }
}
const requireValidRequestExamples = (ajv) => new rulesets_base_1.RequestRule({
    name: 'request body examples must match schema',
    rule: (requestAssertions) => {
        requestAssertions.body.requirement((value) => {
            const { schema, examples, example } = value.raw;
            if (example) {
                const result = validateSchema(schema || {}, example, ajv);
                if (!result.pass) {
                    throw new rulesets_base_1.RuleError({
                        message: `the example does not match the schema. \n${result.error} `,
                    });
                }
            }
            if (examples) {
                Object.entries(examples).forEach((example) => {
                    const [exampleName, exampleValue] = example;
                    const result = validateSchema(schema || {}, exampleValue.value, ajv);
                    if (!result.pass) {
                        throw new rulesets_base_1.RuleError({
                            message: `the example named '${exampleName}' does not match the schema. \n${result.error} `,
                        });
                    }
                });
            }
        });
    },
});
exports.requireValidRequestExamples = requireValidRequestExamples;
const requireValidResponseExamples = (ajv) => new rulesets_base_1.ResponseRule({
    name: 'response body examples must match schemas',
    rule: (responseAssertions) => {
        responseAssertions.requirement((value) => {
            value.bodies.forEach((body) => {
                if (body.raw.example) {
                    const result = validateSchema(body.raw.schema || {}, body.raw.example, ajv);
                    if (!result.pass) {
                        throw new rulesets_base_1.RuleError({
                            message: `the example does not match the schema. \n${result.error} `,
                        });
                    }
                }
                if (body.raw.examples) {
                    Object.entries(body.raw.examples).forEach((example) => {
                        const [exampleName, exampleValue] = example;
                        const result = validateSchema(body.raw.schema || {}, exampleValue.value, ajv);
                        if (!result.pass) {
                            throw new rulesets_base_1.RuleError({
                                message: `the example named '${exampleName}' does not match the schema. \n${result.error} `,
                            });
                        }
                    });
                }
            });
        });
    },
});
exports.requireValidResponseExamples = requireValidResponseExamples;
const requireValidParameterExamples = (ajv) => new rulesets_base_1.OperationRule({
    name: 'parameter examples must match schemas',
    rule: (operation) => {
        operation.headerParameter.requirement((header) => {
            if (header.raw.example) {
                const result = validateSchema(header.raw.schema || {}, header.raw.example, ajv);
                if (!result.pass) {
                    throw new rulesets_base_1.RuleError({
                        message: `header '${header.value.name}' example does not match the schema. \n${result.error} `,
                    });
                }
            }
            if (header.raw.schema && 'example' in header.raw.schema) {
                const result = validateSchema(header.raw.schema || {}, header.raw.schema.example, ajv);
                if (!result.pass) {
                    throw new rulesets_base_1.RuleError({
                        message: `header '${header.value.name}' example does not match the schema. \n${result.error} `,
                    });
                }
            }
        });
        operation.queryParameter.requirement((query) => {
            if (query.raw.example) {
                const result = validateSchema(query.raw.schema || {}, query.raw.example, ajv);
                if (!result.pass) {
                    throw new rulesets_base_1.RuleError({
                        message: `query parameter '${query.value.name}' example does not match the schema. \n${result.error} `,
                    });
                }
            }
            if (query.raw.schema && 'example' in query.raw.schema) {
                const result = validateSchema(query.raw.schema || {}, query.raw.schema.example, ajv);
                if (!result.pass) {
                    throw new rulesets_base_1.RuleError({
                        message: `query parameter '${query.value.name}' example does not match the schema. \n${result.error} `,
                    });
                }
            }
        });
        operation.cookieParameter.requirement((cookie) => {
            if (cookie.raw.example) {
                const result = validateSchema(cookie.raw.schema || {}, cookie.raw.example, ajv);
                if (!result.pass) {
                    throw new rulesets_base_1.RuleError({
                        message: `cookie '${cookie.value.name}' example does not match the schema. \n${result.error} `,
                    });
                }
            }
            if (cookie.raw.schema && 'example' in cookie.raw.schema) {
                const result = validateSchema(cookie.raw.schema || {}, cookie.raw.schema.example, ajv);
                if (!result.pass) {
                    throw new rulesets_base_1.RuleError({
                        message: `cookie '${cookie.value.name}' example does not match the schema. \n${result.error} `,
                    });
                }
            }
        });
    },
});
exports.requireValidParameterExamples = requireValidParameterExamples;
const requirePropertyExamplesMatchSchema = (ajv) => new rulesets_base_1.PropertyRule({
    name: 'require property examples match schemas',
    rule: (property) => {
        property.requirement((property) => {
            if (property.raw.example) {
                const result = validateSchema(property.raw, property.raw.example, ajv);
                if (!result.pass) {
                    throw new rulesets_base_1.RuleError({
                        message: `'${property.value.key}' example does not match the schema. \n${result.error} `,
                    });
                }
            }
        });
    },
});
exports.requirePropertyExamplesMatchSchema = requirePropertyExamplesMatchSchema;
//# sourceMappingURL=requireValidExamples.js.map