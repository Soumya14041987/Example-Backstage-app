"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LintGpt = void 0;
const openapi_utilities_1 = require("@useoptic/openapi-utilities");
const ajv_1 = __importDefault(require("ajv"));
const constants_1 = require("./constants");
const rules_helper_1 = require("./rules-helper");
const external_rule_base_1 = require("@useoptic/rulesets-base/build/rules/external-rule-base");
const json_pointer_helpers_1 = require("@useoptic/json-pointer-helpers");
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
const prepare_openapi_1 = require("./prepare-openapi");
const ajv = new ajv_1.default();
const configSchema = {
    type: 'object',
    patternProperties: {
        '.+': {
            type: 'object',
            required: ['rules'],
            properties: {
                severity: {
                    type: 'string',
                    enum: openapi_utilities_1.SeverityTextOptions,
                },
                required_on: {
                    type: 'string',
                    enum: constants_1.appliesWhen,
                },
                rules: {
                    type: 'array',
                    items: {
                        type: 'string',
                    },
                },
            },
        },
    },
};
const validateConfigSchema = ajv.compile(configSchema);
class LintGpt extends external_rule_base_1.ExternalRuleBase {
    static async fromOpticConfig(config) {
        return 'Error: LintGPT is no longer supported';
    }
    constructor(config, requirementRules, addedRules, lintgptClient) {
        super();
        this.config = config;
        this.requirementRules = requirementRules;
        this.addedRules = addedRules;
        this.lintgptClient = lintgptClient;
    }
    async runRulesV2(inputs) {
        const operationsToRun = [];
        const responsesToRun = [];
        const propertiesToRun = [];
        const lintgptRulesHelper = new rules_helper_1.LintgptRulesHelper();
        inputs.groupedFacts.endpoints.forEach((endpoint) => {
            const { path, method } = endpoint;
            const location = `${method} ${path}`;
            const didChange = endpoint.change?.changeType === openapi_utilities_1.ChangeType.Changed;
            const wasRemoved = endpoint.change?.changeType === openapi_utilities_1.ChangeType.Removed;
            const jsonPath = (endpoint.after?.location.jsonPath ||
                endpoint.before?.location.jsonPath);
            const inAfterSpec = endpoint.after !== null;
            if (inAfterSpec) {
                operationsToRun.push({
                    locationContext: location,
                    jsonPath,
                    value: wasRemoved
                        ? undefined
                        : (0, prepare_openapi_1.prepareOperation)(json_pointer_helpers_1.jsonPointerHelpers.get(inputs.toSpec, jsonPath)),
                    before: didChange
                        ? (0, prepare_openapi_1.prepareOperation)(json_pointer_helpers_1.jsonPointerHelpers.get(inputs.fromSpec, endpoint.before?.location.jsonPath))
                        : undefined,
                });
            }
            endpoint.responses.forEach((response) => {
                const location = `${method} ${path} ${response.statusCode} response`;
                const didChange = response.change?.changeType === openapi_utilities_1.ChangeType.Changed;
                const wasRemoved = response.change?.changeType === openapi_utilities_1.ChangeType.Removed;
                response.bodies.forEach((body) => {
                    body.fields.forEach((property) => {
                        if (property.after) {
                            const propertyLocation = `Name: \`${property.after.value.key}\`. Required? \`${property.after.value.required}\``;
                            const didChange = property.change?.changeType === openapi_utilities_1.ChangeType.Changed;
                            const wasRemoved = property.change?.changeType === openapi_utilities_1.ChangeType.Removed;
                            propertiesToRun.push({
                                locationContext: propertyLocation,
                                jsonPath: property.after.location.jsonPath,
                                value: wasRemoved
                                    ? undefined
                                    : json_pointer_helpers_1.jsonPointerHelpers.get(inputs.toSpec, property.after.location.jsonPath),
                                before: didChange
                                    ? json_pointer_helpers_1.jsonPointerHelpers.get(inputs.fromSpec, property.before.location.jsonPath)
                                    : undefined,
                            });
                        }
                    });
                });
                responsesToRun.push({
                    locationContext: location,
                    jsonPath,
                    value: wasRemoved
                        ? undefined
                        : (0, prepare_openapi_1.prepareResponse)(json_pointer_helpers_1.jsonPointerHelpers.get(inputs.toSpec, jsonPath)),
                    before: didChange
                        ? (0, prepare_openapi_1.prepareResponse)(json_pointer_helpers_1.jsonPointerHelpers.get(inputs.fromSpec, response.before?.location.jsonPath))
                        : undefined,
                });
            });
        });
        ///// run the rules
        const operationsRules = this.requirementRules.filter((i) => i.entity === 'OPERATION');
        const responsesRules = this.requirementRules.filter((i) => i.entity === 'RESPONSE');
        const propertyRules = this.requirementRules.filter((i) => i.entity === 'PROPERTY');
        const evals = new Map();
        for (const rule of operationsRules) {
            for (const operation of operationsToRun) {
                if (rule.changed && !operation.before)
                    continue;
                const rule_checksum = (0, rules_helper_1.computeRuleChecksum)(rule.rule);
                const eval_data = {
                    rule_checksum,
                    location_context: operation.locationContext,
                    node: (0, json_stable_stringify_1.default)(operation.value ?? ''),
                    node_before: (0, json_stable_stringify_1.default)(operation.before ?? ''),
                };
                const node_checksum = (0, rules_helper_1.computeNodeChecksum)(eval_data);
                const key = `${rule_checksum}${node_checksum}`;
                evals.set(key, { eval_data, jsonPath: operation.jsonPath, rule });
            }
        }
        for (const rule of responsesRules) {
            for (const response of responsesToRun) {
                if (rule.changed && !response.before)
                    continue;
                const rule_checksum = (0, rules_helper_1.computeRuleChecksum)(rule.rule);
                const eval_data = {
                    rule_checksum,
                    location_context: response.locationContext,
                    node: (0, json_stable_stringify_1.default)(response.value ?? ''),
                    node_before: (0, json_stable_stringify_1.default)(response.before ?? ''),
                };
                const node_checksum = (0, rules_helper_1.computeNodeChecksum)(eval_data);
                const key = `${rule_checksum}${node_checksum}`;
                evals.set(key, { eval_data, jsonPath: response.jsonPath, rule });
            }
        }
        for (const rule of propertyRules) {
            for (const property of propertiesToRun) {
                if (rule.changed && !property.before)
                    continue;
                const rule_checksum = (0, rules_helper_1.computeRuleChecksum)(rule.rule);
                const eval_data = {
                    rule_checksum,
                    location_context: property.locationContext,
                    node: (0, json_stable_stringify_1.default)(property.value ?? ''),
                    node_before: (0, json_stable_stringify_1.default)(property.before ?? ''),
                };
                const node_checksum = (0, rules_helper_1.computeNodeChecksum)(eval_data);
                const key = `${rule_checksum}${node_checksum}`;
                evals.set(key, { eval_data, jsonPath: property.jsonPath, rule });
            }
        }
        const eval_results = await lintgptRulesHelper.getRuleEvals([...evals.values()].map((v) => v.eval_data));
        const results = [];
        const successfulEvals = [...eval_results.values()]
            .map((v) => v.rule_eval)
            .filter((v) => v?.status === 'success');
        if (successfulEvals.length < evals.size) {
            console.warn(`${evals.size - successfulEvals.length} LintGPT rule evaluations failed to run.`);
            console.warn('');
        }
        for (const result of successfulEvals) {
            if (result.skipped)
                continue;
            const key = `${result.rule_checksum}${result.node_checksum}`;
            const data = evals.get(key);
            if (!data)
                continue;
            const opticResult = {
                passed: !!result.passed,
                where: data.eval_data.location_context,
                name: data.rule.slug,
                severity: data.rule.severity === 'ERROR' ? openapi_utilities_1.Severity.Error : openapi_utilities_1.Severity.Warn,
                location: {
                    jsonPath: data.jsonPath,
                    spec: 'after',
                },
                error: result.eval_error ?? undefined,
            };
            results.push(opticResult);
        }
        return results;
    }
}
exports.LintGpt = LintGpt;
//# sourceMappingURL=index.js.map