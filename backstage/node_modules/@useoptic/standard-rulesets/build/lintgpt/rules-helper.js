"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeNodeChecksum = exports.computeRuleChecksum = exports.LintgptRulesHelper = void 0;
const crypto_1 = __importDefault(require("crypto"));
const ora_1 = __importDefault(require("ora"));
class LintgptRulesHelper {
    constructor() {
        this.getPrepSpinnerText = ({ total, evaluated, }) => `LintGPT: ${evaluated}/${total} rules ready`;
    }
    async getRulePreps(rules) {
        const preparedRulesMap = new Map();
        let spinner = (0, ora_1.default)({
            text: this.getPrepSpinnerText({
                total: rules.length,
                evaluated: 0,
            }),
        });
        spinner.start();
        spinner.fail(`LintGPT: no longer supported`);
    }
    async getRuleEvals(eval_requests) {
        return new Map();
    }
}
exports.LintgptRulesHelper = LintgptRulesHelper;
const computeRuleChecksum = (rule) => crypto_1.default
    .createHash('sha256')
    .update(rule ?? '')
    .digest('base64')
    .toString();
exports.computeRuleChecksum = computeRuleChecksum;
const computeNodeChecksum = ({ node, node_before, location_context, }) => crypto_1.default
    .createHash('sha256')
    .update(location_context)
    .update(node ?? '')
    .update(node_before ?? '')
    .digest('base64')
    .toString();
exports.computeNodeChecksum = computeNodeChecksum;
const getEvalKey = (rule_checksum, node_checksum) => `${rule_checksum}${node_checksum}`;
//# sourceMappingURL=rules-helper.js.map