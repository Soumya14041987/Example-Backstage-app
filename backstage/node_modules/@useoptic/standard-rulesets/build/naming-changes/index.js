"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NamingChangesRuleset = void 0;
const rulesets_base_1 = require("@useoptic/rulesets-base");
const constants_1 = require("./constants");
const propertyNames_1 = require("./propertyNames");
const queryParameters_1 = require("./queryParameters");
const requestHeaders_1 = require("./requestHeaders");
const responseHeader_1 = require("./responseHeader");
const cookieParameters_1 = require("./cookieParameters");
const pathComponents_1 = require("./pathComponents");
const ajv_1 = __importDefault(require("ajv"));
const openapi_utilities_1 = require("@useoptic/openapi-utilities");
const operationIds_1 = require("./operationIds");
const utils_1 = require("../utils");
const ajv = new ajv_1.default();
const configSchema = {
    type: 'object',
    properties: {
        required_on: {
            type: 'string',
            enum: constants_1.appliesWhen,
        },
        exclude_operations_with_extension: {
            oneOf: [{ type: 'string' }, { type: 'array', items: { type: 'string' } }],
        },
        docs_link: {
            type: 'string',
        },
        severity: {
            type: 'string',
            enum: openapi_utilities_1.SeverityTextOptions,
        },
        // TODO deprecate applies in naming config
        applies: {
            type: 'string',
            enum: constants_1.appliesWhen,
        },
        requestHeaders: {
            type: 'string',
            enum: constants_1.casing,
        },
        queryParameters: {
            type: 'string',
            enum: constants_1.casing,
        },
        responseHeaders: {
            type: 'string',
            enum: constants_1.casing,
        },
        cookieParameters: {
            type: 'string',
            enum: constants_1.casing,
        },
        pathComponents: {
            type: 'string',
            enum: constants_1.casing,
        },
        operationId: {
            type: 'string',
            enum: constants_1.casing,
        },
        properties: {
            type: 'string',
            enum: constants_1.casing,
        },
    },
};
const validateConfigSchema = ajv.compile(configSchema);
class NamingChangesRuleset extends rulesets_base_1.Ruleset {
    static async fromOpticConfig(config) {
        const result = validateConfigSchema(config);
        if (!result) {
            return `- ${ajv.errorsText(validateConfigSchema.errors, {
                separator: '\n- ',
                dataVar: 'ruleset/naming',
            })}`;
        }
        const required_on = config.required_on || config.applies || 'always';
        if ('applies' in config) {
            console.warn('`applies` is deprecated in the naming changes config. Use `required_on` instead.');
        }
        const validatedConfig = config;
        const namingConfig = {};
        for (const key of [
            'requestHeaders',
            'queryParameters',
            'responseHeaders',
            'cookieParameters',
            'pathComponents',
            'properties',
            'operationId',
        ]) {
            if (validatedConfig[key]) {
                namingConfig[key] = validatedConfig[key];
            }
        }
        let matches = undefined;
        if (validatedConfig.exclude_operations_with_extension !== undefined) {
            matches = (0, utils_1.excludeOperationWithExtensionMatches)(validatedConfig.exclude_operations_with_extension);
        }
        return new NamingChangesRuleset({
            required_on: required_on,
            options: namingConfig,
            docsLink: validatedConfig.docs_link,
            matches,
            severity: validatedConfig.severity,
        });
    }
    constructor(config) {
        if (!config) {
            // TODO silence this from sentry
            throw new Error('Expected config object in NamingChangesRuleset');
        }
        const { required_on, matches, docsLink, options = {} } = config;
        if (!required_on || !constants_1.appliesWhen.includes(required_on)) {
            // TODO silence this from sentry
            throw new Error(`Expected config.applies in NamingChangesRuleset to be specified and be one of ${constants_1.appliesWhen.join(', ')}`);
        }
        for (const [key, value] of Object.entries(options)) {
            if (!constants_1.casing.includes(value)) {
                // TODO silence this from sentry
                throw new Error(`Expected casing option to be one of ${constants_1.casing.join(', ')}, received ${value} for ${key}`);
            }
        }
        // TODO create naming rules using options
        const namingChangeRules = [];
        if (options.properties) {
            namingChangeRules.push(...(0, propertyNames_1.createPropertyNamingChecks)(required_on, options.properties));
        }
        if (options.queryParameters) {
            namingChangeRules.push((0, queryParameters_1.createQueryParameterChecks)(required_on, options.queryParameters));
        }
        if (options.requestHeaders) {
            namingChangeRules.push((0, requestHeaders_1.createRequestHeaderParameterChecks)(required_on, options.requestHeaders));
        }
        if (options.cookieParameters) {
            namingChangeRules.push((0, cookieParameters_1.createCookieParameterChecks)(required_on, options.cookieParameters));
        }
        if (options.operationId) {
            namingChangeRules.push((0, operationIds_1.createOperationIdRule)(required_on, options.operationId));
        }
        if (options.responseHeaders) {
            namingChangeRules.push((0, responseHeader_1.createResponseHeaderParameterChecks)(required_on, options.responseHeaders));
        }
        if (options.pathComponents) {
            namingChangeRules.push((0, pathComponents_1.createPathComponentChecks)(required_on, options.pathComponents));
        }
        super({
            name: 'Naming changes ruleset',
            docsLink,
            matches,
            rules: namingChangeRules,
            severity: config.severity,
        });
    }
}
exports.NamingChangesRuleset = NamingChangesRuleset;
//# sourceMappingURL=index.js.map