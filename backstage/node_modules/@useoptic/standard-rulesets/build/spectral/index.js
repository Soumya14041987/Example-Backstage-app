"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpectralRulesets = void 0;
const rulesets_base_1 = require("@useoptic/rulesets-base");
const ajv_1 = __importDefault(require("ajv"));
const external_rule_base_1 = require("@useoptic/rulesets-base/build/rules/external-rule-base");
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const promises_1 = __importDefault(require("node:fs/promises"));
const utils_1 = require("../utils");
const ajv = new ajv_1.default();
const configSchema = {
    type: 'object',
    properties: {
        exclude_operations_with_extension: {
            oneOf: [{ type: 'string' }, { type: 'array', items: { type: 'string' } }],
        },
        added: {
            type: 'array',
            items: {
                type: 'string',
                description: 'URI of spectral ruleset file (file or URL)',
            },
        },
        always: {
            type: 'array',
            items: {
                type: 'string',
                description: 'URI of spectral ruleset file (file or URL)',
            },
        },
        changed: {
            type: 'array',
            items: {
                type: 'string',
                description: 'URI of spectral ruleset file (file or URL)',
            },
        },
        addedOrChanged: {
            type: 'array',
            items: {
                type: 'string',
                description: 'URI of spectral ruleset file (file or URL)',
            },
        },
    },
};
const validateConfigSchema = ajv.compile(configSchema);
class SpectralRulesets extends external_rule_base_1.ExternalRuleBase {
    constructor(options) {
        super();
        this.options = {
            always: options.always ?? [],
            added: options.added ?? [],
            changed: options.changed ?? [],
            addedOrChanged: options.addedOrChanged ?? [],
            matches: options.matches,
        };
    }
    async runRules(inputs) {
        const absolutePathTmpSpec = path_1.default.join(os_1.default.tmpdir(), `optic-next-spec-${Math.floor(Math.random() * 100000)}.json`);
        // write one tmp spec for all the spectral runs to use
        await promises_1.default.writeFile(absolutePathTmpSpec, JSON.stringify(inputs.nextJsonLike));
        const added = this.options.added.map((ruleInput) => {
            return new rulesets_base_1.SpectralRule({
                name: 'Spectral Rules applied to additions to the specification: ' +
                    ruleInput,
                flatSpecFile: absolutePathTmpSpec,
                applies: 'added',
                rulesetPointer: ruleInput,
                matches: this.options.matches,
            });
        });
        const changed = this.options.changed.map((ruleInput) => {
            return new rulesets_base_1.SpectralRule({
                name: 'Spectral Rules applied to changes to the specification: ' +
                    ruleInput,
                flatSpecFile: absolutePathTmpSpec,
                applies: 'changed',
                rulesetPointer: ruleInput,
                matches: this.options.matches,
            });
        });
        const addedOrChanged = this.options.addedOrChanged.flatMap((ruleInput) => {
            return [
                new rulesets_base_1.SpectralRule({
                    name: 'Spectral Rules applied to additions to the specification: ' +
                        ruleInput,
                    flatSpecFile: absolutePathTmpSpec,
                    applies: 'added',
                    rulesetPointer: ruleInput,
                    matches: this.options.matches,
                }),
                new rulesets_base_1.SpectralRule({
                    name: 'Spectral Rules applied to changes to the specification: ' +
                        ruleInput,
                    flatSpecFile: absolutePathTmpSpec,
                    applies: 'changed',
                    rulesetPointer: ruleInput,
                    matches: this.options.matches,
                }),
            ];
        });
        const always = this.options.always.map((ruleInput) => {
            return new rulesets_base_1.SpectralRule({
                name: 'Spectral Rules applied to entire specification: ' + ruleInput,
                flatSpecFile: absolutePathTmpSpec,
                applies: 'always',
                rulesetPointer: ruleInput,
                matches: this.options.matches,
            });
        });
        const allRulesets = [...always, ...added, ...changed, ...addedOrChanged];
        const allResults = await Promise.all(allRulesets.map((ruleset) => ruleset.runRules(inputs)));
        // remove tmp spec
        await promises_1.default.unlink(absolutePathTmpSpec);
        return allResults.flat(1);
    }
    async runRulesV2(inputs) {
        const absolutePathTmpSpec = path_1.default.join(os_1.default.tmpdir(), `optic-next-spec-${Math.floor(Math.random() * 100000)}.json`);
        // write one tmp spec for all the spectral runs to use
        await promises_1.default.writeFile(absolutePathTmpSpec, JSON.stringify(inputs.toSpec));
        const added = this.options.added.map((ruleInput) => {
            return new rulesets_base_1.SpectralRule({
                name: 'Spectral Rules applied to additions to the specification: ' +
                    ruleInput,
                flatSpecFile: absolutePathTmpSpec,
                applies: 'added',
                rulesetPointer: ruleInput,
                matches: this.options.matches,
            });
        });
        const always = this.options.always.map((ruleInput) => {
            return new rulesets_base_1.SpectralRule({
                name: 'Spectral Rules applied to entire specification: ' + ruleInput,
                flatSpecFile: absolutePathTmpSpec,
                applies: 'always',
                rulesetPointer: ruleInput,
                matches: this.options.matches,
            });
        });
        const changed = this.options.changed.map((ruleInput) => {
            return new rulesets_base_1.SpectralRule({
                name: 'Spectral Rules applied to changes to the specification: ' +
                    ruleInput,
                flatSpecFile: absolutePathTmpSpec,
                applies: 'changed',
                rulesetPointer: ruleInput,
                matches: this.options.matches,
            });
        });
        const addedOrChanged = this.options.addedOrChanged.flatMap((ruleInput) => {
            return [
                new rulesets_base_1.SpectralRule({
                    name: 'Spectral Rules applied to additions to the specification: ' +
                        ruleInput,
                    flatSpecFile: absolutePathTmpSpec,
                    applies: 'added',
                    rulesetPointer: ruleInput,
                    matches: this.options.matches,
                }),
                new rulesets_base_1.SpectralRule({
                    name: 'Spectral Rules applied to changes to the specification: ' +
                        ruleInput,
                    flatSpecFile: absolutePathTmpSpec,
                    applies: 'changed',
                    rulesetPointer: ruleInput,
                    matches: this.options.matches,
                }),
            ];
        });
        const allRulesets = [...always, ...added, ...changed, ...addedOrChanged];
        const allResults = await Promise.all(allRulesets.map((ruleset) => ruleset.runRulesV2(inputs)));
        // remove tmp spec
        await promises_1.default.unlink(absolutePathTmpSpec);
        return allResults.flat(1);
    }
    static async fromOpticConfig(config) {
        const result = validateConfigSchema(config);
        if (!result && validateConfigSchema.errors) {
            return validateConfigSchema.errors
                .map((error) => {
                return `- ruleset/spectral${error.instancePath} ${error.message}`;
            })
                .join('\n- ');
        }
        const validatedConfig = config;
        let matches = undefined;
        if (validatedConfig.exclude_operations_with_extension !== undefined) {
            matches = (0, utils_1.excludeOperationWithExtensionMatches)(validatedConfig.exclude_operations_with_extension);
        }
        return new SpectralRulesets({
            added: validatedConfig.added ?? [],
            always: validatedConfig.always ?? [],
            changed: validatedConfig.changed ?? [],
            addedOrChanged: validatedConfig.addedOrChanged ?? [],
            matches,
        });
    }
}
exports.SpectralRulesets = SpectralRulesets;
//# sourceMappingURL=index.js.map